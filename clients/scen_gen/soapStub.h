/* soapStub.h
   Generated by gSOAP 2.8.3 from enrima.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns2	"http://www.ime.iiasa.ac.at/model/spec"
#define SOAP_NAMESPACE_OF_ns3	"http://www.ime.iiasa.ac.at/model/instance"
#define SOAP_NAMESPACE_OF_ns4	"http://www.ime.iiasa.ac.at/model/analysis"
#define SOAP_NAMESPACE_OF_ns1	"http://www.ime.iiasa.ac.at/enrima"
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns2__status
#define SOAP_TYPE_ns2__status (71)
/* ns2:status */
enum ns2__status {ns2__status__EDIT = 0, ns2__status__TEST = 1, ns2__status__COMMITED = 2};
#endif

#ifndef SOAP_TYPE_ns2__setSpecType
#define SOAP_TYPE_ns2__setSpecType (72)
/* ns2:setSpecType */
enum ns2__setSpecType {ns2__setSpecType__MAINSET = 0, ns2__setSpecType__SUBSET = 1, ns2__setSpecType__INDEXEDSUBSET = 2};
#endif

#ifndef SOAP_TYPE_ns2__entityRole
#define SOAP_TYPE_ns2__entityRole (73)
/* ns2:entityRole */
enum ns2__entityRole {ns2__entityRole__CONSTANT = 0, ns2__entityRole__PARAMETER = 1, ns2__entityRole__DECISION_USCOREVAR = 2, ns2__entityRole__EXTERNAL_USCOREDECISION_USCOREVAR = 3, ns2__entityRole__OUTCOME_USCOREVAR = 4, ns2__entityRole__AUXILIARY_USCOREVAR = 5, ns2__entityRole__ASSIGNMENT = 6, ns2__entityRole__CONSTRAINT = 7, ns2__entityRole__A_USCOREVARIABLE = 8, ns2__entityRole__A_USCOREFORMULA = 9};
#endif

#ifndef SOAP_TYPE_ns2__mathType
#define SOAP_TYPE_ns2__mathType (74)
/* ns2:mathType */
enum ns2__mathType {ns2__mathType__INTEGER = 0, ns2__mathType__REAL = 1};
#endif

#ifndef SOAP_TYPE_ns4__preferenceType
#define SOAP_TYPE_ns4__preferenceType (79)
/* ns4:preferenceType */
enum ns4__preferenceType {ns4__preferenceType__MIN = 0, ns4__preferenceType__MAX = 1, ns4__preferenceType__LOWER_USCOREBND = 2, ns4__preferenceType__UPPER_USCOREBND = 3};
#endif

#ifndef SOAP_TYPE_ns1__responseStatus
#define SOAP_TYPE_ns1__responseStatus (80)
/* ns1:responseStatus */
enum ns1__responseStatus {ns1__responseStatus__OK = 0, ns1__responseStatus__INVALID_USCORESETNAME = 1, ns1__responseStatus__INVALID_USCOREDATAUPDATE = 2, ns1__responseStatus__INVALID_USCOREITERATOR = 3, ns1__responseStatus__INVALID_USCORESET_USCOREMEMBER = 4, ns1__responseStatus__INVALID_USCOREVALUE = 5, ns1__responseStatus__INVALID_USCOREENTITYNAME = 6, ns1__responseStatus__BOUND_USCOREVIOLATION = 7, ns1__responseStatus__UNKOWN_USCOREEXECEPTION = 8};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns2__modelSpec
#define SOAP_TYPE_ns2__modelSpec (8)
/* ns2:modelSpec */
class SOAP_CMAC ns2__modelSpec
{
public:
	int *id;	/* optional element of type xsd:int */
	std::string shortName;	/* required element of type ns2:shortName */
	std::string *name;	/* optional element of type ns2:name */
	std::string *description;	/* optional element of type ns2:description */
	enum ns2__status status;	/* required element of type ns2:status */
	std::vector<class ns2__setSpec * >setSpec;	/* required element of type ns2:setSpec */
	std::vector<class ns2__entitySpec * >entitySpec;	/* required element of type ns2:entitySpec */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_ns2__modelSpec */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__modelSpec() { ns2__modelSpec::soap_default(NULL); }
	virtual ~ns2__modelSpec() { }
};
#endif

#ifndef SOAP_TYPE_ns2__setSpec
#define SOAP_TYPE_ns2__setSpec (9)
/* ns2:setSpec */
class SOAP_CMAC ns2__setSpec
{
public:
	int *id;	/* optional element of type xsd:int */
	int *idParent;	/* optional element of type xsd:int */
	std::string shortName;	/* required element of type ns2:shortName */
	std::string *name;	/* optional element of type ns2:name */
	std::string *description;	/* optional element of type ns2:description */
	enum ns2__setSpecType type;	/* required element of type ns2:setSpecType */
	std::string *idx;	/* optional element of type xsd:string */
	class ns2__iteratorContainer *iteratorContainer;	/* optional element of type ns2:iteratorContainer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_ns2__setSpec */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__setSpec() { ns2__setSpec::soap_default(NULL); }
	virtual ~ns2__setSpec() { }
};
#endif

#ifndef SOAP_TYPE_ns2__entitySpec
#define SOAP_TYPE_ns2__entitySpec (10)
/* ns2:entitySpec */
class SOAP_CMAC ns2__entitySpec
{
public:
	int *id;	/* optional element of type xsd:int */
	std::string shortName;	/* required element of type ns2:shortName */
	std::string *name;	/* optional element of type ns2:name */
	std::string *description;	/* optional element of type ns2:description */
	int *idLowerBound;	/* optional element of type xsd:int */
	int *idUpperBound;	/* optional element of type xsd:int */
	double *constantValue;	/* optional element of type xsd:double */
	ns2__iteratorContainer *iteratorContainer;	/* optional element of type ns2:iteratorContainer */
	enum ns2__entityRole *role;	/* optional element of type ns2:entityRole */
	enum ns2__mathType mathType;	/* required element of type ns2:mathType */
	std::string *unit;	/* optional element of type xsd:string */
	std::string *formula;	/* optional element of type xsd:string */
	std::string *source;	/* optional element of type xsd:string */
	std::vector<std::string >group;	/* optional element of type xsd:string */
	std::string *modelSpec;	/* optional element of type xsd:string */
	std::vector<std::string >batch;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_ns2__entitySpec */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__entitySpec() { ns2__entitySpec::soap_default(NULL); }
	virtual ~ns2__entitySpec() { }
};
#endif

#ifndef SOAP_TYPE_ns2__iteratorContainer
#define SOAP_TYPE_ns2__iteratorContainer (11)
/* ns2:iteratorContainer */
class SOAP_CMAC ns2__iteratorContainer
{
public:
	std::vector<int >idSetSpec;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_ns2__iteratorContainer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__iteratorContainer() { ns2__iteratorContainer::soap_default(NULL); }
	virtual ~ns2__iteratorContainer() { }
};
#endif

#ifndef SOAP_TYPE_ns3__modelData
#define SOAP_TYPE_ns3__modelData (12)
/* ns3:modelData */
class SOAP_CMAC ns3__modelData
{
public:
	int *id;	/* optional element of type xsd:int */
	std::vector<int >idModelSpec;	/* required element of type xsd:int */
	int *idParent;	/* optional element of type xsd:int */
	std::string *description;	/* optional element of type ns2:description */
	enum ns2__status status;	/* required element of type ns2:status */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ns3__modelData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__modelData() { ns3__modelData::soap_default(NULL); }
	virtual ~ns3__modelData() { }
};
#endif

#ifndef SOAP_TYPE_ns3__modelInstance
#define SOAP_TYPE_ns3__modelInstance (13)
/* ns3:modelInstance */
class SOAP_CMAC ns3__modelInstance
{
public:
	int *id;	/* optional element of type xsd:int */
	int idModelSpec;	/* required element of type xsd:int */
	int idModelData;	/* required element of type xsd:int */
	std::string *shortName;	/* optional element of type ns2:shortName */
	std::string *name;	/* optional element of type ns2:name */
	std::string *description;	/* optional element of type ns2:description */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_ns3__modelInstance */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__modelInstance() { ns3__modelInstance::soap_default(NULL); }
	virtual ~ns3__modelInstance() { }
};
#endif

#ifndef SOAP_TYPE_ns3__memberDic
#define SOAP_TYPE_ns3__memberDic (14)
/* ns3:memberDic */
class SOAP_CMAC ns3__memberDic
{
public:
	int *id;	/* optional element of type xsd:int */
	std::string code;	/* required element of type ns2:name */
	std::string *description;	/* optional element of type ns2:description */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ns3__memberDic */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__memberDic() { ns3__memberDic::soap_default(NULL); }
	virtual ~ns3__memberDic() { }
};
#endif

#ifndef SOAP_TYPE_ns3__tupleValue
#define SOAP_TYPE_ns3__tupleValue (15)
/* ns3:tupleValue */
class SOAP_CMAC ns3__tupleValue
{
public:
	std::vector<ns3__memberDic * >tupleMember;	/* optional element of type ns3:memberDic */
	class ns3__value *value;	/* required element of type ns3:value */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_ns3__tupleValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__tupleValue() { ns3__tupleValue::soap_default(NULL); }
	virtual ~ns3__tupleValue() { }
};
#endif

#ifndef SOAP_TYPE_ns3__setMembers
#define SOAP_TYPE_ns3__setMembers (16)
/* ns3:setMembers */
class SOAP_CMAC ns3__setMembers
{
public:
	std::string setShortName;	/* required element of type xsd:string */
	std::vector<class ns3__tupleMembers * >tupleMembers;	/* optional element of type ns3:tupleMembers */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns3__setMembers */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__setMembers() { ns3__setMembers::soap_default(NULL); }
	virtual ~ns3__setMembers() { }
};
#endif

#ifndef SOAP_TYPE_ns3__tupleMembers
#define SOAP_TYPE_ns3__tupleMembers (17)
/* ns3:tupleMembers */
class SOAP_CMAC ns3__tupleMembers
{
public:
	std::string *tuple;	/* optional element of type xsd:string */
	std::string members;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns3__tupleMembers */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__tupleMembers() { ns3__tupleMembers::soap_default(NULL); }
	virtual ~ns3__tupleMembers() { }
};
#endif

#ifndef SOAP_TYPE_ns3__entityValues
#define SOAP_TYPE_ns3__entityValues (18)
/* ns3:entityValues */
class SOAP_CMAC ns3__entityValues
{
public:
	std::string entityShortName;	/* required element of type xsd:string */
	std::vector<class ns3__tupleValues * >tupleValues;	/* optional element of type ns3:tupleValues */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns3__entityValues */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__entityValues() { ns3__entityValues::soap_default(NULL); }
	virtual ~ns3__entityValues() { }
};
#endif

#ifndef SOAP_TYPE_ns3__tupleValues
#define SOAP_TYPE_ns3__tupleValues (19)
/* ns3:tupleValues */
class SOAP_CMAC ns3__tupleValues
{
public:
	std::string *tuple;	/* optional element of type xsd:string */
	ns3__value *value;	/* required element of type ns3:value */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ns3__tupleValues */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__tupleValues() { ns3__tupleValues::soap_default(NULL); }
	virtual ~ns3__tupleValues() { }
};
#endif

#ifndef SOAP_TYPE_ns3__batchValues
#define SOAP_TYPE_ns3__batchValues (20)
/* ns3:batchValues */
class SOAP_CMAC ns3__batchValues
{
public:
	std::vector<ns3__memberDic * >tupleMember;	/* optional element of type ns3:memberDic */
	std::vector<ns3__value * >value;	/* optional element of type ns3:value */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ns3__batchValues */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__batchValues() { ns3__batchValues::soap_default(NULL); }
	virtual ~ns3__batchValues() { }
};
#endif

#ifndef SOAP_TYPE__ns3__union_value
#define SOAP_TYPE__ns3__union_value (105)
/* xsd:choice */
union _ns3__union_value
{
#define SOAP_UNION__ns3__union_value_intValue	(1)
	int intValue;
#define SOAP_UNION__ns3__union_value_doubleValue	(2)
	double doubleValue;
};
#endif

#ifndef SOAP_TYPE_ns3__value
#define SOAP_TYPE_ns3__value (21)
/* Choice: */
class SOAP_CMAC ns3__value
{
public:
	int __union_value;	/* union discriminant (of union defined below) */
	union _ns3__union_value union_value;	/* required element of type xsd:choice */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ns3__value */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__value() { ns3__value::soap_default(NULL); }
	virtual ~ns3__value() { }
};
#endif

#ifndef SOAP_TYPE__ns3__dataSet
#define SOAP_TYPE__ns3__dataSet (22)
/* ns3:dataSet */
class SOAP_CMAC _ns3__dataSet
{
public:
	std::vector<ns3__setMembers * >setMembers;	/* required element of type ns3:setMembers */
	std::vector<ns3__entityValues * >entityValues;	/* required element of type ns3:entityValues */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE__ns3__dataSet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__dataSet() { _ns3__dataSet::soap_default(NULL); }
	virtual ~_ns3__dataSet() { }
};
#endif

#ifndef SOAP_TYPE_ns4__analysis
#define SOAP_TYPE_ns4__analysis (23)
/* ns4:analysis */
class SOAP_CMAC ns4__analysis
{
public:
	int *id;	/* optional element of type xsd:int */
	int idModelInstance;	/* required element of type xsd:int */
	std::string shortName;	/* required element of type ns2:shortName */
	std::string *name;	/* optional element of type ns2:name */
	std::string *description;	/* optional element of type ns2:description */
	std::string status;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns4__analysis */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__analysis() { ns4__analysis::soap_default(NULL); }
	virtual ~ns4__analysis() { }
};
#endif

#ifndef SOAP_TYPE_ns4__preference
#define SOAP_TYPE_ns4__preference (24)
/* ns4:preference */
class SOAP_CMAC ns4__preference
{
public:
	int idEntitySpec;	/* required element of type xsd:int */
	enum ns4__preferenceType preferenceType;	/* required element of type ns4:preferenceType */
	double *prefValue;	/* optional element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns4__preference */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__preference() { ns4__preference::soap_default(NULL); }
	virtual ~ns4__preference() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getSMSRequest
#define SOAP_TYPE__ns1__getSMSRequest (25)
/* ns1:getSMSRequest */
class SOAP_CMAC _ns1__getSMSRequest
{
public:
	int idModelSpec;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE__ns1__getSMSRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getSMSRequest() { _ns1__getSMSRequest::soap_default(NULL); }
	virtual ~_ns1__getSMSRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getSMSResponse
#define SOAP_TYPE__ns1__getSMSResponse (26)
/* ns1:getSMSResponse */
class SOAP_CMAC _ns1__getSMSResponse
{
public:
	ns2__modelSpec *modelSpec;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:modelSpec */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE__ns1__getSMSResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getSMSResponse() { _ns1__getSMSResponse::soap_default(NULL); }
	virtual ~_ns1__getSMSResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getEntityValuesRequest
#define SOAP_TYPE__ns1__getEntityValuesRequest (27)
/* ns1:getEntityValuesRequest */
class SOAP_CMAC _ns1__getEntityValuesRequest
{
public:
	int idModelSpec;	/* required element of type xsd:int */
	int idModelData;	/* required element of type xsd:int */
	std::string entityShortName;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE__ns1__getEntityValuesRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getEntityValuesRequest() { _ns1__getEntityValuesRequest::soap_default(NULL); }
	virtual ~_ns1__getEntityValuesRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getEntityValuesResponse
#define SOAP_TYPE__ns1__getEntityValuesResponse (28)
/* ns1:getEntityValuesResponse */
class SOAP_CMAC _ns1__getEntityValuesResponse
{
public:
	ns2__entitySpec *entitySpec;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:entitySpec */
	std::vector<ns3__tupleValue * >tupleValue;	/* optional element of type ns3:tupleValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE__ns1__getEntityValuesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getEntityValuesResponse() { _ns1__getEntityValuesResponse::soap_default(NULL); }
	virtual ~_ns1__getEntityValuesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getBatchValuesRequest
#define SOAP_TYPE__ns1__getBatchValuesRequest (29)
/* ns1:getBatchValuesRequest */
class SOAP_CMAC _ns1__getBatchValuesRequest
{
public:
	int idModelSpec;	/* required element of type xsd:int */
	int idModelData;	/* required element of type xsd:int */
	std::string batch;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE__ns1__getBatchValuesRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getBatchValuesRequest() { _ns1__getBatchValuesRequest::soap_default(NULL); }
	virtual ~_ns1__getBatchValuesRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getBatchValuesResponse
#define SOAP_TYPE__ns1__getBatchValuesResponse (30)
/* ns1:getBatchValuesResponse */
class SOAP_CMAC _ns1__getBatchValuesResponse
{
public:
	int idModelData;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	std::vector<ns2__entitySpec * >entitySpec;	/* optional element of type ns2:entitySpec */
	std::vector<ns3__batchValues * >batchValues;	/* optional element of type ns3:batchValues */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE__ns1__getBatchValuesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getBatchValuesResponse() { _ns1__getBatchValuesResponse::soap_default(NULL); }
	virtual ~_ns1__getBatchValuesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getSetMembersRequest
#define SOAP_TYPE__ns1__getSetMembersRequest (31)
/* ns1:getSetMembersRequest */
class SOAP_CMAC _ns1__getSetMembersRequest
{
public:
	int idModelData;	/* required element of type xsd:int */
	std::string setShortName;	/* required element of type xsd:string */
	std::vector<ns3__memberDic * >tupleMember;	/* optional element of type ns3:memberDic */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE__ns1__getSetMembersRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getSetMembersRequest() { _ns1__getSetMembersRequest::soap_default(NULL); }
	virtual ~_ns1__getSetMembersRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getSetMembersResponse
#define SOAP_TYPE__ns1__getSetMembersResponse (32)
/* ns1:getSetMembersResponse */
class SOAP_CMAC _ns1__getSetMembersResponse
{
public:
	std::vector<ns3__memberDic * >member;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns3:memberDic */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE__ns1__getSetMembersResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getSetMembersResponse() { _ns1__getSetMembersResponse::soap_default(NULL); }
	virtual ~_ns1__getSetMembersResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__storeMainSetRequest
#define SOAP_TYPE__ns1__storeMainSetRequest (33)
/* ns1:storeMainSetRequest */
class SOAP_CMAC _ns1__storeMainSetRequest
{
public:
	int idModeldata;	/* required element of type xsd:int */
	std::string setShortName;	/* required element of type xsd:string */
	std::vector<ns3__memberDic * >member;	/* required element of type ns3:memberDic */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE__ns1__storeMainSetRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__storeMainSetRequest() { _ns1__storeMainSetRequest::soap_default(NULL); }
	virtual ~_ns1__storeMainSetRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__storeMainSetResponse
#define SOAP_TYPE__ns1__storeMainSetResponse (34)
/* ns1:storeMainSetResponse */
class SOAP_CMAC _ns1__storeMainSetResponse
{
public:
	enum ns1__responseStatus status;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:responseStatus */
	std::string *msg;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE__ns1__storeMainSetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__storeMainSetResponse() { _ns1__storeMainSetResponse::soap_default(NULL); }
	virtual ~_ns1__storeMainSetResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__storeSetMembersRequest
#define SOAP_TYPE__ns1__storeSetMembersRequest (35)
/* ns1:storeSetMembersRequest */
class SOAP_CMAC _ns1__storeSetMembersRequest
{
public:
	int idModeldata;	/* required element of type xsd:int */
	std::vector<ns3__setMembers * >setMembers;	/* required element of type ns3:setMembers */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE__ns1__storeSetMembersRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__storeSetMembersRequest() { _ns1__storeSetMembersRequest::soap_default(NULL); }
	virtual ~_ns1__storeSetMembersRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__storeSetMembersResponse
#define SOAP_TYPE__ns1__storeSetMembersResponse (36)
/* ns1:storeSetMembersResponse */
class SOAP_CMAC _ns1__storeSetMembersResponse
{
public:
	enum ns1__responseStatus status;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:responseStatus */
	std::string *msg;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE__ns1__storeSetMembersResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__storeSetMembersResponse() { _ns1__storeSetMembersResponse::soap_default(NULL); }
	virtual ~_ns1__storeSetMembersResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__removeSetMembersRequest
#define SOAP_TYPE__ns1__removeSetMembersRequest (37)
/* ns1:removeSetMembersRequest */
class SOAP_CMAC _ns1__removeSetMembersRequest
{
public:
	int idModeldata;	/* required element of type xsd:int */
	std::vector<ns3__setMembers * >setMembers;	/* required element of type ns3:setMembers */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE__ns1__removeSetMembersRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__removeSetMembersRequest() { _ns1__removeSetMembersRequest::soap_default(NULL); }
	virtual ~_ns1__removeSetMembersRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__removeSetMembersResponse
#define SOAP_TYPE__ns1__removeSetMembersResponse (38)
/* ns1:removeSetMembersResponse */
class SOAP_CMAC _ns1__removeSetMembersResponse
{
public:
	enum ns1__responseStatus status;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:responseStatus */
	std::string *msg;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE__ns1__removeSetMembersResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__removeSetMembersResponse() { _ns1__removeSetMembersResponse::soap_default(NULL); }
	virtual ~_ns1__removeSetMembersResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__storeEntityValuesRequest
#define SOAP_TYPE__ns1__storeEntityValuesRequest (39)
/* ns1:storeEntityValuesRequest */
class SOAP_CMAC _ns1__storeEntityValuesRequest
{
public:
	int idModelSpec;	/* required element of type xsd:int */
	int idModeldata;	/* required element of type xsd:int */
	std::vector<ns3__entityValues * >entityValues;	/* optional element of type ns3:entityValues */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE__ns1__storeEntityValuesRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__storeEntityValuesRequest() { _ns1__storeEntityValuesRequest::soap_default(NULL); }
	virtual ~_ns1__storeEntityValuesRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__storeEntityValuesResponse
#define SOAP_TYPE__ns1__storeEntityValuesResponse (40)
/* ns1:storeEntityValuesResponse */
class SOAP_CMAC _ns1__storeEntityValuesResponse
{
public:
	enum ns1__responseStatus status;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:responseStatus */
	std::string *msg;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE__ns1__storeEntityValuesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__storeEntityValuesResponse() { _ns1__storeEntityValuesResponse::soap_default(NULL); }
	virtual ~_ns1__storeEntityValuesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__removeEntityValuesRequest
#define SOAP_TYPE__ns1__removeEntityValuesRequest (41)
/* ns1:removeEntityValuesRequest */
class SOAP_CMAC _ns1__removeEntityValuesRequest
{
public:
	int idModelSpec;	/* required element of type xsd:int */
	int idModeldata;	/* required element of type xsd:int */
	std::vector<ns3__entityValues * >entityValues;	/* optional element of type ns3:entityValues */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE__ns1__removeEntityValuesRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__removeEntityValuesRequest() { _ns1__removeEntityValuesRequest::soap_default(NULL); }
	virtual ~_ns1__removeEntityValuesRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__removeEntityValuesResponse
#define SOAP_TYPE__ns1__removeEntityValuesResponse (42)
/* ns1:removeEntityValuesResponse */
class SOAP_CMAC _ns1__removeEntityValuesResponse
{
public:
	enum ns1__responseStatus status;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:responseStatus */
	std::string *msg;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE__ns1__removeEntityValuesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__removeEntityValuesResponse() { _ns1__removeEntityValuesResponse::soap_default(NULL); }
	virtual ~_ns1__removeEntityValuesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__defineModelDataRequest
#define SOAP_TYPE__ns1__defineModelDataRequest (43)
/* ns1:defineModelDataRequest */
class SOAP_CMAC _ns1__defineModelDataRequest
{
public:
	ns3__modelData *modelData;	/* required element of type ns3:modelData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE__ns1__defineModelDataRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__defineModelDataRequest() { _ns1__defineModelDataRequest::soap_default(NULL); }
	virtual ~_ns1__defineModelDataRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__defineModelDataResponse
#define SOAP_TYPE__ns1__defineModelDataResponse (44)
/* ns1:defineModelDataResponse */
class SOAP_CMAC _ns1__defineModelDataResponse
{
public:
	ns3__modelData *modelData;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns3:modelData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE__ns1__defineModelDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__defineModelDataResponse() { _ns1__defineModelDataResponse::soap_default(NULL); }
	virtual ~_ns1__defineModelDataResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__changeModelDataStatusRequest
#define SOAP_TYPE__ns1__changeModelDataStatusRequest (45)
/* ns1:changeModelDataStatusRequest */
class SOAP_CMAC _ns1__changeModelDataStatusRequest
{
public:
	int idModelData;	/* required element of type xsd:int */
	enum ns2__status status;	/* required element of type ns2:status */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE__ns1__changeModelDataStatusRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__changeModelDataStatusRequest() { _ns1__changeModelDataStatusRequest::soap_default(NULL); }
	virtual ~_ns1__changeModelDataStatusRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__changeModelDataStatusResponse
#define SOAP_TYPE__ns1__changeModelDataStatusResponse (46)
/* ns1:changeModelDataStatusResponse */
class SOAP_CMAC _ns1__changeModelDataStatusResponse
{
public:
	std::string result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE__ns1__changeModelDataStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__changeModelDataStatusResponse() { _ns1__changeModelDataStatusResponse::soap_default(NULL); }
	virtual ~_ns1__changeModelDataStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__defineInstanceRequest
#define SOAP_TYPE__ns1__defineInstanceRequest (47)
/* ns1:defineInstanceRequest */
class SOAP_CMAC _ns1__defineInstanceRequest
{
public:
	ns3__modelInstance *modelInstance;	/* required element of type ns3:modelInstance */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE__ns1__defineInstanceRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__defineInstanceRequest() { _ns1__defineInstanceRequest::soap_default(NULL); }
	virtual ~_ns1__defineInstanceRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__defineInstanceResponse
#define SOAP_TYPE__ns1__defineInstanceResponse (48)
/* ns1:defineInstanceResponse */
class SOAP_CMAC _ns1__defineInstanceResponse
{
public:
	ns3__modelInstance *modelInstance;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns3:modelInstance */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE__ns1__defineInstanceResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__defineInstanceResponse() { _ns1__defineInstanceResponse::soap_default(NULL); }
	virtual ~_ns1__defineInstanceResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getDataSummaryRequest
#define SOAP_TYPE__ns1__getDataSummaryRequest (49)
/* ns1:getDataSummaryRequest */
class SOAP_CMAC _ns1__getDataSummaryRequest
{
public:
	int idModelData;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE__ns1__getDataSummaryRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getDataSummaryRequest() { _ns1__getDataSummaryRequest::soap_default(NULL); }
	virtual ~_ns1__getDataSummaryRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getDataSummaryResponse
#define SOAP_TYPE__ns1__getDataSummaryResponse (50)
/* ns1:getDataSummaryResponse */
class SOAP_CMAC _ns1__getDataSummaryResponse
{
public:
	ns3__modelData *modelData;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns3:modelData */
	std::vector<ns3__modelInstance * >modelInstance;	/* optional element of type ns3:modelInstance */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE__ns1__getDataSummaryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getDataSummaryResponse() { _ns1__getDataSummaryResponse::soap_default(NULL); }
	virtual ~_ns1__getDataSummaryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__defineAnalysisRequest
#define SOAP_TYPE__ns1__defineAnalysisRequest (51)
/* ns1:defineAnalysisRequest */
class SOAP_CMAC _ns1__defineAnalysisRequest
{
public:
	ns4__analysis *analysis;	/* required element of type ns4:analysis */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE__ns1__defineAnalysisRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__defineAnalysisRequest() { _ns1__defineAnalysisRequest::soap_default(NULL); }
	virtual ~_ns1__defineAnalysisRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__defineAnalysisResponse
#define SOAP_TYPE__ns1__defineAnalysisResponse (52)
/* ns1:defineAnalysisResponse */
class SOAP_CMAC _ns1__defineAnalysisResponse
{
public:
	ns4__analysis *analysis;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns4:analysis */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE__ns1__defineAnalysisResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__defineAnalysisResponse() { _ns1__defineAnalysisResponse::soap_default(NULL); }
	virtual ~_ns1__defineAnalysisResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getAnalysesRequest
#define SOAP_TYPE__ns1__getAnalysesRequest (53)
/* ns1:getAnalysesRequest */
class SOAP_CMAC _ns1__getAnalysesRequest
{
public:
	int idModelInstance;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE__ns1__getAnalysesRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getAnalysesRequest() { _ns1__getAnalysesRequest::soap_default(NULL); }
	virtual ~_ns1__getAnalysesRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getAnalysesResponse
#define SOAP_TYPE__ns1__getAnalysesResponse (54)
/* ns1:getAnalysesResponse */
class SOAP_CMAC _ns1__getAnalysesResponse
{
public:
	std::vector<ns4__analysis * >analysis;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns4:analysis */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE__ns1__getAnalysesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getAnalysesResponse() { _ns1__getAnalysesResponse::soap_default(NULL); }
	virtual ~_ns1__getAnalysesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__definePreferenceRequest
#define SOAP_TYPE__ns1__definePreferenceRequest (55)
/* ns1:definePreferenceRequest */
class SOAP_CMAC _ns1__definePreferenceRequest
{
public:
	int idAnalysis;	/* required element of type xsd:int */
	std::vector<ns4__preference * >preference;	/* optional element of type ns4:preference */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE__ns1__definePreferenceRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__definePreferenceRequest() { _ns1__definePreferenceRequest::soap_default(NULL); }
	virtual ~_ns1__definePreferenceRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__definePreferenceResponse
#define SOAP_TYPE__ns1__definePreferenceResponse (56)
/* ns1:definePreferenceResponse */
class SOAP_CMAC _ns1__definePreferenceResponse
{
public:
	std::string result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE__ns1__definePreferenceResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__definePreferenceResponse() { _ns1__definePreferenceResponse::soap_default(NULL); }
	virtual ~_ns1__definePreferenceResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getPreferenceRequest
#define SOAP_TYPE__ns1__getPreferenceRequest (57)
/* ns1:getPreferenceRequest */
class SOAP_CMAC _ns1__getPreferenceRequest
{
public:
	int idAnalysis;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE__ns1__getPreferenceRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getPreferenceRequest() { _ns1__getPreferenceRequest::soap_default(NULL); }
	virtual ~_ns1__getPreferenceRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getPreferenceResponse
#define SOAP_TYPE__ns1__getPreferenceResponse (58)
/* ns1:getPreferenceResponse */
class SOAP_CMAC _ns1__getPreferenceResponse
{
public:
	int idModelSpec;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	int idModelData;	/* required element of type xsd:int */
	int idAnalysis;	/* required element of type xsd:int */
	std::vector<ns4__preference * >preference;	/* optional element of type ns4:preference */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE__ns1__getPreferenceResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getPreferenceResponse() { _ns1__getPreferenceResponse::soap_default(NULL); }
	virtual ~_ns1__getPreferenceResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__storeSolutionRequest
#define SOAP_TYPE__ns1__storeSolutionRequest (59)
/* ns1:storeSolutionRequest */
class SOAP_CMAC _ns1__storeSolutionRequest
{
public:
	int idAnalysis;	/* required element of type xsd:int */
	std::vector<ns3__entityValues * >entityValues;	/* optional element of type ns3:entityValues */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE__ns1__storeSolutionRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__storeSolutionRequest() { _ns1__storeSolutionRequest::soap_default(NULL); }
	virtual ~_ns1__storeSolutionRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__storeSolutionResponse
#define SOAP_TYPE__ns1__storeSolutionResponse (60)
/* ns1:storeSolutionResponse */
class SOAP_CMAC _ns1__storeSolutionResponse
{
public:
	std::string result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE__ns1__storeSolutionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__storeSolutionResponse() { _ns1__storeSolutionResponse::soap_default(NULL); }
	virtual ~_ns1__storeSolutionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getSolutionRequest
#define SOAP_TYPE__ns1__getSolutionRequest (61)
/* ns1:getSolutionRequest */
class SOAP_CMAC _ns1__getSolutionRequest
{
public:
	int idAnalysis;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE__ns1__getSolutionRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getSolutionRequest() { _ns1__getSolutionRequest::soap_default(NULL); }
	virtual ~_ns1__getSolutionRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getSolutionResponse
#define SOAP_TYPE__ns1__getSolutionResponse (62)
/* ns1:getSolutionResponse */
class SOAP_CMAC _ns1__getSolutionResponse
{
public:
	int idAnalysis;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	std::vector<ns3__entityValues * >entityValues;	/* optional element of type ns3:entityValues */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE__ns1__getSolutionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getSolutionResponse() { _ns1__getSolutionResponse::soap_default(NULL); }
	virtual ~_ns1__getSolutionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__updateSolverStatusRequest
#define SOAP_TYPE__ns1__updateSolverStatusRequest (63)
/* ns1:updateSolverStatusRequest */
class SOAP_CMAC _ns1__updateSolverStatusRequest
{
public:
	int idAnalysis;	/* required element of type xsd:int */
	std::string status;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE__ns1__updateSolverStatusRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__updateSolverStatusRequest() { _ns1__updateSolverStatusRequest::soap_default(NULL); }
	virtual ~_ns1__updateSolverStatusRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__updateSolverStatusResponse
#define SOAP_TYPE__ns1__updateSolverStatusResponse (64)
/* ns1:updateSolverStatusResponse */
class SOAP_CMAC _ns1__updateSolverStatusResponse
{
public:
	std::string result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE__ns1__updateSolverStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__updateSolverStatusResponse() { _ns1__updateSolverStatusResponse::soap_default(NULL); }
	virtual ~_ns1__updateSolverStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getSolverStatusRequest
#define SOAP_TYPE__ns1__getSolverStatusRequest (65)
/* ns1:getSolverStatusRequest */
class SOAP_CMAC _ns1__getSolverStatusRequest
{
public:
	int idAnalysis;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE__ns1__getSolverStatusRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getSolverStatusRequest() { _ns1__getSolverStatusRequest::soap_default(NULL); }
	virtual ~_ns1__getSolverStatusRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getSolverStatusResponse
#define SOAP_TYPE__ns1__getSolverStatusResponse (66)
/* ns1:getSolverStatusResponse */
class SOAP_CMAC _ns1__getSolverStatusResponse
{
public:
	std::string result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE__ns1__getSolverStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getSolverStatusResponse() { _ns1__getSolverStatusResponse::soap_default(NULL); }
	virtual ~_ns1__getSolverStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__runSolverRequest
#define SOAP_TYPE__ns1__runSolverRequest (67)
/* ns1:runSolverRequest */
class SOAP_CMAC _ns1__runSolverRequest
{
public:
	int idAnalysis;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE__ns1__runSolverRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__runSolverRequest() { _ns1__runSolverRequest::soap_default(NULL); }
	virtual ~_ns1__runSolverRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__runSolverResponse
#define SOAP_TYPE__ns1__runSolverResponse (68)
/* ns1:runSolverResponse */
class SOAP_CMAC _ns1__runSolverResponse
{
public:
	std::string result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE__ns1__runSolverResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__runSolverResponse() { _ns1__runSolverResponse::soap_default(NULL); }
	virtual ~_ns1__runSolverResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__runScenarioRequest
#define SOAP_TYPE__ns1__runScenarioRequest (69)
/* ns1:runScenarioRequest */
class SOAP_CMAC _ns1__runScenarioRequest
{
public:
	int idAnalysis;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE__ns1__runScenarioRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__runScenarioRequest() { _ns1__runScenarioRequest::soap_default(NULL); }
	virtual ~_ns1__runScenarioRequest() { }
};
#endif

#ifndef SOAP_TYPE__ns1__runScenarioResponse
#define SOAP_TYPE__ns1__runScenarioResponse (70)
/* ns1:runScenarioResponse */
class SOAP_CMAC _ns1__runScenarioResponse
{
public:
	std::string result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE__ns1__runScenarioResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__runScenarioResponse() { _ns1__runScenarioResponse::soap_default(NULL); }
	virtual ~_ns1__runScenarioResponse() { }
};
#endif

#ifndef SOAP_TYPE___ns1__changeModelDataStatus
#define SOAP_TYPE___ns1__changeModelDataStatus (125)
/* Operation wrapper: */
struct __ns1__changeModelDataStatus
{
public:
	_ns1__changeModelDataStatusRequest *ns1__changeModelDataStatusRequest;	/* optional element of type ns1:changeModelDataStatusRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__updateSolverStatus
#define SOAP_TYPE___ns1__updateSolverStatus (129)
/* Operation wrapper: */
struct __ns1__updateSolverStatus
{
public:
	_ns1__updateSolverStatusRequest *ns1__updateSolverStatusRequest;	/* optional element of type ns1:updateSolverStatusRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__getAnalyses
#define SOAP_TYPE___ns1__getAnalyses (133)
/* Operation wrapper: */
struct __ns1__getAnalyses
{
public:
	_ns1__getAnalysesRequest *ns1__getAnalysesRequest;	/* optional element of type ns1:getAnalysesRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__defineModelData
#define SOAP_TYPE___ns1__defineModelData (137)
/* Operation wrapper: */
struct __ns1__defineModelData
{
public:
	_ns1__defineModelDataRequest *ns1__defineModelDataRequest;	/* optional element of type ns1:defineModelDataRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__runScenario
#define SOAP_TYPE___ns1__runScenario (141)
/* Operation wrapper: */
struct __ns1__runScenario
{
public:
	_ns1__runScenarioRequest *ns1__runScenarioRequest;	/* optional element of type ns1:runScenarioRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__defineAnalysis
#define SOAP_TYPE___ns1__defineAnalysis (145)
/* Operation wrapper: */
struct __ns1__defineAnalysis
{
public:
	_ns1__defineAnalysisRequest *ns1__defineAnalysisRequest;	/* optional element of type ns1:defineAnalysisRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__getPreference
#define SOAP_TYPE___ns1__getPreference (149)
/* Operation wrapper: */
struct __ns1__getPreference
{
public:
	_ns1__getPreferenceRequest *ns1__getPreferenceRequest;	/* optional element of type ns1:getPreferenceRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__getEntityValues
#define SOAP_TYPE___ns1__getEntityValues (153)
/* Operation wrapper: */
struct __ns1__getEntityValues
{
public:
	_ns1__getEntityValuesRequest *ns1__getEntityValuesRequest;	/* optional element of type ns1:getEntityValuesRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__storeMainSet
#define SOAP_TYPE___ns1__storeMainSet (157)
/* Operation wrapper: */
struct __ns1__storeMainSet
{
public:
	_ns1__storeMainSetRequest *ns1__storeMainSetRequest;	/* optional element of type ns1:storeMainSetRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__getSMS
#define SOAP_TYPE___ns1__getSMS (161)
/* Operation wrapper: */
struct __ns1__getSMS
{
public:
	_ns1__getSMSRequest *ns1__getSMSRequest;	/* optional element of type ns1:getSMSRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__getSolution
#define SOAP_TYPE___ns1__getSolution (165)
/* Operation wrapper: */
struct __ns1__getSolution
{
public:
	_ns1__getSolutionRequest *ns1__getSolutionRequest;	/* optional element of type ns1:getSolutionRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__getBatchValues
#define SOAP_TYPE___ns1__getBatchValues (169)
/* Operation wrapper: */
struct __ns1__getBatchValues
{
public:
	_ns1__getBatchValuesRequest *ns1__getBatchValuesRequest;	/* optional element of type ns1:getBatchValuesRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__removeEntityValues
#define SOAP_TYPE___ns1__removeEntityValues (173)
/* Operation wrapper: */
struct __ns1__removeEntityValues
{
public:
	_ns1__removeEntityValuesRequest *ns1__removeEntityValuesRequest;	/* optional element of type ns1:removeEntityValuesRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__getDataSummary
#define SOAP_TYPE___ns1__getDataSummary (177)
/* Operation wrapper: */
struct __ns1__getDataSummary
{
public:
	_ns1__getDataSummaryRequest *ns1__getDataSummaryRequest;	/* optional element of type ns1:getDataSummaryRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__storeSolution
#define SOAP_TYPE___ns1__storeSolution (181)
/* Operation wrapper: */
struct __ns1__storeSolution
{
public:
	_ns1__storeSolutionRequest *ns1__storeSolutionRequest;	/* optional element of type ns1:storeSolutionRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__getSetMembers
#define SOAP_TYPE___ns1__getSetMembers (185)
/* Operation wrapper: */
struct __ns1__getSetMembers
{
public:
	_ns1__getSetMembersRequest *ns1__getSetMembersRequest;	/* optional element of type ns1:getSetMembersRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__definePreference
#define SOAP_TYPE___ns1__definePreference (189)
/* Operation wrapper: */
struct __ns1__definePreference
{
public:
	_ns1__definePreferenceRequest *ns1__definePreferenceRequest;	/* optional element of type ns1:definePreferenceRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__storeSetMembers
#define SOAP_TYPE___ns1__storeSetMembers (193)
/* Operation wrapper: */
struct __ns1__storeSetMembers
{
public:
	_ns1__storeSetMembersRequest *ns1__storeSetMembersRequest;	/* optional element of type ns1:storeSetMembersRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__runSolver
#define SOAP_TYPE___ns1__runSolver (197)
/* Operation wrapper: */
struct __ns1__runSolver
{
public:
	_ns1__runSolverRequest *ns1__runSolverRequest;	/* optional element of type ns1:runSolverRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__defineInstance
#define SOAP_TYPE___ns1__defineInstance (201)
/* Operation wrapper: */
struct __ns1__defineInstance
{
public:
	_ns1__defineInstanceRequest *ns1__defineInstanceRequest;	/* optional element of type ns1:defineInstanceRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__removeSetMembers
#define SOAP_TYPE___ns1__removeSetMembers (205)
/* Operation wrapper: */
struct __ns1__removeSetMembers
{
public:
	_ns1__removeSetMembersRequest *ns1__removeSetMembersRequest;	/* optional element of type ns1:removeSetMembersRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__storeEntityValues
#define SOAP_TYPE___ns1__storeEntityValues (209)
/* Operation wrapper: */
struct __ns1__storeEntityValues
{
public:
	_ns1__storeEntityValuesRequest *ns1__storeEntityValuesRequest;	/* optional element of type ns1:storeEntityValuesRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__getSolverStatus
#define SOAP_TYPE___ns1__getSolverStatus (213)
/* Operation wrapper: */
struct __ns1__getSolverStatus
{
public:
	_ns1__getSolverStatusRequest *ns1__getSolverStatusRequest;	/* optional element of type ns1:getSolverStatusRequest */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (214)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (215)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (217)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (220)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (221)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_ns2__shortName
#define SOAP_TYPE_ns2__shortName (76)
typedef std::string ns2__shortName;
#endif

#ifndef SOAP_TYPE_ns2__name
#define SOAP_TYPE_ns2__name (77)
typedef std::string ns2__name;
#endif

#ifndef SOAP_TYPE_ns2__description
#define SOAP_TYPE_ns2__description (78)
typedef std::string ns2__description;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
