/* soapC.cpp
   Generated by gSOAP 2.8.3 from enrima.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.3 2013-02-14 11:25:44 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_ns1__responseStatus:
		return soap_in_ns1__responseStatus(soap, NULL, NULL, "ns1:responseStatus");
	case SOAP_TYPE_ns4__preferenceType:
		return soap_in_ns4__preferenceType(soap, NULL, NULL, "ns4:preferenceType");
	case SOAP_TYPE_ns2__mathType:
		return soap_in_ns2__mathType(soap, NULL, NULL, "ns2:mathType");
	case SOAP_TYPE_ns2__entityRole:
		return soap_in_ns2__entityRole(soap, NULL, NULL, "ns2:entityRole");
	case SOAP_TYPE_ns2__setSpecType:
		return soap_in_ns2__setSpecType(soap, NULL, NULL, "ns2:setSpecType");
	case SOAP_TYPE_ns2__status:
		return soap_in_ns2__status(soap, NULL, NULL, "ns2:status");
	case SOAP_TYPE_ns2__description:
		return soap_in_ns2__description(soap, NULL, NULL, "ns2:description");
	case SOAP_TYPE_ns2__name:
		return soap_in_ns2__name(soap, NULL, NULL, "ns2:name");
	case SOAP_TYPE_ns2__shortName:
		return soap_in_ns2__shortName(soap, NULL, NULL, "ns2:shortName");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns4__preference:
		return soap_in_ns4__preference(soap, NULL, NULL, "ns4:preference");
	case SOAP_TYPE_ns4__analysis:
		return soap_in_ns4__analysis(soap, NULL, NULL, "ns4:analysis");
	case SOAP_TYPE_ns3__value:
		return soap_in_ns3__value(soap, NULL, NULL, "ns3:value");
	case SOAP_TYPE_ns3__batchValues:
		return soap_in_ns3__batchValues(soap, NULL, NULL, "ns3:batchValues");
	case SOAP_TYPE_ns3__tupleValues:
		return soap_in_ns3__tupleValues(soap, NULL, NULL, "ns3:tupleValues");
	case SOAP_TYPE_ns3__entityValues:
		return soap_in_ns3__entityValues(soap, NULL, NULL, "ns3:entityValues");
	case SOAP_TYPE_ns3__tupleMembers:
		return soap_in_ns3__tupleMembers(soap, NULL, NULL, "ns3:tupleMembers");
	case SOAP_TYPE_ns3__setMembers:
		return soap_in_ns3__setMembers(soap, NULL, NULL, "ns3:setMembers");
	case SOAP_TYPE_ns3__tupleValue:
		return soap_in_ns3__tupleValue(soap, NULL, NULL, "ns3:tupleValue");
	case SOAP_TYPE_ns3__memberDic:
		return soap_in_ns3__memberDic(soap, NULL, NULL, "ns3:memberDic");
	case SOAP_TYPE_ns3__modelInstance:
		return soap_in_ns3__modelInstance(soap, NULL, NULL, "ns3:modelInstance");
	case SOAP_TYPE_ns3__modelData:
		return soap_in_ns3__modelData(soap, NULL, NULL, "ns3:modelData");
	case SOAP_TYPE_ns2__iteratorContainer:
		return soap_in_ns2__iteratorContainer(soap, NULL, NULL, "ns2:iteratorContainer");
	case SOAP_TYPE_ns2__entitySpec:
		return soap_in_ns2__entitySpec(soap, NULL, NULL, "ns2:entitySpec");
	case SOAP_TYPE_ns2__setSpec:
		return soap_in_ns2__setSpec(soap, NULL, NULL, "ns2:setSpec");
	case SOAP_TYPE_ns2__modelSpec:
		return soap_in_ns2__modelSpec(soap, NULL, NULL, "ns2:modelSpec");
	case SOAP_TYPE_PointerTo_ns1__getSolverStatusResponse:
		return soap_in_PointerTo_ns1__getSolverStatusResponse(soap, NULL, NULL, "ns1:getSolverStatusResponse");
	case SOAP_TYPE_PointerTo_ns1__getSolverStatusRequest:
		return soap_in_PointerTo_ns1__getSolverStatusRequest(soap, NULL, NULL, "ns1:getSolverStatusRequest");
	case SOAP_TYPE_PointerTo_ns1__storeEntityValuesResponse:
		return soap_in_PointerTo_ns1__storeEntityValuesResponse(soap, NULL, NULL, "ns1:storeEntityValuesResponse");
	case SOAP_TYPE_PointerTo_ns1__storeEntityValuesRequest:
		return soap_in_PointerTo_ns1__storeEntityValuesRequest(soap, NULL, NULL, "ns1:storeEntityValuesRequest");
	case SOAP_TYPE_PointerTo_ns1__removeSetMembersResponse:
		return soap_in_PointerTo_ns1__removeSetMembersResponse(soap, NULL, NULL, "ns1:removeSetMembersResponse");
	case SOAP_TYPE_PointerTo_ns1__removeSetMembersRequest:
		return soap_in_PointerTo_ns1__removeSetMembersRequest(soap, NULL, NULL, "ns1:removeSetMembersRequest");
	case SOAP_TYPE_PointerTo_ns1__defineInstanceResponse:
		return soap_in_PointerTo_ns1__defineInstanceResponse(soap, NULL, NULL, "ns1:defineInstanceResponse");
	case SOAP_TYPE_PointerTo_ns1__defineInstanceRequest:
		return soap_in_PointerTo_ns1__defineInstanceRequest(soap, NULL, NULL, "ns1:defineInstanceRequest");
	case SOAP_TYPE_PointerTo_ns1__runSolverResponse:
		return soap_in_PointerTo_ns1__runSolverResponse(soap, NULL, NULL, "ns1:runSolverResponse");
	case SOAP_TYPE_PointerTo_ns1__runSolverRequest:
		return soap_in_PointerTo_ns1__runSolverRequest(soap, NULL, NULL, "ns1:runSolverRequest");
	case SOAP_TYPE_PointerTo_ns1__storeSetMembersResponse:
		return soap_in_PointerTo_ns1__storeSetMembersResponse(soap, NULL, NULL, "ns1:storeSetMembersResponse");
	case SOAP_TYPE_PointerTo_ns1__storeSetMembersRequest:
		return soap_in_PointerTo_ns1__storeSetMembersRequest(soap, NULL, NULL, "ns1:storeSetMembersRequest");
	case SOAP_TYPE_PointerTo_ns1__definePreferenceResponse:
		return soap_in_PointerTo_ns1__definePreferenceResponse(soap, NULL, NULL, "ns1:definePreferenceResponse");
	case SOAP_TYPE_PointerTo_ns1__definePreferenceRequest:
		return soap_in_PointerTo_ns1__definePreferenceRequest(soap, NULL, NULL, "ns1:definePreferenceRequest");
	case SOAP_TYPE_PointerTo_ns1__getSetMembersResponse:
		return soap_in_PointerTo_ns1__getSetMembersResponse(soap, NULL, NULL, "ns1:getSetMembersResponse");
	case SOAP_TYPE_PointerTo_ns1__getSetMembersRequest:
		return soap_in_PointerTo_ns1__getSetMembersRequest(soap, NULL, NULL, "ns1:getSetMembersRequest");
	case SOAP_TYPE_PointerTo_ns1__storeSolutionResponse:
		return soap_in_PointerTo_ns1__storeSolutionResponse(soap, NULL, NULL, "ns1:storeSolutionResponse");
	case SOAP_TYPE_PointerTo_ns1__storeSolutionRequest:
		return soap_in_PointerTo_ns1__storeSolutionRequest(soap, NULL, NULL, "ns1:storeSolutionRequest");
	case SOAP_TYPE_PointerTo_ns1__getDataSummaryResponse:
		return soap_in_PointerTo_ns1__getDataSummaryResponse(soap, NULL, NULL, "ns1:getDataSummaryResponse");
	case SOAP_TYPE_PointerTo_ns1__getDataSummaryRequest:
		return soap_in_PointerTo_ns1__getDataSummaryRequest(soap, NULL, NULL, "ns1:getDataSummaryRequest");
	case SOAP_TYPE_PointerTo_ns1__removeEntityValuesResponse:
		return soap_in_PointerTo_ns1__removeEntityValuesResponse(soap, NULL, NULL, "ns1:removeEntityValuesResponse");
	case SOAP_TYPE_PointerTo_ns1__removeEntityValuesRequest:
		return soap_in_PointerTo_ns1__removeEntityValuesRequest(soap, NULL, NULL, "ns1:removeEntityValuesRequest");
	case SOAP_TYPE_PointerTo_ns1__getBatchValuesResponse:
		return soap_in_PointerTo_ns1__getBatchValuesResponse(soap, NULL, NULL, "ns1:getBatchValuesResponse");
	case SOAP_TYPE_PointerTo_ns1__getBatchValuesRequest:
		return soap_in_PointerTo_ns1__getBatchValuesRequest(soap, NULL, NULL, "ns1:getBatchValuesRequest");
	case SOAP_TYPE_PointerTo_ns1__getSolutionResponse:
		return soap_in_PointerTo_ns1__getSolutionResponse(soap, NULL, NULL, "ns1:getSolutionResponse");
	case SOAP_TYPE_PointerTo_ns1__getSolutionRequest:
		return soap_in_PointerTo_ns1__getSolutionRequest(soap, NULL, NULL, "ns1:getSolutionRequest");
	case SOAP_TYPE_PointerTo_ns1__getSMSResponse:
		return soap_in_PointerTo_ns1__getSMSResponse(soap, NULL, NULL, "ns1:getSMSResponse");
	case SOAP_TYPE_PointerTo_ns1__getSMSRequest:
		return soap_in_PointerTo_ns1__getSMSRequest(soap, NULL, NULL, "ns1:getSMSRequest");
	case SOAP_TYPE_PointerTo_ns1__storeMainSetResponse:
		return soap_in_PointerTo_ns1__storeMainSetResponse(soap, NULL, NULL, "ns1:storeMainSetResponse");
	case SOAP_TYPE_PointerTo_ns1__storeMainSetRequest:
		return soap_in_PointerTo_ns1__storeMainSetRequest(soap, NULL, NULL, "ns1:storeMainSetRequest");
	case SOAP_TYPE_PointerTo_ns1__getEntityValuesResponse:
		return soap_in_PointerTo_ns1__getEntityValuesResponse(soap, NULL, NULL, "ns1:getEntityValuesResponse");
	case SOAP_TYPE_PointerTo_ns1__getEntityValuesRequest:
		return soap_in_PointerTo_ns1__getEntityValuesRequest(soap, NULL, NULL, "ns1:getEntityValuesRequest");
	case SOAP_TYPE_PointerTo_ns1__getPreferenceResponse:
		return soap_in_PointerTo_ns1__getPreferenceResponse(soap, NULL, NULL, "ns1:getPreferenceResponse");
	case SOAP_TYPE_PointerTo_ns1__getPreferenceRequest:
		return soap_in_PointerTo_ns1__getPreferenceRequest(soap, NULL, NULL, "ns1:getPreferenceRequest");
	case SOAP_TYPE_PointerTo_ns1__defineAnalysisResponse:
		return soap_in_PointerTo_ns1__defineAnalysisResponse(soap, NULL, NULL, "ns1:defineAnalysisResponse");
	case SOAP_TYPE_PointerTo_ns1__defineAnalysisRequest:
		return soap_in_PointerTo_ns1__defineAnalysisRequest(soap, NULL, NULL, "ns1:defineAnalysisRequest");
	case SOAP_TYPE_PointerTo_ns1__runScenarioResponse:
		return soap_in_PointerTo_ns1__runScenarioResponse(soap, NULL, NULL, "ns1:runScenarioResponse");
	case SOAP_TYPE_PointerTo_ns1__runScenarioRequest:
		return soap_in_PointerTo_ns1__runScenarioRequest(soap, NULL, NULL, "ns1:runScenarioRequest");
	case SOAP_TYPE_PointerTo_ns1__defineModelDataResponse:
		return soap_in_PointerTo_ns1__defineModelDataResponse(soap, NULL, NULL, "ns1:defineModelDataResponse");
	case SOAP_TYPE_PointerTo_ns1__defineModelDataRequest:
		return soap_in_PointerTo_ns1__defineModelDataRequest(soap, NULL, NULL, "ns1:defineModelDataRequest");
	case SOAP_TYPE_PointerTo_ns1__getAnalysesResponse:
		return soap_in_PointerTo_ns1__getAnalysesResponse(soap, NULL, NULL, "ns1:getAnalysesResponse");
	case SOAP_TYPE_PointerTo_ns1__getAnalysesRequest:
		return soap_in_PointerTo_ns1__getAnalysesRequest(soap, NULL, NULL, "ns1:getAnalysesRequest");
	case SOAP_TYPE_PointerTo_ns1__updateSolverStatusResponse:
		return soap_in_PointerTo_ns1__updateSolverStatusResponse(soap, NULL, NULL, "ns1:updateSolverStatusResponse");
	case SOAP_TYPE_PointerTo_ns1__updateSolverStatusRequest:
		return soap_in_PointerTo_ns1__updateSolverStatusRequest(soap, NULL, NULL, "ns1:updateSolverStatusRequest");
	case SOAP_TYPE_PointerTo_ns1__changeModelDataStatusResponse:
		return soap_in_PointerTo_ns1__changeModelDataStatusResponse(soap, NULL, NULL, "ns1:changeModelDataStatusResponse");
	case SOAP_TYPE_PointerTo_ns1__changeModelDataStatusRequest:
		return soap_in_PointerTo_ns1__changeModelDataStatusRequest(soap, NULL, NULL, "ns1:changeModelDataStatusRequest");
	case SOAP_TYPE_PointerTons4__preference:
		return soap_in_PointerTons4__preference(soap, NULL, NULL, "ns4:preference");
	case SOAP_TYPE_PointerTons4__analysis:
		return soap_in_PointerTons4__analysis(soap, NULL, NULL, "ns4:analysis");
	case SOAP_TYPE_PointerTons3__modelInstance:
		return soap_in_PointerTons3__modelInstance(soap, NULL, NULL, "ns3:modelInstance");
	case SOAP_TYPE_PointerTons3__modelData:
		return soap_in_PointerTons3__modelData(soap, NULL, NULL, "ns3:modelData");
	case SOAP_TYPE_PointerTons3__batchValues:
		return soap_in_PointerTons3__batchValues(soap, NULL, NULL, "ns3:batchValues");
	case SOAP_TYPE_PointerTons3__tupleValue:
		return soap_in_PointerTons3__tupleValue(soap, NULL, NULL, "ns3:tupleValue");
	case SOAP_TYPE_PointerTons2__modelSpec:
		return soap_in_PointerTons2__modelSpec(soap, NULL, NULL, "ns2:modelSpec");
	case SOAP_TYPE_PointerTons3__entityValues:
		return soap_in_PointerTons3__entityValues(soap, NULL, NULL, "ns3:entityValues");
	case SOAP_TYPE_PointerTons3__setMembers:
		return soap_in_PointerTons3__setMembers(soap, NULL, NULL, "ns3:setMembers");
	case SOAP_TYPE_PointerTons3__tupleValues:
		return soap_in_PointerTons3__tupleValues(soap, NULL, NULL, "ns3:tupleValues");
	case SOAP_TYPE_PointerTons3__tupleMembers:
		return soap_in_PointerTons3__tupleMembers(soap, NULL, NULL, "ns3:tupleMembers");
	case SOAP_TYPE_PointerTons3__value:
		return soap_in_PointerTons3__value(soap, NULL, NULL, "ns3:value");
	case SOAP_TYPE_PointerTons3__memberDic:
		return soap_in_PointerTons3__memberDic(soap, NULL, NULL, "ns3:memberDic");
	case SOAP_TYPE_PointerTons2__shortName:
		return soap_in_PointerTons2__shortName(soap, NULL, NULL, "ns2:shortName");
	case SOAP_TYPE_PointerTons2__entityRole:
		return soap_in_PointerTons2__entityRole(soap, NULL, NULL, "ns2:entityRole");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerTons2__iteratorContainer:
		return soap_in_PointerTons2__iteratorContainer(soap, NULL, NULL, "ns2:iteratorContainer");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons2__entitySpec:
		return soap_in_PointerTons2__entitySpec(soap, NULL, NULL, "ns2:entitySpec");
	case SOAP_TYPE_PointerTons2__setSpec:
		return soap_in_PointerTons2__setSpec(soap, NULL, NULL, "ns2:setSpec");
	case SOAP_TYPE_PointerTons2__description:
		return soap_in_PointerTons2__description(soap, NULL, NULL, "ns2:description");
	case SOAP_TYPE_PointerTons2__name:
		return soap_in_PointerTons2__name(soap, NULL, NULL, "ns2:name");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:description"))
		{	*type = SOAP_TYPE_ns2__description;
			return soap_in_ns2__description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:name"))
		{	*type = SOAP_TYPE_ns2__name;
			return soap_in_ns2__name(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:shortName"))
		{	*type = SOAP_TYPE_ns2__shortName;
			return soap_in_ns2__shortName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:preference"))
		{	*type = SOAP_TYPE_ns4__preference;
			return soap_in_ns4__preference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:analysis"))
		{	*type = SOAP_TYPE_ns4__analysis;
			return soap_in_ns4__analysis(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:value"))
		{	*type = SOAP_TYPE_ns3__value;
			return soap_in_ns3__value(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:batchValues"))
		{	*type = SOAP_TYPE_ns3__batchValues;
			return soap_in_ns3__batchValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:tupleValues"))
		{	*type = SOAP_TYPE_ns3__tupleValues;
			return soap_in_ns3__tupleValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:entityValues"))
		{	*type = SOAP_TYPE_ns3__entityValues;
			return soap_in_ns3__entityValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:tupleMembers"))
		{	*type = SOAP_TYPE_ns3__tupleMembers;
			return soap_in_ns3__tupleMembers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:setMembers"))
		{	*type = SOAP_TYPE_ns3__setMembers;
			return soap_in_ns3__setMembers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:tupleValue"))
		{	*type = SOAP_TYPE_ns3__tupleValue;
			return soap_in_ns3__tupleValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:memberDic"))
		{	*type = SOAP_TYPE_ns3__memberDic;
			return soap_in_ns3__memberDic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:modelInstance"))
		{	*type = SOAP_TYPE_ns3__modelInstance;
			return soap_in_ns3__modelInstance(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:modelData"))
		{	*type = SOAP_TYPE_ns3__modelData;
			return soap_in_ns3__modelData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:iteratorContainer"))
		{	*type = SOAP_TYPE_ns2__iteratorContainer;
			return soap_in_ns2__iteratorContainer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:entitySpec"))
		{	*type = SOAP_TYPE_ns2__entitySpec;
			return soap_in_ns2__entitySpec(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:setSpec"))
		{	*type = SOAP_TYPE_ns2__setSpec;
			return soap_in_ns2__setSpec(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:modelSpec"))
		{	*type = SOAP_TYPE_ns2__modelSpec;
			return soap_in_ns2__modelSpec(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:responseStatus"))
		{	*type = SOAP_TYPE_ns1__responseStatus;
			return soap_in_ns1__responseStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:preferenceType"))
		{	*type = SOAP_TYPE_ns4__preferenceType;
			return soap_in_ns4__preferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:mathType"))
		{	*type = SOAP_TYPE_ns2__mathType;
			return soap_in_ns2__mathType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:entityRole"))
		{	*type = SOAP_TYPE_ns2__entityRole;
			return soap_in_ns2__entityRole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:setSpecType"))
		{	*type = SOAP_TYPE_ns2__setSpecType;
			return soap_in_ns2__setSpecType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:status"))
		{	*type = SOAP_TYPE_ns2__status;
			return soap_in_ns2__status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:runScenarioResponse"))
		{	*type = SOAP_TYPE__ns1__runScenarioResponse;
			return soap_in__ns1__runScenarioResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runScenarioRequest"))
		{	*type = SOAP_TYPE__ns1__runScenarioRequest;
			return soap_in__ns1__runScenarioRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runSolverResponse"))
		{	*type = SOAP_TYPE__ns1__runSolverResponse;
			return soap_in__ns1__runSolverResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runSolverRequest"))
		{	*type = SOAP_TYPE__ns1__runSolverRequest;
			return soap_in__ns1__runSolverRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSolverStatusResponse"))
		{	*type = SOAP_TYPE__ns1__getSolverStatusResponse;
			return soap_in__ns1__getSolverStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSolverStatusRequest"))
		{	*type = SOAP_TYPE__ns1__getSolverStatusRequest;
			return soap_in__ns1__getSolverStatusRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateSolverStatusResponse"))
		{	*type = SOAP_TYPE__ns1__updateSolverStatusResponse;
			return soap_in__ns1__updateSolverStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateSolverStatusRequest"))
		{	*type = SOAP_TYPE__ns1__updateSolverStatusRequest;
			return soap_in__ns1__updateSolverStatusRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSolutionResponse"))
		{	*type = SOAP_TYPE__ns1__getSolutionResponse;
			return soap_in__ns1__getSolutionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSolutionRequest"))
		{	*type = SOAP_TYPE__ns1__getSolutionRequest;
			return soap_in__ns1__getSolutionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:storeSolutionResponse"))
		{	*type = SOAP_TYPE__ns1__storeSolutionResponse;
			return soap_in__ns1__storeSolutionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:storeSolutionRequest"))
		{	*type = SOAP_TYPE__ns1__storeSolutionRequest;
			return soap_in__ns1__storeSolutionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPreferenceResponse"))
		{	*type = SOAP_TYPE__ns1__getPreferenceResponse;
			return soap_in__ns1__getPreferenceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPreferenceRequest"))
		{	*type = SOAP_TYPE__ns1__getPreferenceRequest;
			return soap_in__ns1__getPreferenceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:definePreferenceResponse"))
		{	*type = SOAP_TYPE__ns1__definePreferenceResponse;
			return soap_in__ns1__definePreferenceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:definePreferenceRequest"))
		{	*type = SOAP_TYPE__ns1__definePreferenceRequest;
			return soap_in__ns1__definePreferenceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAnalysesResponse"))
		{	*type = SOAP_TYPE__ns1__getAnalysesResponse;
			return soap_in__ns1__getAnalysesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAnalysesRequest"))
		{	*type = SOAP_TYPE__ns1__getAnalysesRequest;
			return soap_in__ns1__getAnalysesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:defineAnalysisResponse"))
		{	*type = SOAP_TYPE__ns1__defineAnalysisResponse;
			return soap_in__ns1__defineAnalysisResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:defineAnalysisRequest"))
		{	*type = SOAP_TYPE__ns1__defineAnalysisRequest;
			return soap_in__ns1__defineAnalysisRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDataSummaryResponse"))
		{	*type = SOAP_TYPE__ns1__getDataSummaryResponse;
			return soap_in__ns1__getDataSummaryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDataSummaryRequest"))
		{	*type = SOAP_TYPE__ns1__getDataSummaryRequest;
			return soap_in__ns1__getDataSummaryRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:defineInstanceResponse"))
		{	*type = SOAP_TYPE__ns1__defineInstanceResponse;
			return soap_in__ns1__defineInstanceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:defineInstanceRequest"))
		{	*type = SOAP_TYPE__ns1__defineInstanceRequest;
			return soap_in__ns1__defineInstanceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:changeModelDataStatusResponse"))
		{	*type = SOAP_TYPE__ns1__changeModelDataStatusResponse;
			return soap_in__ns1__changeModelDataStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:changeModelDataStatusRequest"))
		{	*type = SOAP_TYPE__ns1__changeModelDataStatusRequest;
			return soap_in__ns1__changeModelDataStatusRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:defineModelDataResponse"))
		{	*type = SOAP_TYPE__ns1__defineModelDataResponse;
			return soap_in__ns1__defineModelDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:defineModelDataRequest"))
		{	*type = SOAP_TYPE__ns1__defineModelDataRequest;
			return soap_in__ns1__defineModelDataRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeEntityValuesResponse"))
		{	*type = SOAP_TYPE__ns1__removeEntityValuesResponse;
			return soap_in__ns1__removeEntityValuesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeEntityValuesRequest"))
		{	*type = SOAP_TYPE__ns1__removeEntityValuesRequest;
			return soap_in__ns1__removeEntityValuesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:storeEntityValuesResponse"))
		{	*type = SOAP_TYPE__ns1__storeEntityValuesResponse;
			return soap_in__ns1__storeEntityValuesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:storeEntityValuesRequest"))
		{	*type = SOAP_TYPE__ns1__storeEntityValuesRequest;
			return soap_in__ns1__storeEntityValuesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeSetMembersResponse"))
		{	*type = SOAP_TYPE__ns1__removeSetMembersResponse;
			return soap_in__ns1__removeSetMembersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeSetMembersRequest"))
		{	*type = SOAP_TYPE__ns1__removeSetMembersRequest;
			return soap_in__ns1__removeSetMembersRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:storeSetMembersResponse"))
		{	*type = SOAP_TYPE__ns1__storeSetMembersResponse;
			return soap_in__ns1__storeSetMembersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:storeSetMembersRequest"))
		{	*type = SOAP_TYPE__ns1__storeSetMembersRequest;
			return soap_in__ns1__storeSetMembersRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:storeMainSetResponse"))
		{	*type = SOAP_TYPE__ns1__storeMainSetResponse;
			return soap_in__ns1__storeMainSetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:storeMainSetRequest"))
		{	*type = SOAP_TYPE__ns1__storeMainSetRequest;
			return soap_in__ns1__storeMainSetRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSetMembersResponse"))
		{	*type = SOAP_TYPE__ns1__getSetMembersResponse;
			return soap_in__ns1__getSetMembersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSetMembersRequest"))
		{	*type = SOAP_TYPE__ns1__getSetMembersRequest;
			return soap_in__ns1__getSetMembersRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getBatchValuesResponse"))
		{	*type = SOAP_TYPE__ns1__getBatchValuesResponse;
			return soap_in__ns1__getBatchValuesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getBatchValuesRequest"))
		{	*type = SOAP_TYPE__ns1__getBatchValuesRequest;
			return soap_in__ns1__getBatchValuesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getEntityValuesResponse"))
		{	*type = SOAP_TYPE__ns1__getEntityValuesResponse;
			return soap_in__ns1__getEntityValuesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getEntityValuesRequest"))
		{	*type = SOAP_TYPE__ns1__getEntityValuesRequest;
			return soap_in__ns1__getEntityValuesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSMSResponse"))
		{	*type = SOAP_TYPE__ns1__getSMSResponse;
			return soap_in__ns1__getSMSResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSMSRequest"))
		{	*type = SOAP_TYPE__ns1__getSMSRequest;
			return soap_in__ns1__getSMSRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:dataSet"))
		{	*type = SOAP_TYPE__ns3__dataSet;
			return soap_in__ns3__dataSet(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_ns1__responseStatus:
		return soap_out_ns1__responseStatus(soap, tag, id, (const enum ns1__responseStatus *)ptr, "ns1:responseStatus");
	case SOAP_TYPE_ns4__preferenceType:
		return soap_out_ns4__preferenceType(soap, tag, id, (const enum ns4__preferenceType *)ptr, "ns4:preferenceType");
	case SOAP_TYPE_ns2__mathType:
		return soap_out_ns2__mathType(soap, tag, id, (const enum ns2__mathType *)ptr, "ns2:mathType");
	case SOAP_TYPE_ns2__entityRole:
		return soap_out_ns2__entityRole(soap, tag, id, (const enum ns2__entityRole *)ptr, "ns2:entityRole");
	case SOAP_TYPE_ns2__setSpecType:
		return soap_out_ns2__setSpecType(soap, tag, id, (const enum ns2__setSpecType *)ptr, "ns2:setSpecType");
	case SOAP_TYPE_ns2__status:
		return soap_out_ns2__status(soap, tag, id, (const enum ns2__status *)ptr, "ns2:status");
	case SOAP_TYPE_ns2__description:
		return soap_out_ns2__description(soap, tag, id, (const std::string *)ptr, "ns2:description");
	case SOAP_TYPE_ns2__name:
		return soap_out_ns2__name(soap, tag, id, (const std::string *)ptr, "ns2:name");
	case SOAP_TYPE_ns2__shortName:
		return soap_out_ns2__shortName(soap, tag, id, (const std::string *)ptr, "ns2:shortName");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__ns1__runScenarioResponse:
		return ((_ns1__runScenarioResponse *)ptr)->soap_out(soap, "ns1:runScenarioResponse", id, NULL);
	case SOAP_TYPE__ns1__runScenarioRequest:
		return ((_ns1__runScenarioRequest *)ptr)->soap_out(soap, "ns1:runScenarioRequest", id, NULL);
	case SOAP_TYPE__ns1__runSolverResponse:
		return ((_ns1__runSolverResponse *)ptr)->soap_out(soap, "ns1:runSolverResponse", id, NULL);
	case SOAP_TYPE__ns1__runSolverRequest:
		return ((_ns1__runSolverRequest *)ptr)->soap_out(soap, "ns1:runSolverRequest", id, NULL);
	case SOAP_TYPE__ns1__getSolverStatusResponse:
		return ((_ns1__getSolverStatusResponse *)ptr)->soap_out(soap, "ns1:getSolverStatusResponse", id, NULL);
	case SOAP_TYPE__ns1__getSolverStatusRequest:
		return ((_ns1__getSolverStatusRequest *)ptr)->soap_out(soap, "ns1:getSolverStatusRequest", id, NULL);
	case SOAP_TYPE__ns1__updateSolverStatusResponse:
		return ((_ns1__updateSolverStatusResponse *)ptr)->soap_out(soap, "ns1:updateSolverStatusResponse", id, NULL);
	case SOAP_TYPE__ns1__updateSolverStatusRequest:
		return ((_ns1__updateSolverStatusRequest *)ptr)->soap_out(soap, "ns1:updateSolverStatusRequest", id, NULL);
	case SOAP_TYPE__ns1__getSolutionResponse:
		return ((_ns1__getSolutionResponse *)ptr)->soap_out(soap, "ns1:getSolutionResponse", id, NULL);
	case SOAP_TYPE__ns1__getSolutionRequest:
		return ((_ns1__getSolutionRequest *)ptr)->soap_out(soap, "ns1:getSolutionRequest", id, NULL);
	case SOAP_TYPE__ns1__storeSolutionResponse:
		return ((_ns1__storeSolutionResponse *)ptr)->soap_out(soap, "ns1:storeSolutionResponse", id, NULL);
	case SOAP_TYPE__ns1__storeSolutionRequest:
		return ((_ns1__storeSolutionRequest *)ptr)->soap_out(soap, "ns1:storeSolutionRequest", id, NULL);
	case SOAP_TYPE__ns1__getPreferenceResponse:
		return ((_ns1__getPreferenceResponse *)ptr)->soap_out(soap, "ns1:getPreferenceResponse", id, NULL);
	case SOAP_TYPE__ns1__getPreferenceRequest:
		return ((_ns1__getPreferenceRequest *)ptr)->soap_out(soap, "ns1:getPreferenceRequest", id, NULL);
	case SOAP_TYPE__ns1__definePreferenceResponse:
		return ((_ns1__definePreferenceResponse *)ptr)->soap_out(soap, "ns1:definePreferenceResponse", id, NULL);
	case SOAP_TYPE__ns1__definePreferenceRequest:
		return ((_ns1__definePreferenceRequest *)ptr)->soap_out(soap, "ns1:definePreferenceRequest", id, NULL);
	case SOAP_TYPE__ns1__getAnalysesResponse:
		return ((_ns1__getAnalysesResponse *)ptr)->soap_out(soap, "ns1:getAnalysesResponse", id, NULL);
	case SOAP_TYPE__ns1__getAnalysesRequest:
		return ((_ns1__getAnalysesRequest *)ptr)->soap_out(soap, "ns1:getAnalysesRequest", id, NULL);
	case SOAP_TYPE__ns1__defineAnalysisResponse:
		return ((_ns1__defineAnalysisResponse *)ptr)->soap_out(soap, "ns1:defineAnalysisResponse", id, NULL);
	case SOAP_TYPE__ns1__defineAnalysisRequest:
		return ((_ns1__defineAnalysisRequest *)ptr)->soap_out(soap, "ns1:defineAnalysisRequest", id, NULL);
	case SOAP_TYPE__ns1__getDataSummaryResponse:
		return ((_ns1__getDataSummaryResponse *)ptr)->soap_out(soap, "ns1:getDataSummaryResponse", id, NULL);
	case SOAP_TYPE__ns1__getDataSummaryRequest:
		return ((_ns1__getDataSummaryRequest *)ptr)->soap_out(soap, "ns1:getDataSummaryRequest", id, NULL);
	case SOAP_TYPE__ns1__defineInstanceResponse:
		return ((_ns1__defineInstanceResponse *)ptr)->soap_out(soap, "ns1:defineInstanceResponse", id, NULL);
	case SOAP_TYPE__ns1__defineInstanceRequest:
		return ((_ns1__defineInstanceRequest *)ptr)->soap_out(soap, "ns1:defineInstanceRequest", id, NULL);
	case SOAP_TYPE__ns1__changeModelDataStatusResponse:
		return ((_ns1__changeModelDataStatusResponse *)ptr)->soap_out(soap, "ns1:changeModelDataStatusResponse", id, NULL);
	case SOAP_TYPE__ns1__changeModelDataStatusRequest:
		return ((_ns1__changeModelDataStatusRequest *)ptr)->soap_out(soap, "ns1:changeModelDataStatusRequest", id, NULL);
	case SOAP_TYPE__ns1__defineModelDataResponse:
		return ((_ns1__defineModelDataResponse *)ptr)->soap_out(soap, "ns1:defineModelDataResponse", id, NULL);
	case SOAP_TYPE__ns1__defineModelDataRequest:
		return ((_ns1__defineModelDataRequest *)ptr)->soap_out(soap, "ns1:defineModelDataRequest", id, NULL);
	case SOAP_TYPE__ns1__removeEntityValuesResponse:
		return ((_ns1__removeEntityValuesResponse *)ptr)->soap_out(soap, "ns1:removeEntityValuesResponse", id, NULL);
	case SOAP_TYPE__ns1__removeEntityValuesRequest:
		return ((_ns1__removeEntityValuesRequest *)ptr)->soap_out(soap, "ns1:removeEntityValuesRequest", id, NULL);
	case SOAP_TYPE__ns1__storeEntityValuesResponse:
		return ((_ns1__storeEntityValuesResponse *)ptr)->soap_out(soap, "ns1:storeEntityValuesResponse", id, NULL);
	case SOAP_TYPE__ns1__storeEntityValuesRequest:
		return ((_ns1__storeEntityValuesRequest *)ptr)->soap_out(soap, "ns1:storeEntityValuesRequest", id, NULL);
	case SOAP_TYPE__ns1__removeSetMembersResponse:
		return ((_ns1__removeSetMembersResponse *)ptr)->soap_out(soap, "ns1:removeSetMembersResponse", id, NULL);
	case SOAP_TYPE__ns1__removeSetMembersRequest:
		return ((_ns1__removeSetMembersRequest *)ptr)->soap_out(soap, "ns1:removeSetMembersRequest", id, NULL);
	case SOAP_TYPE__ns1__storeSetMembersResponse:
		return ((_ns1__storeSetMembersResponse *)ptr)->soap_out(soap, "ns1:storeSetMembersResponse", id, NULL);
	case SOAP_TYPE__ns1__storeSetMembersRequest:
		return ((_ns1__storeSetMembersRequest *)ptr)->soap_out(soap, "ns1:storeSetMembersRequest", id, NULL);
	case SOAP_TYPE__ns1__storeMainSetResponse:
		return ((_ns1__storeMainSetResponse *)ptr)->soap_out(soap, "ns1:storeMainSetResponse", id, NULL);
	case SOAP_TYPE__ns1__storeMainSetRequest:
		return ((_ns1__storeMainSetRequest *)ptr)->soap_out(soap, "ns1:storeMainSetRequest", id, NULL);
	case SOAP_TYPE__ns1__getSetMembersResponse:
		return ((_ns1__getSetMembersResponse *)ptr)->soap_out(soap, "ns1:getSetMembersResponse", id, NULL);
	case SOAP_TYPE__ns1__getSetMembersRequest:
		return ((_ns1__getSetMembersRequest *)ptr)->soap_out(soap, "ns1:getSetMembersRequest", id, NULL);
	case SOAP_TYPE__ns1__getBatchValuesResponse:
		return ((_ns1__getBatchValuesResponse *)ptr)->soap_out(soap, "ns1:getBatchValuesResponse", id, NULL);
	case SOAP_TYPE__ns1__getBatchValuesRequest:
		return ((_ns1__getBatchValuesRequest *)ptr)->soap_out(soap, "ns1:getBatchValuesRequest", id, NULL);
	case SOAP_TYPE__ns1__getEntityValuesResponse:
		return ((_ns1__getEntityValuesResponse *)ptr)->soap_out(soap, "ns1:getEntityValuesResponse", id, NULL);
	case SOAP_TYPE__ns1__getEntityValuesRequest:
		return ((_ns1__getEntityValuesRequest *)ptr)->soap_out(soap, "ns1:getEntityValuesRequest", id, NULL);
	case SOAP_TYPE__ns1__getSMSResponse:
		return ((_ns1__getSMSResponse *)ptr)->soap_out(soap, "ns1:getSMSResponse", id, NULL);
	case SOAP_TYPE__ns1__getSMSRequest:
		return ((_ns1__getSMSRequest *)ptr)->soap_out(soap, "ns1:getSMSRequest", id, NULL);
	case SOAP_TYPE_ns4__preference:
		return ((ns4__preference *)ptr)->soap_out(soap, tag, id, "ns4:preference");
	case SOAP_TYPE_ns4__analysis:
		return ((ns4__analysis *)ptr)->soap_out(soap, tag, id, "ns4:analysis");
	case SOAP_TYPE__ns3__dataSet:
		return ((_ns3__dataSet *)ptr)->soap_out(soap, "ns3:dataSet", id, NULL);
	case SOAP_TYPE_ns3__value:
		return ((ns3__value *)ptr)->soap_out(soap, tag, id, "ns3:value");
	case SOAP_TYPE_ns3__batchValues:
		return ((ns3__batchValues *)ptr)->soap_out(soap, tag, id, "ns3:batchValues");
	case SOAP_TYPE_ns3__tupleValues:
		return ((ns3__tupleValues *)ptr)->soap_out(soap, tag, id, "ns3:tupleValues");
	case SOAP_TYPE_ns3__entityValues:
		return ((ns3__entityValues *)ptr)->soap_out(soap, tag, id, "ns3:entityValues");
	case SOAP_TYPE_ns3__tupleMembers:
		return ((ns3__tupleMembers *)ptr)->soap_out(soap, tag, id, "ns3:tupleMembers");
	case SOAP_TYPE_ns3__setMembers:
		return ((ns3__setMembers *)ptr)->soap_out(soap, tag, id, "ns3:setMembers");
	case SOAP_TYPE_ns3__tupleValue:
		return ((ns3__tupleValue *)ptr)->soap_out(soap, tag, id, "ns3:tupleValue");
	case SOAP_TYPE_ns3__memberDic:
		return ((ns3__memberDic *)ptr)->soap_out(soap, tag, id, "ns3:memberDic");
	case SOAP_TYPE_ns3__modelInstance:
		return ((ns3__modelInstance *)ptr)->soap_out(soap, tag, id, "ns3:modelInstance");
	case SOAP_TYPE_ns3__modelData:
		return ((ns3__modelData *)ptr)->soap_out(soap, tag, id, "ns3:modelData");
	case SOAP_TYPE_ns2__iteratorContainer:
		return ((ns2__iteratorContainer *)ptr)->soap_out(soap, tag, id, "ns2:iteratorContainer");
	case SOAP_TYPE_ns2__entitySpec:
		return ((ns2__entitySpec *)ptr)->soap_out(soap, tag, id, "ns2:entitySpec");
	case SOAP_TYPE_ns2__setSpec:
		return ((ns2__setSpec *)ptr)->soap_out(soap, tag, id, "ns2:setSpec");
	case SOAP_TYPE_ns2__modelSpec:
		return ((ns2__modelSpec *)ptr)->soap_out(soap, tag, id, "ns2:modelSpec");
	case SOAP_TYPE_PointerTo_ns1__getSolverStatusResponse:
		return soap_out_PointerTo_ns1__getSolverStatusResponse(soap, tag, id, (_ns1__getSolverStatusResponse *const*)ptr, "ns1:getSolverStatusResponse");
	case SOAP_TYPE_PointerTo_ns1__getSolverStatusRequest:
		return soap_out_PointerTo_ns1__getSolverStatusRequest(soap, tag, id, (_ns1__getSolverStatusRequest *const*)ptr, "ns1:getSolverStatusRequest");
	case SOAP_TYPE_PointerTo_ns1__storeEntityValuesResponse:
		return soap_out_PointerTo_ns1__storeEntityValuesResponse(soap, tag, id, (_ns1__storeEntityValuesResponse *const*)ptr, "ns1:storeEntityValuesResponse");
	case SOAP_TYPE_PointerTo_ns1__storeEntityValuesRequest:
		return soap_out_PointerTo_ns1__storeEntityValuesRequest(soap, tag, id, (_ns1__storeEntityValuesRequest *const*)ptr, "ns1:storeEntityValuesRequest");
	case SOAP_TYPE_PointerTo_ns1__removeSetMembersResponse:
		return soap_out_PointerTo_ns1__removeSetMembersResponse(soap, tag, id, (_ns1__removeSetMembersResponse *const*)ptr, "ns1:removeSetMembersResponse");
	case SOAP_TYPE_PointerTo_ns1__removeSetMembersRequest:
		return soap_out_PointerTo_ns1__removeSetMembersRequest(soap, tag, id, (_ns1__removeSetMembersRequest *const*)ptr, "ns1:removeSetMembersRequest");
	case SOAP_TYPE_PointerTo_ns1__defineInstanceResponse:
		return soap_out_PointerTo_ns1__defineInstanceResponse(soap, tag, id, (_ns1__defineInstanceResponse *const*)ptr, "ns1:defineInstanceResponse");
	case SOAP_TYPE_PointerTo_ns1__defineInstanceRequest:
		return soap_out_PointerTo_ns1__defineInstanceRequest(soap, tag, id, (_ns1__defineInstanceRequest *const*)ptr, "ns1:defineInstanceRequest");
	case SOAP_TYPE_PointerTo_ns1__runSolverResponse:
		return soap_out_PointerTo_ns1__runSolverResponse(soap, tag, id, (_ns1__runSolverResponse *const*)ptr, "ns1:runSolverResponse");
	case SOAP_TYPE_PointerTo_ns1__runSolverRequest:
		return soap_out_PointerTo_ns1__runSolverRequest(soap, tag, id, (_ns1__runSolverRequest *const*)ptr, "ns1:runSolverRequest");
	case SOAP_TYPE_PointerTo_ns1__storeSetMembersResponse:
		return soap_out_PointerTo_ns1__storeSetMembersResponse(soap, tag, id, (_ns1__storeSetMembersResponse *const*)ptr, "ns1:storeSetMembersResponse");
	case SOAP_TYPE_PointerTo_ns1__storeSetMembersRequest:
		return soap_out_PointerTo_ns1__storeSetMembersRequest(soap, tag, id, (_ns1__storeSetMembersRequest *const*)ptr, "ns1:storeSetMembersRequest");
	case SOAP_TYPE_PointerTo_ns1__definePreferenceResponse:
		return soap_out_PointerTo_ns1__definePreferenceResponse(soap, tag, id, (_ns1__definePreferenceResponse *const*)ptr, "ns1:definePreferenceResponse");
	case SOAP_TYPE_PointerTo_ns1__definePreferenceRequest:
		return soap_out_PointerTo_ns1__definePreferenceRequest(soap, tag, id, (_ns1__definePreferenceRequest *const*)ptr, "ns1:definePreferenceRequest");
	case SOAP_TYPE_PointerTo_ns1__getSetMembersResponse:
		return soap_out_PointerTo_ns1__getSetMembersResponse(soap, tag, id, (_ns1__getSetMembersResponse *const*)ptr, "ns1:getSetMembersResponse");
	case SOAP_TYPE_PointerTo_ns1__getSetMembersRequest:
		return soap_out_PointerTo_ns1__getSetMembersRequest(soap, tag, id, (_ns1__getSetMembersRequest *const*)ptr, "ns1:getSetMembersRequest");
	case SOAP_TYPE_PointerTo_ns1__storeSolutionResponse:
		return soap_out_PointerTo_ns1__storeSolutionResponse(soap, tag, id, (_ns1__storeSolutionResponse *const*)ptr, "ns1:storeSolutionResponse");
	case SOAP_TYPE_PointerTo_ns1__storeSolutionRequest:
		return soap_out_PointerTo_ns1__storeSolutionRequest(soap, tag, id, (_ns1__storeSolutionRequest *const*)ptr, "ns1:storeSolutionRequest");
	case SOAP_TYPE_PointerTo_ns1__getDataSummaryResponse:
		return soap_out_PointerTo_ns1__getDataSummaryResponse(soap, tag, id, (_ns1__getDataSummaryResponse *const*)ptr, "ns1:getDataSummaryResponse");
	case SOAP_TYPE_PointerTo_ns1__getDataSummaryRequest:
		return soap_out_PointerTo_ns1__getDataSummaryRequest(soap, tag, id, (_ns1__getDataSummaryRequest *const*)ptr, "ns1:getDataSummaryRequest");
	case SOAP_TYPE_PointerTo_ns1__removeEntityValuesResponse:
		return soap_out_PointerTo_ns1__removeEntityValuesResponse(soap, tag, id, (_ns1__removeEntityValuesResponse *const*)ptr, "ns1:removeEntityValuesResponse");
	case SOAP_TYPE_PointerTo_ns1__removeEntityValuesRequest:
		return soap_out_PointerTo_ns1__removeEntityValuesRequest(soap, tag, id, (_ns1__removeEntityValuesRequest *const*)ptr, "ns1:removeEntityValuesRequest");
	case SOAP_TYPE_PointerTo_ns1__getBatchValuesResponse:
		return soap_out_PointerTo_ns1__getBatchValuesResponse(soap, tag, id, (_ns1__getBatchValuesResponse *const*)ptr, "ns1:getBatchValuesResponse");
	case SOAP_TYPE_PointerTo_ns1__getBatchValuesRequest:
		return soap_out_PointerTo_ns1__getBatchValuesRequest(soap, tag, id, (_ns1__getBatchValuesRequest *const*)ptr, "ns1:getBatchValuesRequest");
	case SOAP_TYPE_PointerTo_ns1__getSolutionResponse:
		return soap_out_PointerTo_ns1__getSolutionResponse(soap, tag, id, (_ns1__getSolutionResponse *const*)ptr, "ns1:getSolutionResponse");
	case SOAP_TYPE_PointerTo_ns1__getSolutionRequest:
		return soap_out_PointerTo_ns1__getSolutionRequest(soap, tag, id, (_ns1__getSolutionRequest *const*)ptr, "ns1:getSolutionRequest");
	case SOAP_TYPE_PointerTo_ns1__getSMSResponse:
		return soap_out_PointerTo_ns1__getSMSResponse(soap, tag, id, (_ns1__getSMSResponse *const*)ptr, "ns1:getSMSResponse");
	case SOAP_TYPE_PointerTo_ns1__getSMSRequest:
		return soap_out_PointerTo_ns1__getSMSRequest(soap, tag, id, (_ns1__getSMSRequest *const*)ptr, "ns1:getSMSRequest");
	case SOAP_TYPE_PointerTo_ns1__storeMainSetResponse:
		return soap_out_PointerTo_ns1__storeMainSetResponse(soap, tag, id, (_ns1__storeMainSetResponse *const*)ptr, "ns1:storeMainSetResponse");
	case SOAP_TYPE_PointerTo_ns1__storeMainSetRequest:
		return soap_out_PointerTo_ns1__storeMainSetRequest(soap, tag, id, (_ns1__storeMainSetRequest *const*)ptr, "ns1:storeMainSetRequest");
	case SOAP_TYPE_PointerTo_ns1__getEntityValuesResponse:
		return soap_out_PointerTo_ns1__getEntityValuesResponse(soap, tag, id, (_ns1__getEntityValuesResponse *const*)ptr, "ns1:getEntityValuesResponse");
	case SOAP_TYPE_PointerTo_ns1__getEntityValuesRequest:
		return soap_out_PointerTo_ns1__getEntityValuesRequest(soap, tag, id, (_ns1__getEntityValuesRequest *const*)ptr, "ns1:getEntityValuesRequest");
	case SOAP_TYPE_PointerTo_ns1__getPreferenceResponse:
		return soap_out_PointerTo_ns1__getPreferenceResponse(soap, tag, id, (_ns1__getPreferenceResponse *const*)ptr, "ns1:getPreferenceResponse");
	case SOAP_TYPE_PointerTo_ns1__getPreferenceRequest:
		return soap_out_PointerTo_ns1__getPreferenceRequest(soap, tag, id, (_ns1__getPreferenceRequest *const*)ptr, "ns1:getPreferenceRequest");
	case SOAP_TYPE_PointerTo_ns1__defineAnalysisResponse:
		return soap_out_PointerTo_ns1__defineAnalysisResponse(soap, tag, id, (_ns1__defineAnalysisResponse *const*)ptr, "ns1:defineAnalysisResponse");
	case SOAP_TYPE_PointerTo_ns1__defineAnalysisRequest:
		return soap_out_PointerTo_ns1__defineAnalysisRequest(soap, tag, id, (_ns1__defineAnalysisRequest *const*)ptr, "ns1:defineAnalysisRequest");
	case SOAP_TYPE_PointerTo_ns1__runScenarioResponse:
		return soap_out_PointerTo_ns1__runScenarioResponse(soap, tag, id, (_ns1__runScenarioResponse *const*)ptr, "ns1:runScenarioResponse");
	case SOAP_TYPE_PointerTo_ns1__runScenarioRequest:
		return soap_out_PointerTo_ns1__runScenarioRequest(soap, tag, id, (_ns1__runScenarioRequest *const*)ptr, "ns1:runScenarioRequest");
	case SOAP_TYPE_PointerTo_ns1__defineModelDataResponse:
		return soap_out_PointerTo_ns1__defineModelDataResponse(soap, tag, id, (_ns1__defineModelDataResponse *const*)ptr, "ns1:defineModelDataResponse");
	case SOAP_TYPE_PointerTo_ns1__defineModelDataRequest:
		return soap_out_PointerTo_ns1__defineModelDataRequest(soap, tag, id, (_ns1__defineModelDataRequest *const*)ptr, "ns1:defineModelDataRequest");
	case SOAP_TYPE_PointerTo_ns1__getAnalysesResponse:
		return soap_out_PointerTo_ns1__getAnalysesResponse(soap, tag, id, (_ns1__getAnalysesResponse *const*)ptr, "ns1:getAnalysesResponse");
	case SOAP_TYPE_PointerTo_ns1__getAnalysesRequest:
		return soap_out_PointerTo_ns1__getAnalysesRequest(soap, tag, id, (_ns1__getAnalysesRequest *const*)ptr, "ns1:getAnalysesRequest");
	case SOAP_TYPE_PointerTo_ns1__updateSolverStatusResponse:
		return soap_out_PointerTo_ns1__updateSolverStatusResponse(soap, tag, id, (_ns1__updateSolverStatusResponse *const*)ptr, "ns1:updateSolverStatusResponse");
	case SOAP_TYPE_PointerTo_ns1__updateSolverStatusRequest:
		return soap_out_PointerTo_ns1__updateSolverStatusRequest(soap, tag, id, (_ns1__updateSolverStatusRequest *const*)ptr, "ns1:updateSolverStatusRequest");
	case SOAP_TYPE_PointerTo_ns1__changeModelDataStatusResponse:
		return soap_out_PointerTo_ns1__changeModelDataStatusResponse(soap, tag, id, (_ns1__changeModelDataStatusResponse *const*)ptr, "ns1:changeModelDataStatusResponse");
	case SOAP_TYPE_PointerTo_ns1__changeModelDataStatusRequest:
		return soap_out_PointerTo_ns1__changeModelDataStatusRequest(soap, tag, id, (_ns1__changeModelDataStatusRequest *const*)ptr, "ns1:changeModelDataStatusRequest");
	case SOAP_TYPE_PointerTons4__preference:
		return soap_out_PointerTons4__preference(soap, tag, id, (ns4__preference *const*)ptr, "ns4:preference");
	case SOAP_TYPE_PointerTons4__analysis:
		return soap_out_PointerTons4__analysis(soap, tag, id, (ns4__analysis *const*)ptr, "ns4:analysis");
	case SOAP_TYPE_PointerTons3__modelInstance:
		return soap_out_PointerTons3__modelInstance(soap, tag, id, (ns3__modelInstance *const*)ptr, "ns3:modelInstance");
	case SOAP_TYPE_PointerTons3__modelData:
		return soap_out_PointerTons3__modelData(soap, tag, id, (ns3__modelData *const*)ptr, "ns3:modelData");
	case SOAP_TYPE_PointerTons3__batchValues:
		return soap_out_PointerTons3__batchValues(soap, tag, id, (ns3__batchValues *const*)ptr, "ns3:batchValues");
	case SOAP_TYPE_PointerTons3__tupleValue:
		return soap_out_PointerTons3__tupleValue(soap, tag, id, (ns3__tupleValue *const*)ptr, "ns3:tupleValue");
	case SOAP_TYPE_PointerTons2__modelSpec:
		return soap_out_PointerTons2__modelSpec(soap, tag, id, (ns2__modelSpec *const*)ptr, "ns2:modelSpec");
	case SOAP_TYPE_PointerTons3__entityValues:
		return soap_out_PointerTons3__entityValues(soap, tag, id, (ns3__entityValues *const*)ptr, "ns3:entityValues");
	case SOAP_TYPE_PointerTons3__setMembers:
		return soap_out_PointerTons3__setMembers(soap, tag, id, (ns3__setMembers *const*)ptr, "ns3:setMembers");
	case SOAP_TYPE_PointerTons3__tupleValues:
		return soap_out_PointerTons3__tupleValues(soap, tag, id, (ns3__tupleValues *const*)ptr, "ns3:tupleValues");
	case SOAP_TYPE_PointerTons3__tupleMembers:
		return soap_out_PointerTons3__tupleMembers(soap, tag, id, (ns3__tupleMembers *const*)ptr, "ns3:tupleMembers");
	case SOAP_TYPE_PointerTons3__value:
		return soap_out_PointerTons3__value(soap, tag, id, (ns3__value *const*)ptr, "ns3:value");
	case SOAP_TYPE_PointerTons3__memberDic:
		return soap_out_PointerTons3__memberDic(soap, tag, id, (ns3__memberDic *const*)ptr, "ns3:memberDic");
	case SOAP_TYPE_PointerTons2__shortName:
		return soap_out_PointerTons2__shortName(soap, tag, id, (std::string *const*)ptr, "ns2:shortName");
	case SOAP_TYPE_PointerTons2__entityRole:
		return soap_out_PointerTons2__entityRole(soap, tag, id, (enum ns2__entityRole *const*)ptr, "ns2:entityRole");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerTons2__iteratorContainer:
		return soap_out_PointerTons2__iteratorContainer(soap, tag, id, (ns2__iteratorContainer *const*)ptr, "ns2:iteratorContainer");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons2__entitySpec:
		return soap_out_PointerTons2__entitySpec(soap, tag, id, (ns2__entitySpec *const*)ptr, "ns2:entitySpec");
	case SOAP_TYPE_PointerTons2__setSpec:
		return soap_out_PointerTons2__setSpec(soap, tag, id, (ns2__setSpec *const*)ptr, "ns2:setSpec");
	case SOAP_TYPE_PointerTons2__description:
		return soap_out_PointerTons2__description(soap, tag, id, (std::string *const*)ptr, "ns2:description");
	case SOAP_TYPE_PointerTons2__name:
		return soap_out_PointerTons2__name(soap, tag, id, (std::string *const*)ptr, "ns2:name");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns2__description:
		soap_serialize_ns2__description(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__name:
		soap_serialize_ns2__name(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns2__shortName:
		soap_serialize_ns2__shortName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns1__runScenarioResponse:
		((_ns1__runScenarioResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__runScenarioRequest:
		((_ns1__runScenarioRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__runSolverResponse:
		((_ns1__runSolverResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__runSolverRequest:
		((_ns1__runSolverRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getSolverStatusResponse:
		((_ns1__getSolverStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getSolverStatusRequest:
		((_ns1__getSolverStatusRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__updateSolverStatusResponse:
		((_ns1__updateSolverStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__updateSolverStatusRequest:
		((_ns1__updateSolverStatusRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getSolutionResponse:
		((_ns1__getSolutionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getSolutionRequest:
		((_ns1__getSolutionRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__storeSolutionResponse:
		((_ns1__storeSolutionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__storeSolutionRequest:
		((_ns1__storeSolutionRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getPreferenceResponse:
		((_ns1__getPreferenceResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getPreferenceRequest:
		((_ns1__getPreferenceRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__definePreferenceResponse:
		((_ns1__definePreferenceResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__definePreferenceRequest:
		((_ns1__definePreferenceRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getAnalysesResponse:
		((_ns1__getAnalysesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getAnalysesRequest:
		((_ns1__getAnalysesRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__defineAnalysisResponse:
		((_ns1__defineAnalysisResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__defineAnalysisRequest:
		((_ns1__defineAnalysisRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getDataSummaryResponse:
		((_ns1__getDataSummaryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getDataSummaryRequest:
		((_ns1__getDataSummaryRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__defineInstanceResponse:
		((_ns1__defineInstanceResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__defineInstanceRequest:
		((_ns1__defineInstanceRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__changeModelDataStatusResponse:
		((_ns1__changeModelDataStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__changeModelDataStatusRequest:
		((_ns1__changeModelDataStatusRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__defineModelDataResponse:
		((_ns1__defineModelDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__defineModelDataRequest:
		((_ns1__defineModelDataRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeEntityValuesResponse:
		((_ns1__removeEntityValuesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeEntityValuesRequest:
		((_ns1__removeEntityValuesRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__storeEntityValuesResponse:
		((_ns1__storeEntityValuesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__storeEntityValuesRequest:
		((_ns1__storeEntityValuesRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeSetMembersResponse:
		((_ns1__removeSetMembersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__removeSetMembersRequest:
		((_ns1__removeSetMembersRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__storeSetMembersResponse:
		((_ns1__storeSetMembersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__storeSetMembersRequest:
		((_ns1__storeSetMembersRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__storeMainSetResponse:
		((_ns1__storeMainSetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__storeMainSetRequest:
		((_ns1__storeMainSetRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getSetMembersResponse:
		((_ns1__getSetMembersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getSetMembersRequest:
		((_ns1__getSetMembersRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getBatchValuesResponse:
		((_ns1__getBatchValuesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getBatchValuesRequest:
		((_ns1__getBatchValuesRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getEntityValuesResponse:
		((_ns1__getEntityValuesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getEntityValuesRequest:
		((_ns1__getEntityValuesRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getSMSResponse:
		((_ns1__getSMSResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getSMSRequest:
		((_ns1__getSMSRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__preference:
		((ns4__preference *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__analysis:
		((ns4__analysis *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__dataSet:
		((_ns3__dataSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__value:
		((ns3__value *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__batchValues:
		((ns3__batchValues *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__tupleValues:
		((ns3__tupleValues *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__entityValues:
		((ns3__entityValues *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__tupleMembers:
		((ns3__tupleMembers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__setMembers:
		((ns3__setMembers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__tupleValue:
		((ns3__tupleValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__memberDic:
		((ns3__memberDic *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__modelInstance:
		((ns3__modelInstance *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__modelData:
		((ns3__modelData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__iteratorContainer:
		((ns2__iteratorContainer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__entitySpec:
		((ns2__entitySpec *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__setSpec:
		((ns2__setSpec *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__modelSpec:
		((ns2__modelSpec *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__getSolverStatus:
		soap_serialize___ns1__getSolverStatus(soap, (const struct __ns1__getSolverStatus *)ptr);
		break;
	case SOAP_TYPE___ns1__storeEntityValues:
		soap_serialize___ns1__storeEntityValues(soap, (const struct __ns1__storeEntityValues *)ptr);
		break;
	case SOAP_TYPE___ns1__removeSetMembers:
		soap_serialize___ns1__removeSetMembers(soap, (const struct __ns1__removeSetMembers *)ptr);
		break;
	case SOAP_TYPE___ns1__defineInstance:
		soap_serialize___ns1__defineInstance(soap, (const struct __ns1__defineInstance *)ptr);
		break;
	case SOAP_TYPE___ns1__runSolver:
		soap_serialize___ns1__runSolver(soap, (const struct __ns1__runSolver *)ptr);
		break;
	case SOAP_TYPE___ns1__storeSetMembers:
		soap_serialize___ns1__storeSetMembers(soap, (const struct __ns1__storeSetMembers *)ptr);
		break;
	case SOAP_TYPE___ns1__definePreference:
		soap_serialize___ns1__definePreference(soap, (const struct __ns1__definePreference *)ptr);
		break;
	case SOAP_TYPE___ns1__getSetMembers:
		soap_serialize___ns1__getSetMembers(soap, (const struct __ns1__getSetMembers *)ptr);
		break;
	case SOAP_TYPE___ns1__storeSolution:
		soap_serialize___ns1__storeSolution(soap, (const struct __ns1__storeSolution *)ptr);
		break;
	case SOAP_TYPE___ns1__getDataSummary:
		soap_serialize___ns1__getDataSummary(soap, (const struct __ns1__getDataSummary *)ptr);
		break;
	case SOAP_TYPE___ns1__removeEntityValues:
		soap_serialize___ns1__removeEntityValues(soap, (const struct __ns1__removeEntityValues *)ptr);
		break;
	case SOAP_TYPE___ns1__getBatchValues:
		soap_serialize___ns1__getBatchValues(soap, (const struct __ns1__getBatchValues *)ptr);
		break;
	case SOAP_TYPE___ns1__getSolution:
		soap_serialize___ns1__getSolution(soap, (const struct __ns1__getSolution *)ptr);
		break;
	case SOAP_TYPE___ns1__getSMS:
		soap_serialize___ns1__getSMS(soap, (const struct __ns1__getSMS *)ptr);
		break;
	case SOAP_TYPE___ns1__storeMainSet:
		soap_serialize___ns1__storeMainSet(soap, (const struct __ns1__storeMainSet *)ptr);
		break;
	case SOAP_TYPE___ns1__getEntityValues:
		soap_serialize___ns1__getEntityValues(soap, (const struct __ns1__getEntityValues *)ptr);
		break;
	case SOAP_TYPE___ns1__getPreference:
		soap_serialize___ns1__getPreference(soap, (const struct __ns1__getPreference *)ptr);
		break;
	case SOAP_TYPE___ns1__defineAnalysis:
		soap_serialize___ns1__defineAnalysis(soap, (const struct __ns1__defineAnalysis *)ptr);
		break;
	case SOAP_TYPE___ns1__runScenario:
		soap_serialize___ns1__runScenario(soap, (const struct __ns1__runScenario *)ptr);
		break;
	case SOAP_TYPE___ns1__defineModelData:
		soap_serialize___ns1__defineModelData(soap, (const struct __ns1__defineModelData *)ptr);
		break;
	case SOAP_TYPE___ns1__getAnalyses:
		soap_serialize___ns1__getAnalyses(soap, (const struct __ns1__getAnalyses *)ptr);
		break;
	case SOAP_TYPE___ns1__updateSolverStatus:
		soap_serialize___ns1__updateSolverStatus(soap, (const struct __ns1__updateSolverStatus *)ptr);
		break;
	case SOAP_TYPE___ns1__changeModelDataStatus:
		soap_serialize___ns1__changeModelDataStatus(soap, (const struct __ns1__changeModelDataStatus *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getSolverStatusResponse:
		soap_serialize_PointerTo_ns1__getSolverStatusResponse(soap, (_ns1__getSolverStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getSolverStatusRequest:
		soap_serialize_PointerTo_ns1__getSolverStatusRequest(soap, (_ns1__getSolverStatusRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__storeEntityValuesResponse:
		soap_serialize_PointerTo_ns1__storeEntityValuesResponse(soap, (_ns1__storeEntityValuesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__storeEntityValuesRequest:
		soap_serialize_PointerTo_ns1__storeEntityValuesRequest(soap, (_ns1__storeEntityValuesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeSetMembersResponse:
		soap_serialize_PointerTo_ns1__removeSetMembersResponse(soap, (_ns1__removeSetMembersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeSetMembersRequest:
		soap_serialize_PointerTo_ns1__removeSetMembersRequest(soap, (_ns1__removeSetMembersRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__defineInstanceResponse:
		soap_serialize_PointerTo_ns1__defineInstanceResponse(soap, (_ns1__defineInstanceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__defineInstanceRequest:
		soap_serialize_PointerTo_ns1__defineInstanceRequest(soap, (_ns1__defineInstanceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__runSolverResponse:
		soap_serialize_PointerTo_ns1__runSolverResponse(soap, (_ns1__runSolverResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__runSolverRequest:
		soap_serialize_PointerTo_ns1__runSolverRequest(soap, (_ns1__runSolverRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__storeSetMembersResponse:
		soap_serialize_PointerTo_ns1__storeSetMembersResponse(soap, (_ns1__storeSetMembersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__storeSetMembersRequest:
		soap_serialize_PointerTo_ns1__storeSetMembersRequest(soap, (_ns1__storeSetMembersRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__definePreferenceResponse:
		soap_serialize_PointerTo_ns1__definePreferenceResponse(soap, (_ns1__definePreferenceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__definePreferenceRequest:
		soap_serialize_PointerTo_ns1__definePreferenceRequest(soap, (_ns1__definePreferenceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getSetMembersResponse:
		soap_serialize_PointerTo_ns1__getSetMembersResponse(soap, (_ns1__getSetMembersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getSetMembersRequest:
		soap_serialize_PointerTo_ns1__getSetMembersRequest(soap, (_ns1__getSetMembersRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__storeSolutionResponse:
		soap_serialize_PointerTo_ns1__storeSolutionResponse(soap, (_ns1__storeSolutionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__storeSolutionRequest:
		soap_serialize_PointerTo_ns1__storeSolutionRequest(soap, (_ns1__storeSolutionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDataSummaryResponse:
		soap_serialize_PointerTo_ns1__getDataSummaryResponse(soap, (_ns1__getDataSummaryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDataSummaryRequest:
		soap_serialize_PointerTo_ns1__getDataSummaryRequest(soap, (_ns1__getDataSummaryRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeEntityValuesResponse:
		soap_serialize_PointerTo_ns1__removeEntityValuesResponse(soap, (_ns1__removeEntityValuesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__removeEntityValuesRequest:
		soap_serialize_PointerTo_ns1__removeEntityValuesRequest(soap, (_ns1__removeEntityValuesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getBatchValuesResponse:
		soap_serialize_PointerTo_ns1__getBatchValuesResponse(soap, (_ns1__getBatchValuesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getBatchValuesRequest:
		soap_serialize_PointerTo_ns1__getBatchValuesRequest(soap, (_ns1__getBatchValuesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getSolutionResponse:
		soap_serialize_PointerTo_ns1__getSolutionResponse(soap, (_ns1__getSolutionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getSolutionRequest:
		soap_serialize_PointerTo_ns1__getSolutionRequest(soap, (_ns1__getSolutionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getSMSResponse:
		soap_serialize_PointerTo_ns1__getSMSResponse(soap, (_ns1__getSMSResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getSMSRequest:
		soap_serialize_PointerTo_ns1__getSMSRequest(soap, (_ns1__getSMSRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__storeMainSetResponse:
		soap_serialize_PointerTo_ns1__storeMainSetResponse(soap, (_ns1__storeMainSetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__storeMainSetRequest:
		soap_serialize_PointerTo_ns1__storeMainSetRequest(soap, (_ns1__storeMainSetRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getEntityValuesResponse:
		soap_serialize_PointerTo_ns1__getEntityValuesResponse(soap, (_ns1__getEntityValuesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getEntityValuesRequest:
		soap_serialize_PointerTo_ns1__getEntityValuesRequest(soap, (_ns1__getEntityValuesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPreferenceResponse:
		soap_serialize_PointerTo_ns1__getPreferenceResponse(soap, (_ns1__getPreferenceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPreferenceRequest:
		soap_serialize_PointerTo_ns1__getPreferenceRequest(soap, (_ns1__getPreferenceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__defineAnalysisResponse:
		soap_serialize_PointerTo_ns1__defineAnalysisResponse(soap, (_ns1__defineAnalysisResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__defineAnalysisRequest:
		soap_serialize_PointerTo_ns1__defineAnalysisRequest(soap, (_ns1__defineAnalysisRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__runScenarioResponse:
		soap_serialize_PointerTo_ns1__runScenarioResponse(soap, (_ns1__runScenarioResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__runScenarioRequest:
		soap_serialize_PointerTo_ns1__runScenarioRequest(soap, (_ns1__runScenarioRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__defineModelDataResponse:
		soap_serialize_PointerTo_ns1__defineModelDataResponse(soap, (_ns1__defineModelDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__defineModelDataRequest:
		soap_serialize_PointerTo_ns1__defineModelDataRequest(soap, (_ns1__defineModelDataRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAnalysesResponse:
		soap_serialize_PointerTo_ns1__getAnalysesResponse(soap, (_ns1__getAnalysesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAnalysesRequest:
		soap_serialize_PointerTo_ns1__getAnalysesRequest(soap, (_ns1__getAnalysesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateSolverStatusResponse:
		soap_serialize_PointerTo_ns1__updateSolverStatusResponse(soap, (_ns1__updateSolverStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateSolverStatusRequest:
		soap_serialize_PointerTo_ns1__updateSolverStatusRequest(soap, (_ns1__updateSolverStatusRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__changeModelDataStatusResponse:
		soap_serialize_PointerTo_ns1__changeModelDataStatusResponse(soap, (_ns1__changeModelDataStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__changeModelDataStatusRequest:
		soap_serialize_PointerTo_ns1__changeModelDataStatusRequest(soap, (_ns1__changeModelDataStatusRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__preference:
		soap_serialize_PointerTons4__preference(soap, (ns4__preference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__analysis:
		soap_serialize_PointerTons4__analysis(soap, (ns4__analysis *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__modelInstance:
		soap_serialize_PointerTons3__modelInstance(soap, (ns3__modelInstance *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__modelData:
		soap_serialize_PointerTons3__modelData(soap, (ns3__modelData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__batchValues:
		soap_serialize_PointerTons3__batchValues(soap, (ns3__batchValues *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__tupleValue:
		soap_serialize_PointerTons3__tupleValue(soap, (ns3__tupleValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__modelSpec:
		soap_serialize_PointerTons2__modelSpec(soap, (ns2__modelSpec *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__entityValues:
		soap_serialize_PointerTons3__entityValues(soap, (ns3__entityValues *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__setMembers:
		soap_serialize_PointerTons3__setMembers(soap, (ns3__setMembers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__tupleValues:
		soap_serialize_PointerTons3__tupleValues(soap, (ns3__tupleValues *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__tupleMembers:
		soap_serialize_PointerTons3__tupleMembers(soap, (ns3__tupleMembers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__value:
		soap_serialize_PointerTons3__value(soap, (ns3__value *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__memberDic:
		soap_serialize_PointerTons3__memberDic(soap, (ns3__memberDic *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__shortName:
		soap_serialize_PointerTons2__shortName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__entityRole:
		soap_serialize_PointerTons2__entityRole(soap, (enum ns2__entityRole *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__iteratorContainer:
		soap_serialize_PointerTons2__iteratorContainer(soap, (ns2__iteratorContainer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__entitySpec:
		soap_serialize_PointerTons2__entitySpec(soap, (ns2__entitySpec *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__setSpec:
		soap_serialize_PointerTons2__setSpec(soap, (ns2__setSpec *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__description:
		soap_serialize_PointerTons2__description(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__name:
		soap_serialize_PointerTons2__name(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__modelSpec:
		return (void*)soap_instantiate_ns2__modelSpec(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__setSpec:
		return (void*)soap_instantiate_ns2__setSpec(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__entitySpec:
		return (void*)soap_instantiate_ns2__entitySpec(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__iteratorContainer:
		return (void*)soap_instantiate_ns2__iteratorContainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__modelData:
		return (void*)soap_instantiate_ns3__modelData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__modelInstance:
		return (void*)soap_instantiate_ns3__modelInstance(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__memberDic:
		return (void*)soap_instantiate_ns3__memberDic(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__tupleValue:
		return (void*)soap_instantiate_ns3__tupleValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__setMembers:
		return (void*)soap_instantiate_ns3__setMembers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__tupleMembers:
		return (void*)soap_instantiate_ns3__tupleMembers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__entityValues:
		return (void*)soap_instantiate_ns3__entityValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__tupleValues:
		return (void*)soap_instantiate_ns3__tupleValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__batchValues:
		return (void*)soap_instantiate_ns3__batchValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__value:
		return (void*)soap_instantiate_ns3__value(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__dataSet:
		return (void*)soap_instantiate__ns3__dataSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__analysis:
		return (void*)soap_instantiate_ns4__analysis(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__preference:
		return (void*)soap_instantiate_ns4__preference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getSMSRequest:
		return (void*)soap_instantiate__ns1__getSMSRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getSMSResponse:
		return (void*)soap_instantiate__ns1__getSMSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getEntityValuesRequest:
		return (void*)soap_instantiate__ns1__getEntityValuesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getEntityValuesResponse:
		return (void*)soap_instantiate__ns1__getEntityValuesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getBatchValuesRequest:
		return (void*)soap_instantiate__ns1__getBatchValuesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getBatchValuesResponse:
		return (void*)soap_instantiate__ns1__getBatchValuesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getSetMembersRequest:
		return (void*)soap_instantiate__ns1__getSetMembersRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getSetMembersResponse:
		return (void*)soap_instantiate__ns1__getSetMembersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__storeMainSetRequest:
		return (void*)soap_instantiate__ns1__storeMainSetRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__storeMainSetResponse:
		return (void*)soap_instantiate__ns1__storeMainSetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__storeSetMembersRequest:
		return (void*)soap_instantiate__ns1__storeSetMembersRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__storeSetMembersResponse:
		return (void*)soap_instantiate__ns1__storeSetMembersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeSetMembersRequest:
		return (void*)soap_instantiate__ns1__removeSetMembersRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeSetMembersResponse:
		return (void*)soap_instantiate__ns1__removeSetMembersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__storeEntityValuesRequest:
		return (void*)soap_instantiate__ns1__storeEntityValuesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__storeEntityValuesResponse:
		return (void*)soap_instantiate__ns1__storeEntityValuesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeEntityValuesRequest:
		return (void*)soap_instantiate__ns1__removeEntityValuesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__removeEntityValuesResponse:
		return (void*)soap_instantiate__ns1__removeEntityValuesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__defineModelDataRequest:
		return (void*)soap_instantiate__ns1__defineModelDataRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__defineModelDataResponse:
		return (void*)soap_instantiate__ns1__defineModelDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__changeModelDataStatusRequest:
		return (void*)soap_instantiate__ns1__changeModelDataStatusRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__changeModelDataStatusResponse:
		return (void*)soap_instantiate__ns1__changeModelDataStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__defineInstanceRequest:
		return (void*)soap_instantiate__ns1__defineInstanceRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__defineInstanceResponse:
		return (void*)soap_instantiate__ns1__defineInstanceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getDataSummaryRequest:
		return (void*)soap_instantiate__ns1__getDataSummaryRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getDataSummaryResponse:
		return (void*)soap_instantiate__ns1__getDataSummaryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__defineAnalysisRequest:
		return (void*)soap_instantiate__ns1__defineAnalysisRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__defineAnalysisResponse:
		return (void*)soap_instantiate__ns1__defineAnalysisResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getAnalysesRequest:
		return (void*)soap_instantiate__ns1__getAnalysesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getAnalysesResponse:
		return (void*)soap_instantiate__ns1__getAnalysesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__definePreferenceRequest:
		return (void*)soap_instantiate__ns1__definePreferenceRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__definePreferenceResponse:
		return (void*)soap_instantiate__ns1__definePreferenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getPreferenceRequest:
		return (void*)soap_instantiate__ns1__getPreferenceRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getPreferenceResponse:
		return (void*)soap_instantiate__ns1__getPreferenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__storeSolutionRequest:
		return (void*)soap_instantiate__ns1__storeSolutionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__storeSolutionResponse:
		return (void*)soap_instantiate__ns1__storeSolutionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getSolutionRequest:
		return (void*)soap_instantiate__ns1__getSolutionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getSolutionResponse:
		return (void*)soap_instantiate__ns1__getSolutionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__updateSolverStatusRequest:
		return (void*)soap_instantiate__ns1__updateSolverStatusRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__updateSolverStatusResponse:
		return (void*)soap_instantiate__ns1__updateSolverStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getSolverStatusRequest:
		return (void*)soap_instantiate__ns1__getSolverStatusRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getSolverStatusResponse:
		return (void*)soap_instantiate__ns1__getSolverStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__runSolverRequest:
		return (void*)soap_instantiate__ns1__runSolverRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__runSolverResponse:
		return (void*)soap_instantiate__ns1__runSolverResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__runScenarioRequest:
		return (void*)soap_instantiate__ns1__runScenarioRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__runScenarioResponse:
		return (void*)soap_instantiate__ns1__runScenarioResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__changeModelDataStatus:
		return (void*)soap_instantiate___ns1__changeModelDataStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateSolverStatus:
		return (void*)soap_instantiate___ns1__updateSolverStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAnalyses:
		return (void*)soap_instantiate___ns1__getAnalyses(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__defineModelData:
		return (void*)soap_instantiate___ns1__defineModelData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__runScenario:
		return (void*)soap_instantiate___ns1__runScenario(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__defineAnalysis:
		return (void*)soap_instantiate___ns1__defineAnalysis(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPreference:
		return (void*)soap_instantiate___ns1__getPreference(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getEntityValues:
		return (void*)soap_instantiate___ns1__getEntityValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__storeMainSet:
		return (void*)soap_instantiate___ns1__storeMainSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSMS:
		return (void*)soap_instantiate___ns1__getSMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSolution:
		return (void*)soap_instantiate___ns1__getSolution(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getBatchValues:
		return (void*)soap_instantiate___ns1__getBatchValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeEntityValues:
		return (void*)soap_instantiate___ns1__removeEntityValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getDataSummary:
		return (void*)soap_instantiate___ns1__getDataSummary(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__storeSolution:
		return (void*)soap_instantiate___ns1__storeSolution(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSetMembers:
		return (void*)soap_instantiate___ns1__getSetMembers(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__definePreference:
		return (void*)soap_instantiate___ns1__definePreference(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__storeSetMembers:
		return (void*)soap_instantiate___ns1__storeSetMembers(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__runSolver:
		return (void*)soap_instantiate___ns1__runSolver(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__defineInstance:
		return (void*)soap_instantiate___ns1__defineInstance(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeSetMembers:
		return (void*)soap_instantiate___ns1__removeSetMembers(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__storeEntityValues:
		return (void*)soap_instantiate___ns1__storeEntityValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSolverStatus:
		return (void*)soap_instantiate___ns1__getSolverStatus(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_ns2__shortName:
		return (void*)soap_instantiate_ns2__shortName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__name:
		return (void*)soap_instantiate_ns2__name(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__description:
		return (void*)soap_instantiate_ns2__description(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__preference:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__preference(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__analysis:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons4__analysis(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__modelInstance:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__modelInstance(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__batchValues:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__batchValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__tupleValue:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__tupleValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__entityValues:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__entityValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__setMembers:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__setMembers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__value:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__value(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__tupleValues:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__tupleValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__tupleMembers:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__tupleMembers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__memberDic:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons3__memberDic(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfint:
		return (void*)soap_instantiate_std__vectorTemplateOfint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__entitySpec:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__entitySpec(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__setSpec:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__setSpec(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__modelSpec:
		if (p->size < 0)
			SOAP_DELETE((ns2__modelSpec*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__modelSpec*)p->ptr);
		break;
	case SOAP_TYPE_ns2__setSpec:
		if (p->size < 0)
			SOAP_DELETE((ns2__setSpec*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__setSpec*)p->ptr);
		break;
	case SOAP_TYPE_ns2__entitySpec:
		if (p->size < 0)
			SOAP_DELETE((ns2__entitySpec*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__entitySpec*)p->ptr);
		break;
	case SOAP_TYPE_ns2__iteratorContainer:
		if (p->size < 0)
			SOAP_DELETE((ns2__iteratorContainer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__iteratorContainer*)p->ptr);
		break;
	case SOAP_TYPE_ns3__modelData:
		if (p->size < 0)
			SOAP_DELETE((ns3__modelData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__modelData*)p->ptr);
		break;
	case SOAP_TYPE_ns3__modelInstance:
		if (p->size < 0)
			SOAP_DELETE((ns3__modelInstance*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__modelInstance*)p->ptr);
		break;
	case SOAP_TYPE_ns3__memberDic:
		if (p->size < 0)
			SOAP_DELETE((ns3__memberDic*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__memberDic*)p->ptr);
		break;
	case SOAP_TYPE_ns3__tupleValue:
		if (p->size < 0)
			SOAP_DELETE((ns3__tupleValue*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__tupleValue*)p->ptr);
		break;
	case SOAP_TYPE_ns3__setMembers:
		if (p->size < 0)
			SOAP_DELETE((ns3__setMembers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__setMembers*)p->ptr);
		break;
	case SOAP_TYPE_ns3__tupleMembers:
		if (p->size < 0)
			SOAP_DELETE((ns3__tupleMembers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__tupleMembers*)p->ptr);
		break;
	case SOAP_TYPE_ns3__entityValues:
		if (p->size < 0)
			SOAP_DELETE((ns3__entityValues*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__entityValues*)p->ptr);
		break;
	case SOAP_TYPE_ns3__tupleValues:
		if (p->size < 0)
			SOAP_DELETE((ns3__tupleValues*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__tupleValues*)p->ptr);
		break;
	case SOAP_TYPE_ns3__batchValues:
		if (p->size < 0)
			SOAP_DELETE((ns3__batchValues*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__batchValues*)p->ptr);
		break;
	case SOAP_TYPE_ns3__value:
		if (p->size < 0)
			SOAP_DELETE((ns3__value*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__value*)p->ptr);
		break;
	case SOAP_TYPE__ns3__dataSet:
		if (p->size < 0)
			SOAP_DELETE((_ns3__dataSet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns3__dataSet*)p->ptr);
		break;
	case SOAP_TYPE_ns4__analysis:
		if (p->size < 0)
			SOAP_DELETE((ns4__analysis*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__analysis*)p->ptr);
		break;
	case SOAP_TYPE_ns4__preference:
		if (p->size < 0)
			SOAP_DELETE((ns4__preference*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__preference*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getSMSRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getSMSRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getSMSRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getSMSResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getSMSResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getSMSResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getEntityValuesRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getEntityValuesRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getEntityValuesRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getEntityValuesResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getEntityValuesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getEntityValuesResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getBatchValuesRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getBatchValuesRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getBatchValuesRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getBatchValuesResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getBatchValuesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getBatchValuesResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getSetMembersRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getSetMembersRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getSetMembersRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getSetMembersResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getSetMembersResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getSetMembersResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__storeMainSetRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__storeMainSetRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__storeMainSetRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__storeMainSetResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__storeMainSetResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__storeMainSetResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__storeSetMembersRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__storeSetMembersRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__storeSetMembersRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__storeSetMembersResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__storeSetMembersResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__storeSetMembersResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeSetMembersRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeSetMembersRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeSetMembersRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeSetMembersResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeSetMembersResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeSetMembersResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__storeEntityValuesRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__storeEntityValuesRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__storeEntityValuesRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__storeEntityValuesResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__storeEntityValuesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__storeEntityValuesResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeEntityValuesRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeEntityValuesRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeEntityValuesRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__removeEntityValuesResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__removeEntityValuesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__removeEntityValuesResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__defineModelDataRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__defineModelDataRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__defineModelDataRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__defineModelDataResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__defineModelDataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__defineModelDataResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__changeModelDataStatusRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__changeModelDataStatusRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__changeModelDataStatusRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__changeModelDataStatusResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__changeModelDataStatusResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__changeModelDataStatusResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__defineInstanceRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__defineInstanceRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__defineInstanceRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__defineInstanceResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__defineInstanceResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__defineInstanceResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getDataSummaryRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getDataSummaryRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getDataSummaryRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getDataSummaryResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getDataSummaryResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getDataSummaryResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__defineAnalysisRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__defineAnalysisRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__defineAnalysisRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__defineAnalysisResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__defineAnalysisResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__defineAnalysisResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getAnalysesRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getAnalysesRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getAnalysesRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getAnalysesResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getAnalysesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getAnalysesResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__definePreferenceRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__definePreferenceRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__definePreferenceRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__definePreferenceResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__definePreferenceResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__definePreferenceResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getPreferenceRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getPreferenceRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getPreferenceRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getPreferenceResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getPreferenceResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getPreferenceResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__storeSolutionRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__storeSolutionRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__storeSolutionRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__storeSolutionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__storeSolutionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__storeSolutionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getSolutionRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getSolutionRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getSolutionRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getSolutionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getSolutionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getSolutionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__updateSolverStatusRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__updateSolverStatusRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__updateSolverStatusRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__updateSolverStatusResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__updateSolverStatusResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__updateSolverStatusResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getSolverStatusRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getSolverStatusRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getSolverStatusRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getSolverStatusResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getSolverStatusResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getSolverStatusResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__runSolverRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__runSolverRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__runSolverRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__runSolverResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__runSolverResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__runSolverResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__runScenarioRequest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__runScenarioRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__runScenarioRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__runScenarioResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__runScenarioResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__runScenarioResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__changeModelDataStatus:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__changeModelDataStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__changeModelDataStatus*)p->ptr);
		break;
	case SOAP_TYPE___ns1__updateSolverStatus:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__updateSolverStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__updateSolverStatus*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAnalyses:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAnalyses*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAnalyses*)p->ptr);
		break;
	case SOAP_TYPE___ns1__defineModelData:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__defineModelData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__defineModelData*)p->ptr);
		break;
	case SOAP_TYPE___ns1__runScenario:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__runScenario*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__runScenario*)p->ptr);
		break;
	case SOAP_TYPE___ns1__defineAnalysis:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__defineAnalysis*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__defineAnalysis*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getPreference:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getPreference*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getPreference*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getEntityValues:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getEntityValues*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getEntityValues*)p->ptr);
		break;
	case SOAP_TYPE___ns1__storeMainSet:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__storeMainSet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__storeMainSet*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSMS:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSMS*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSMS*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSolution:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSolution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSolution*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getBatchValues:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getBatchValues*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getBatchValues*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeEntityValues:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeEntityValues*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeEntityValues*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getDataSummary:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getDataSummary*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getDataSummary*)p->ptr);
		break;
	case SOAP_TYPE___ns1__storeSolution:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__storeSolution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__storeSolution*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSetMembers:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSetMembers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSetMembers*)p->ptr);
		break;
	case SOAP_TYPE___ns1__definePreference:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__definePreference*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__definePreference*)p->ptr);
		break;
	case SOAP_TYPE___ns1__storeSetMembers:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__storeSetMembers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__storeSetMembers*)p->ptr);
		break;
	case SOAP_TYPE___ns1__runSolver:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__runSolver*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__runSolver*)p->ptr);
		break;
	case SOAP_TYPE___ns1__defineInstance:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__defineInstance*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__defineInstance*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeSetMembers:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeSetMembers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeSetMembers*)p->ptr);
		break;
	case SOAP_TYPE___ns1__storeEntityValues:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__storeEntityValues*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__storeEntityValues*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSolverStatus:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSolverStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSolverStatus*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_ns2__shortName:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__name:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__description:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__preference:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__preference * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__preference * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__analysis:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns4__analysis * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns4__analysis * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__modelInstance:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__modelInstance * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__modelInstance * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__batchValues:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__batchValues * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__batchValues * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__tupleValue:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__tupleValue * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__tupleValue * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__entityValues:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__entityValues * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__entityValues * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__setMembers:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__setMembers * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__setMembers * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__value:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__value * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__value * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__tupleValues:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__tupleValues * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__tupleValues * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__tupleMembers:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__tupleMembers * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__tupleMembers * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__memberDic:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns3__memberDic * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns3__memberDic * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		if (p->size < 0)
			SOAP_DELETE((std::vector<int >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<int >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__entitySpec:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__entitySpec * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__entitySpec * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__setSpec:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__setSpec * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__setSpec * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__preference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__preference * >*)p)[len] = *(ns4__preference **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons4__analysis:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns4__analysis * >*)p)[len] = *(ns4__analysis **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__modelInstance:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__modelInstance * >*)p)[len] = *(ns3__modelInstance **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__batchValues:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__batchValues * >*)p)[len] = *(ns3__batchValues **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__tupleValue:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__tupleValue * >*)p)[len] = *(ns3__tupleValue **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__entityValues:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__entityValues * >*)p)[len] = *(ns3__entityValues **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__setMembers:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__setMembers * >*)p)[len] = *(ns3__setMembers **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__value:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__value * >*)p)[len] = *(ns3__value **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__tupleValues:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__tupleValues * >*)p)[len] = *(ns3__tupleValues **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__tupleMembers:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__tupleMembers * >*)p)[len] = *(ns3__tupleMembers **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons3__memberDic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns3__memberDic * >*)p)[len] = *(ns3__memberDic **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<int >*)p)[len] = *(int *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__entitySpec:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__entitySpec * >*)p)[len] = *(ns2__entitySpec **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__setSpec:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__setSpec * >*)p)[len] = *(ns2__setSpec **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__responseStatus(struct soap *soap, enum ns1__responseStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__responseStatus
	*a = SOAP_DEFAULT_ns1__responseStatus;
#else
	*a = (enum ns1__responseStatus)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__responseStatus[] =
{	{ (long)ns1__responseStatus__OK, "OK" },
	{ (long)ns1__responseStatus__INVALID_USCORESETNAME, "INVALID_SETNAME" },
	{ (long)ns1__responseStatus__INVALID_USCOREDATAUPDATE, "INVALID_DATAUPDATE" },
	{ (long)ns1__responseStatus__INVALID_USCOREITERATOR, "INVALID_ITERATOR" },
	{ (long)ns1__responseStatus__INVALID_USCORESET_USCOREMEMBER, "INVALID_SET_MEMBER" },
	{ (long)ns1__responseStatus__INVALID_USCOREVALUE, "INVALID_VALUE" },
	{ (long)ns1__responseStatus__INVALID_USCOREENTITYNAME, "INVALID_ENTITYNAME" },
	{ (long)ns1__responseStatus__BOUND_USCOREVIOLATION, "BOUND_VIOLATION" },
	{ (long)ns1__responseStatus__UNKOWN_USCOREEXECEPTION, "UNKOWN_EXECEPTION" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__responseStatus2s(struct soap *soap, enum ns1__responseStatus n)
{	const char *s = soap_code_str(soap_codes_ns1__responseStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__responseStatus(struct soap *soap, const char *tag, int id, const enum ns1__responseStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__responseStatus), type) || soap_send(soap, soap_ns1__responseStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__responseStatus(struct soap *soap, const char *s, enum ns1__responseStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__responseStatus, s);
	if (map)
		*a = (enum ns1__responseStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__responseStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__responseStatus * SOAP_FMAC4 soap_in_ns1__responseStatus(struct soap *soap, const char *tag, enum ns1__responseStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__responseStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__responseStatus, sizeof(enum ns1__responseStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__responseStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__responseStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__responseStatus, 0, sizeof(enum ns1__responseStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__responseStatus(struct soap *soap, const enum ns1__responseStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__responseStatus);
	if (soap_out_ns1__responseStatus(soap, tag?tag:"ns1:responseStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__responseStatus * SOAP_FMAC4 soap_get_ns1__responseStatus(struct soap *soap, enum ns1__responseStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__responseStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__preferenceType(struct soap *soap, enum ns4__preferenceType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__preferenceType
	*a = SOAP_DEFAULT_ns4__preferenceType;
#else
	*a = (enum ns4__preferenceType)0;
#endif
}

static const struct soap_code_map soap_codes_ns4__preferenceType[] =
{	{ (long)ns4__preferenceType__MIN, "MIN" },
	{ (long)ns4__preferenceType__MAX, "MAX" },
	{ (long)ns4__preferenceType__LOWER_USCOREBND, "LOWER_BND" },
	{ (long)ns4__preferenceType__UPPER_USCOREBND, "UPPER_BND" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__preferenceType2s(struct soap *soap, enum ns4__preferenceType n)
{	const char *s = soap_code_str(soap_codes_ns4__preferenceType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__preferenceType(struct soap *soap, const char *tag, int id, const enum ns4__preferenceType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__preferenceType), type) || soap_send(soap, soap_ns4__preferenceType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__preferenceType(struct soap *soap, const char *s, enum ns4__preferenceType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__preferenceType, s);
	if (map)
		*a = (enum ns4__preferenceType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__preferenceType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__preferenceType * SOAP_FMAC4 soap_in_ns4__preferenceType(struct soap *soap, const char *tag, enum ns4__preferenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__preferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__preferenceType, sizeof(enum ns4__preferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__preferenceType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__preferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__preferenceType, 0, sizeof(enum ns4__preferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__preferenceType(struct soap *soap, const enum ns4__preferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__preferenceType);
	if (soap_out_ns4__preferenceType(soap, tag?tag:"ns4:preferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__preferenceType * SOAP_FMAC4 soap_get_ns4__preferenceType(struct soap *soap, enum ns4__preferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__preferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__mathType(struct soap *soap, enum ns2__mathType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__mathType
	*a = SOAP_DEFAULT_ns2__mathType;
#else
	*a = (enum ns2__mathType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__mathType[] =
{	{ (long)ns2__mathType__INTEGER, "INTEGER" },
	{ (long)ns2__mathType__REAL, "REAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__mathType2s(struct soap *soap, enum ns2__mathType n)
{	const char *s = soap_code_str(soap_codes_ns2__mathType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__mathType(struct soap *soap, const char *tag, int id, const enum ns2__mathType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__mathType), type) || soap_send(soap, soap_ns2__mathType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__mathType(struct soap *soap, const char *s, enum ns2__mathType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__mathType, s);
	if (map)
		*a = (enum ns2__mathType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__mathType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__mathType * SOAP_FMAC4 soap_in_ns2__mathType(struct soap *soap, const char *tag, enum ns2__mathType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__mathType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__mathType, sizeof(enum ns2__mathType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__mathType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__mathType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__mathType, 0, sizeof(enum ns2__mathType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__mathType(struct soap *soap, const enum ns2__mathType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__mathType);
	if (soap_out_ns2__mathType(soap, tag?tag:"ns2:mathType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__mathType * SOAP_FMAC4 soap_get_ns2__mathType(struct soap *soap, enum ns2__mathType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__mathType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__entityRole(struct soap *soap, enum ns2__entityRole *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__entityRole
	*a = SOAP_DEFAULT_ns2__entityRole;
#else
	*a = (enum ns2__entityRole)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__entityRole[] =
{	{ (long)ns2__entityRole__CONSTANT, "CONSTANT" },
	{ (long)ns2__entityRole__PARAMETER, "PARAMETER" },
	{ (long)ns2__entityRole__DECISION_USCOREVAR, "DECISION_VAR" },
	{ (long)ns2__entityRole__EXTERNAL_USCOREDECISION_USCOREVAR, "EXTERNAL_DECISION_VAR" },
	{ (long)ns2__entityRole__OUTCOME_USCOREVAR, "OUTCOME_VAR" },
	{ (long)ns2__entityRole__AUXILIARY_USCOREVAR, "AUXILIARY_VAR" },
	{ (long)ns2__entityRole__ASSIGNMENT, "ASSIGNMENT" },
	{ (long)ns2__entityRole__CONSTRAINT, "CONSTRAINT" },
	{ (long)ns2__entityRole__A_USCOREVARIABLE, "A_VARIABLE" },
	{ (long)ns2__entityRole__A_USCOREFORMULA, "A_FORMULA" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__entityRole2s(struct soap *soap, enum ns2__entityRole n)
{	const char *s = soap_code_str(soap_codes_ns2__entityRole, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__entityRole(struct soap *soap, const char *tag, int id, const enum ns2__entityRole *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__entityRole), type) || soap_send(soap, soap_ns2__entityRole2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__entityRole(struct soap *soap, const char *s, enum ns2__entityRole *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__entityRole, s);
	if (map)
		*a = (enum ns2__entityRole)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 9)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__entityRole)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__entityRole * SOAP_FMAC4 soap_in_ns2__entityRole(struct soap *soap, const char *tag, enum ns2__entityRole *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__entityRole *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__entityRole, sizeof(enum ns2__entityRole), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__entityRole(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__entityRole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__entityRole, 0, sizeof(enum ns2__entityRole), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__entityRole(struct soap *soap, const enum ns2__entityRole *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__entityRole);
	if (soap_out_ns2__entityRole(soap, tag?tag:"ns2:entityRole", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__entityRole * SOAP_FMAC4 soap_get_ns2__entityRole(struct soap *soap, enum ns2__entityRole *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__entityRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__setSpecType(struct soap *soap, enum ns2__setSpecType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__setSpecType
	*a = SOAP_DEFAULT_ns2__setSpecType;
#else
	*a = (enum ns2__setSpecType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__setSpecType[] =
{	{ (long)ns2__setSpecType__MAINSET, "MAINSET" },
	{ (long)ns2__setSpecType__SUBSET, "SUBSET" },
	{ (long)ns2__setSpecType__INDEXEDSUBSET, "INDEXEDSUBSET" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__setSpecType2s(struct soap *soap, enum ns2__setSpecType n)
{	const char *s = soap_code_str(soap_codes_ns2__setSpecType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__setSpecType(struct soap *soap, const char *tag, int id, const enum ns2__setSpecType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__setSpecType), type) || soap_send(soap, soap_ns2__setSpecType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__setSpecType(struct soap *soap, const char *s, enum ns2__setSpecType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__setSpecType, s);
	if (map)
		*a = (enum ns2__setSpecType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__setSpecType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__setSpecType * SOAP_FMAC4 soap_in_ns2__setSpecType(struct soap *soap, const char *tag, enum ns2__setSpecType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__setSpecType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__setSpecType, sizeof(enum ns2__setSpecType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__setSpecType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__setSpecType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__setSpecType, 0, sizeof(enum ns2__setSpecType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__setSpecType(struct soap *soap, const enum ns2__setSpecType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__setSpecType);
	if (soap_out_ns2__setSpecType(soap, tag?tag:"ns2:setSpecType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__setSpecType * SOAP_FMAC4 soap_get_ns2__setSpecType(struct soap *soap, enum ns2__setSpecType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__setSpecType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__status(struct soap *soap, enum ns2__status *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__status
	*a = SOAP_DEFAULT_ns2__status;
#else
	*a = (enum ns2__status)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__status[] =
{	{ (long)ns2__status__EDIT, "EDIT" },
	{ (long)ns2__status__TEST, "TEST" },
	{ (long)ns2__status__COMMITED, "COMMITED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__status2s(struct soap *soap, enum ns2__status n)
{	const char *s = soap_code_str(soap_codes_ns2__status, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__status(struct soap *soap, const char *tag, int id, const enum ns2__status *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__status), type) || soap_send(soap, soap_ns2__status2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__status(struct soap *soap, const char *s, enum ns2__status *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__status, s);
	if (map)
		*a = (enum ns2__status)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__status)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__status * SOAP_FMAC4 soap_in_ns2__status(struct soap *soap, const char *tag, enum ns2__status *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__status, sizeof(enum ns2__status), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__status(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__status, 0, sizeof(enum ns2__status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__status(struct soap *soap, const enum ns2__status *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__status);
	if (soap_out_ns2__status(soap, tag?tag:"ns2:status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__status * SOAP_FMAC4 soap_get_ns2__status(struct soap *soap, enum ns2__status *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__description(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__description), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__description(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__description, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, 1, 1000)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__description, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__description, 0, sizeof(std::string), 0, soap_copy_ns2__description);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__description(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__description);
	if (soap_out_ns2__description(soap, tag?tag:"ns2:description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__description(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__name(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__name), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__name(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__name, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, 1, 64)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__name, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__name, 0, sizeof(std::string), 0, soap_copy_ns2__name);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__name(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__name);
	if (soap_out_ns2__name(soap, tag?tag:"ns2:name", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__name(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__shortName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__shortName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns2__shortName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__shortName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, 1, 16)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__shortName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__shortName, 0, sizeof(std::string), 0, soap_copy_ns2__shortName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__shortName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__shortName);
	if (soap_out_ns2__shortName(soap, tag?tag:"ns2:shortName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns2__shortName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__shortName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, 0, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void _ns1__runScenarioResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__runScenarioResponse::result);
	/* transient soap skipped */
}

void _ns1__runScenarioResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__runScenarioResponse::result, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__runScenarioResponse::result);
	/* transient soap skipped */
}

int _ns1__runScenarioResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__runScenarioResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__runScenarioResponse(struct soap *soap, const char *tag, int id, const _ns1__runScenarioResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__runScenarioResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &(a->_ns1__runScenarioResponse::result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__runScenarioResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__runScenarioResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__runScenarioResponse * SOAP_FMAC4 soap_in__ns1__runScenarioResponse(struct soap *soap, const char *tag, _ns1__runScenarioResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__runScenarioResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__runScenarioResponse, sizeof(_ns1__runScenarioResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__runScenarioResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__runScenarioResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &(a->_ns1__runScenarioResponse::result), "xsd:string"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__runScenarioResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__runScenarioResponse, 0, sizeof(_ns1__runScenarioResponse), 0, soap_copy__ns1__runScenarioResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__runScenarioResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__runScenarioResponse);
	if (this->soap_out(soap, tag?tag:"ns1:runScenarioResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__runScenarioResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__runScenarioResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__runScenarioResponse * SOAP_FMAC4 soap_get__ns1__runScenarioResponse(struct soap *soap, _ns1__runScenarioResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__runScenarioResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__runScenarioResponse * SOAP_FMAC2 soap_instantiate__ns1__runScenarioResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__runScenarioResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__runScenarioResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__runScenarioResponse);
		if (size)
			*size = sizeof(_ns1__runScenarioResponse);
		((_ns1__runScenarioResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__runScenarioResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__runScenarioResponse);
		for (int i = 0; i < n; i++)
			((_ns1__runScenarioResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__runScenarioResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__runScenarioResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__runScenarioResponse %p -> %p\n", q, p));
	*(_ns1__runScenarioResponse*)p = *(_ns1__runScenarioResponse*)q;
}

void _ns1__runScenarioRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__runScenarioRequest::idAnalysis);
	/* transient soap skipped */
}

void _ns1__runScenarioRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__runScenarioRequest::idAnalysis, SOAP_TYPE_int);
	/* transient soap skipped */
}

int _ns1__runScenarioRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__runScenarioRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__runScenarioRequest(struct soap *soap, const char *tag, int id, const _ns1__runScenarioRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__runScenarioRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idAnalysis", -1, &(a->_ns1__runScenarioRequest::idAnalysis), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__runScenarioRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__runScenarioRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__runScenarioRequest * SOAP_FMAC4 soap_in__ns1__runScenarioRequest(struct soap *soap, const char *tag, _ns1__runScenarioRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__runScenarioRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__runScenarioRequest, sizeof(_ns1__runScenarioRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__runScenarioRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__runScenarioRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idAnalysis1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idAnalysis1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idAnalysis", &(a->_ns1__runScenarioRequest::idAnalysis), "xsd:int"))
				{	soap_flag_idAnalysis1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__runScenarioRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__runScenarioRequest, 0, sizeof(_ns1__runScenarioRequest), 0, soap_copy__ns1__runScenarioRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idAnalysis1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__runScenarioRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__runScenarioRequest);
	if (this->soap_out(soap, tag?tag:"ns1:runScenarioRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__runScenarioRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__runScenarioRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__runScenarioRequest * SOAP_FMAC4 soap_get__ns1__runScenarioRequest(struct soap *soap, _ns1__runScenarioRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__runScenarioRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__runScenarioRequest * SOAP_FMAC2 soap_instantiate__ns1__runScenarioRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__runScenarioRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__runScenarioRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__runScenarioRequest);
		if (size)
			*size = sizeof(_ns1__runScenarioRequest);
		((_ns1__runScenarioRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__runScenarioRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__runScenarioRequest);
		for (int i = 0; i < n; i++)
			((_ns1__runScenarioRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__runScenarioRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__runScenarioRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__runScenarioRequest %p -> %p\n", q, p));
	*(_ns1__runScenarioRequest*)p = *(_ns1__runScenarioRequest*)q;
}

void _ns1__runSolverResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__runSolverResponse::result);
	/* transient soap skipped */
}

void _ns1__runSolverResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__runSolverResponse::result, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__runSolverResponse::result);
	/* transient soap skipped */
}

int _ns1__runSolverResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__runSolverResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__runSolverResponse(struct soap *soap, const char *tag, int id, const _ns1__runSolverResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__runSolverResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &(a->_ns1__runSolverResponse::result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__runSolverResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__runSolverResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__runSolverResponse * SOAP_FMAC4 soap_in__ns1__runSolverResponse(struct soap *soap, const char *tag, _ns1__runSolverResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__runSolverResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__runSolverResponse, sizeof(_ns1__runSolverResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__runSolverResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__runSolverResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &(a->_ns1__runSolverResponse::result), "xsd:string"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__runSolverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__runSolverResponse, 0, sizeof(_ns1__runSolverResponse), 0, soap_copy__ns1__runSolverResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__runSolverResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__runSolverResponse);
	if (this->soap_out(soap, tag?tag:"ns1:runSolverResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__runSolverResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__runSolverResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__runSolverResponse * SOAP_FMAC4 soap_get__ns1__runSolverResponse(struct soap *soap, _ns1__runSolverResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__runSolverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__runSolverResponse * SOAP_FMAC2 soap_instantiate__ns1__runSolverResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__runSolverResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__runSolverResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__runSolverResponse);
		if (size)
			*size = sizeof(_ns1__runSolverResponse);
		((_ns1__runSolverResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__runSolverResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__runSolverResponse);
		for (int i = 0; i < n; i++)
			((_ns1__runSolverResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__runSolverResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__runSolverResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__runSolverResponse %p -> %p\n", q, p));
	*(_ns1__runSolverResponse*)p = *(_ns1__runSolverResponse*)q;
}

void _ns1__runSolverRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__runSolverRequest::idAnalysis);
	/* transient soap skipped */
}

void _ns1__runSolverRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__runSolverRequest::idAnalysis, SOAP_TYPE_int);
	/* transient soap skipped */
}

int _ns1__runSolverRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__runSolverRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__runSolverRequest(struct soap *soap, const char *tag, int id, const _ns1__runSolverRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__runSolverRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idAnalysis", -1, &(a->_ns1__runSolverRequest::idAnalysis), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__runSolverRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__runSolverRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__runSolverRequest * SOAP_FMAC4 soap_in__ns1__runSolverRequest(struct soap *soap, const char *tag, _ns1__runSolverRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__runSolverRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__runSolverRequest, sizeof(_ns1__runSolverRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__runSolverRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__runSolverRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idAnalysis1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idAnalysis1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idAnalysis", &(a->_ns1__runSolverRequest::idAnalysis), "xsd:int"))
				{	soap_flag_idAnalysis1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__runSolverRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__runSolverRequest, 0, sizeof(_ns1__runSolverRequest), 0, soap_copy__ns1__runSolverRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idAnalysis1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__runSolverRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__runSolverRequest);
	if (this->soap_out(soap, tag?tag:"ns1:runSolverRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__runSolverRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__runSolverRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__runSolverRequest * SOAP_FMAC4 soap_get__ns1__runSolverRequest(struct soap *soap, _ns1__runSolverRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__runSolverRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__runSolverRequest * SOAP_FMAC2 soap_instantiate__ns1__runSolverRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__runSolverRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__runSolverRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__runSolverRequest);
		if (size)
			*size = sizeof(_ns1__runSolverRequest);
		((_ns1__runSolverRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__runSolverRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__runSolverRequest);
		for (int i = 0; i < n; i++)
			((_ns1__runSolverRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__runSolverRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__runSolverRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__runSolverRequest %p -> %p\n", q, p));
	*(_ns1__runSolverRequest*)p = *(_ns1__runSolverRequest*)q;
}

void _ns1__getSolverStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__getSolverStatusResponse::result);
	/* transient soap skipped */
}

void _ns1__getSolverStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getSolverStatusResponse::result, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getSolverStatusResponse::result);
	/* transient soap skipped */
}

int _ns1__getSolverStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getSolverStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSolverStatusResponse(struct soap *soap, const char *tag, int id, const _ns1__getSolverStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSolverStatusResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &(a->_ns1__getSolverStatusResponse::result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getSolverStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getSolverStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getSolverStatusResponse * SOAP_FMAC4 soap_in__ns1__getSolverStatusResponse(struct soap *soap, const char *tag, _ns1__getSolverStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getSolverStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSolverStatusResponse, sizeof(_ns1__getSolverStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getSolverStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getSolverStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &(a->_ns1__getSolverStatusResponse::result), "xsd:string"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getSolverStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getSolverStatusResponse, 0, sizeof(_ns1__getSolverStatusResponse), 0, soap_copy__ns1__getSolverStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getSolverStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getSolverStatusResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getSolverStatusResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getSolverStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getSolverStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getSolverStatusResponse * SOAP_FMAC4 soap_get__ns1__getSolverStatusResponse(struct soap *soap, _ns1__getSolverStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSolverStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getSolverStatusResponse * SOAP_FMAC2 soap_instantiate__ns1__getSolverStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getSolverStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getSolverStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getSolverStatusResponse);
		if (size)
			*size = sizeof(_ns1__getSolverStatusResponse);
		((_ns1__getSolverStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getSolverStatusResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getSolverStatusResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getSolverStatusResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getSolverStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getSolverStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getSolverStatusResponse %p -> %p\n", q, p));
	*(_ns1__getSolverStatusResponse*)p = *(_ns1__getSolverStatusResponse*)q;
}

void _ns1__getSolverStatusRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__getSolverStatusRequest::idAnalysis);
	/* transient soap skipped */
}

void _ns1__getSolverStatusRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getSolverStatusRequest::idAnalysis, SOAP_TYPE_int);
	/* transient soap skipped */
}

int _ns1__getSolverStatusRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getSolverStatusRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSolverStatusRequest(struct soap *soap, const char *tag, int id, const _ns1__getSolverStatusRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSolverStatusRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idAnalysis", -1, &(a->_ns1__getSolverStatusRequest::idAnalysis), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getSolverStatusRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getSolverStatusRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getSolverStatusRequest * SOAP_FMAC4 soap_in__ns1__getSolverStatusRequest(struct soap *soap, const char *tag, _ns1__getSolverStatusRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getSolverStatusRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSolverStatusRequest, sizeof(_ns1__getSolverStatusRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getSolverStatusRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getSolverStatusRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idAnalysis1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idAnalysis1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idAnalysis", &(a->_ns1__getSolverStatusRequest::idAnalysis), "xsd:int"))
				{	soap_flag_idAnalysis1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getSolverStatusRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getSolverStatusRequest, 0, sizeof(_ns1__getSolverStatusRequest), 0, soap_copy__ns1__getSolverStatusRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idAnalysis1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getSolverStatusRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getSolverStatusRequest);
	if (this->soap_out(soap, tag?tag:"ns1:getSolverStatusRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getSolverStatusRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getSolverStatusRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getSolverStatusRequest * SOAP_FMAC4 soap_get__ns1__getSolverStatusRequest(struct soap *soap, _ns1__getSolverStatusRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSolverStatusRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getSolverStatusRequest * SOAP_FMAC2 soap_instantiate__ns1__getSolverStatusRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getSolverStatusRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getSolverStatusRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getSolverStatusRequest);
		if (size)
			*size = sizeof(_ns1__getSolverStatusRequest);
		((_ns1__getSolverStatusRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getSolverStatusRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getSolverStatusRequest);
		for (int i = 0; i < n; i++)
			((_ns1__getSolverStatusRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getSolverStatusRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getSolverStatusRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getSolverStatusRequest %p -> %p\n", q, p));
	*(_ns1__getSolverStatusRequest*)p = *(_ns1__getSolverStatusRequest*)q;
}

void _ns1__updateSolverStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__updateSolverStatusResponse::result);
	/* transient soap skipped */
}

void _ns1__updateSolverStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__updateSolverStatusResponse::result, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__updateSolverStatusResponse::result);
	/* transient soap skipped */
}

int _ns1__updateSolverStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__updateSolverStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateSolverStatusResponse(struct soap *soap, const char *tag, int id, const _ns1__updateSolverStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateSolverStatusResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &(a->_ns1__updateSolverStatusResponse::result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__updateSolverStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__updateSolverStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__updateSolverStatusResponse * SOAP_FMAC4 soap_in__ns1__updateSolverStatusResponse(struct soap *soap, const char *tag, _ns1__updateSolverStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__updateSolverStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateSolverStatusResponse, sizeof(_ns1__updateSolverStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__updateSolverStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__updateSolverStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &(a->_ns1__updateSolverStatusResponse::result), "xsd:string"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__updateSolverStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateSolverStatusResponse, 0, sizeof(_ns1__updateSolverStatusResponse), 0, soap_copy__ns1__updateSolverStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__updateSolverStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__updateSolverStatusResponse);
	if (this->soap_out(soap, tag?tag:"ns1:updateSolverStatusResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__updateSolverStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__updateSolverStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__updateSolverStatusResponse * SOAP_FMAC4 soap_get__ns1__updateSolverStatusResponse(struct soap *soap, _ns1__updateSolverStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateSolverStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__updateSolverStatusResponse * SOAP_FMAC2 soap_instantiate__ns1__updateSolverStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__updateSolverStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__updateSolverStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__updateSolverStatusResponse);
		if (size)
			*size = sizeof(_ns1__updateSolverStatusResponse);
		((_ns1__updateSolverStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__updateSolverStatusResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__updateSolverStatusResponse);
		for (int i = 0; i < n; i++)
			((_ns1__updateSolverStatusResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__updateSolverStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__updateSolverStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__updateSolverStatusResponse %p -> %p\n", q, p));
	*(_ns1__updateSolverStatusResponse*)p = *(_ns1__updateSolverStatusResponse*)q;
}

void _ns1__updateSolverStatusRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__updateSolverStatusRequest::idAnalysis);
	soap_default_std__string(soap, &this->_ns1__updateSolverStatusRequest::status);
	/* transient soap skipped */
}

void _ns1__updateSolverStatusRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__updateSolverStatusRequest::idAnalysis, SOAP_TYPE_int);
	soap_embedded(soap, &this->_ns1__updateSolverStatusRequest::status, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__updateSolverStatusRequest::status);
	/* transient soap skipped */
}

int _ns1__updateSolverStatusRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__updateSolverStatusRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateSolverStatusRequest(struct soap *soap, const char *tag, int id, const _ns1__updateSolverStatusRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateSolverStatusRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idAnalysis", -1, &(a->_ns1__updateSolverStatusRequest::idAnalysis), ""))
		return soap->error;
	if (soap_out_std__string(soap, "status", -1, &(a->_ns1__updateSolverStatusRequest::status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__updateSolverStatusRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__updateSolverStatusRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__updateSolverStatusRequest * SOAP_FMAC4 soap_in__ns1__updateSolverStatusRequest(struct soap *soap, const char *tag, _ns1__updateSolverStatusRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__updateSolverStatusRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateSolverStatusRequest, sizeof(_ns1__updateSolverStatusRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__updateSolverStatusRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__updateSolverStatusRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idAnalysis1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idAnalysis1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idAnalysis", &(a->_ns1__updateSolverStatusRequest::idAnalysis), "xsd:int"))
				{	soap_flag_idAnalysis1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "status", &(a->_ns1__updateSolverStatusRequest::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__updateSolverStatusRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateSolverStatusRequest, 0, sizeof(_ns1__updateSolverStatusRequest), 0, soap_copy__ns1__updateSolverStatusRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idAnalysis1 > 0 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__updateSolverStatusRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__updateSolverStatusRequest);
	if (this->soap_out(soap, tag?tag:"ns1:updateSolverStatusRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__updateSolverStatusRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__updateSolverStatusRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__updateSolverStatusRequest * SOAP_FMAC4 soap_get__ns1__updateSolverStatusRequest(struct soap *soap, _ns1__updateSolverStatusRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateSolverStatusRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__updateSolverStatusRequest * SOAP_FMAC2 soap_instantiate__ns1__updateSolverStatusRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__updateSolverStatusRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__updateSolverStatusRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__updateSolverStatusRequest);
		if (size)
			*size = sizeof(_ns1__updateSolverStatusRequest);
		((_ns1__updateSolverStatusRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__updateSolverStatusRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__updateSolverStatusRequest);
		for (int i = 0; i < n; i++)
			((_ns1__updateSolverStatusRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__updateSolverStatusRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__updateSolverStatusRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__updateSolverStatusRequest %p -> %p\n", q, p));
	*(_ns1__updateSolverStatusRequest*)p = *(_ns1__updateSolverStatusRequest*)q;
}

void _ns1__getSolutionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__getSolutionResponse::idAnalysis);
	soap_default_std__vectorTemplateOfPointerTons3__entityValues(soap, &this->_ns1__getSolutionResponse::entityValues);
	/* transient soap skipped */
}

void _ns1__getSolutionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getSolutionResponse::idAnalysis, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfPointerTons3__entityValues(soap, &this->_ns1__getSolutionResponse::entityValues);
	/* transient soap skipped */
}

int _ns1__getSolutionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getSolutionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSolutionResponse(struct soap *soap, const char *tag, int id, const _ns1__getSolutionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSolutionResponse), type))
		return soap->error;
	if (soap_out_int(soap, "idAnalysis", -1, &(a->_ns1__getSolutionResponse::idAnalysis), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__entityValues(soap, "entityValues", -1, &(a->_ns1__getSolutionResponse::entityValues), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getSolutionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getSolutionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getSolutionResponse * SOAP_FMAC4 soap_in__ns1__getSolutionResponse(struct soap *soap, const char *tag, _ns1__getSolutionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getSolutionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSolutionResponse, sizeof(_ns1__getSolutionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getSolutionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getSolutionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idAnalysis1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idAnalysis1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idAnalysis", &(a->_ns1__getSolutionResponse::idAnalysis), "xsd:int"))
				{	soap_flag_idAnalysis1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__entityValues(soap, "entityValues", &(a->_ns1__getSolutionResponse::entityValues), "ns3:entityValues"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getSolutionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getSolutionResponse, 0, sizeof(_ns1__getSolutionResponse), 0, soap_copy__ns1__getSolutionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idAnalysis1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getSolutionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getSolutionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getSolutionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getSolutionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getSolutionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getSolutionResponse * SOAP_FMAC4 soap_get__ns1__getSolutionResponse(struct soap *soap, _ns1__getSolutionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSolutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getSolutionResponse * SOAP_FMAC2 soap_instantiate__ns1__getSolutionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getSolutionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getSolutionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getSolutionResponse);
		if (size)
			*size = sizeof(_ns1__getSolutionResponse);
		((_ns1__getSolutionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getSolutionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getSolutionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getSolutionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getSolutionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getSolutionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getSolutionResponse %p -> %p\n", q, p));
	*(_ns1__getSolutionResponse*)p = *(_ns1__getSolutionResponse*)q;
}

void _ns1__getSolutionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__getSolutionRequest::idAnalysis);
	/* transient soap skipped */
}

void _ns1__getSolutionRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getSolutionRequest::idAnalysis, SOAP_TYPE_int);
	/* transient soap skipped */
}

int _ns1__getSolutionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getSolutionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSolutionRequest(struct soap *soap, const char *tag, int id, const _ns1__getSolutionRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSolutionRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idAnalysis", -1, &(a->_ns1__getSolutionRequest::idAnalysis), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getSolutionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getSolutionRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getSolutionRequest * SOAP_FMAC4 soap_in__ns1__getSolutionRequest(struct soap *soap, const char *tag, _ns1__getSolutionRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getSolutionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSolutionRequest, sizeof(_ns1__getSolutionRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getSolutionRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getSolutionRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idAnalysis1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idAnalysis1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idAnalysis", &(a->_ns1__getSolutionRequest::idAnalysis), "xsd:int"))
				{	soap_flag_idAnalysis1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getSolutionRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getSolutionRequest, 0, sizeof(_ns1__getSolutionRequest), 0, soap_copy__ns1__getSolutionRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idAnalysis1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getSolutionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getSolutionRequest);
	if (this->soap_out(soap, tag?tag:"ns1:getSolutionRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getSolutionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getSolutionRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getSolutionRequest * SOAP_FMAC4 soap_get__ns1__getSolutionRequest(struct soap *soap, _ns1__getSolutionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSolutionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getSolutionRequest * SOAP_FMAC2 soap_instantiate__ns1__getSolutionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getSolutionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getSolutionRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getSolutionRequest);
		if (size)
			*size = sizeof(_ns1__getSolutionRequest);
		((_ns1__getSolutionRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getSolutionRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getSolutionRequest);
		for (int i = 0; i < n; i++)
			((_ns1__getSolutionRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getSolutionRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getSolutionRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getSolutionRequest %p -> %p\n", q, p));
	*(_ns1__getSolutionRequest*)p = *(_ns1__getSolutionRequest*)q;
}

void _ns1__storeSolutionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__storeSolutionResponse::result);
	/* transient soap skipped */
}

void _ns1__storeSolutionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__storeSolutionResponse::result, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__storeSolutionResponse::result);
	/* transient soap skipped */
}

int _ns1__storeSolutionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__storeSolutionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__storeSolutionResponse(struct soap *soap, const char *tag, int id, const _ns1__storeSolutionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__storeSolutionResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &(a->_ns1__storeSolutionResponse::result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__storeSolutionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__storeSolutionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__storeSolutionResponse * SOAP_FMAC4 soap_in__ns1__storeSolutionResponse(struct soap *soap, const char *tag, _ns1__storeSolutionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__storeSolutionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__storeSolutionResponse, sizeof(_ns1__storeSolutionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__storeSolutionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__storeSolutionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &(a->_ns1__storeSolutionResponse::result), "xsd:string"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__storeSolutionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__storeSolutionResponse, 0, sizeof(_ns1__storeSolutionResponse), 0, soap_copy__ns1__storeSolutionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__storeSolutionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__storeSolutionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:storeSolutionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__storeSolutionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__storeSolutionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__storeSolutionResponse * SOAP_FMAC4 soap_get__ns1__storeSolutionResponse(struct soap *soap, _ns1__storeSolutionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__storeSolutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__storeSolutionResponse * SOAP_FMAC2 soap_instantiate__ns1__storeSolutionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__storeSolutionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__storeSolutionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__storeSolutionResponse);
		if (size)
			*size = sizeof(_ns1__storeSolutionResponse);
		((_ns1__storeSolutionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__storeSolutionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__storeSolutionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__storeSolutionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__storeSolutionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__storeSolutionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__storeSolutionResponse %p -> %p\n", q, p));
	*(_ns1__storeSolutionResponse*)p = *(_ns1__storeSolutionResponse*)q;
}

void _ns1__storeSolutionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__storeSolutionRequest::idAnalysis);
	soap_default_std__vectorTemplateOfPointerTons3__entityValues(soap, &this->_ns1__storeSolutionRequest::entityValues);
	/* transient soap skipped */
}

void _ns1__storeSolutionRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__storeSolutionRequest::idAnalysis, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfPointerTons3__entityValues(soap, &this->_ns1__storeSolutionRequest::entityValues);
	/* transient soap skipped */
}

int _ns1__storeSolutionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__storeSolutionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__storeSolutionRequest(struct soap *soap, const char *tag, int id, const _ns1__storeSolutionRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__storeSolutionRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idAnalysis", -1, &(a->_ns1__storeSolutionRequest::idAnalysis), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__entityValues(soap, "entityValues", -1, &(a->_ns1__storeSolutionRequest::entityValues), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__storeSolutionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__storeSolutionRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__storeSolutionRequest * SOAP_FMAC4 soap_in__ns1__storeSolutionRequest(struct soap *soap, const char *tag, _ns1__storeSolutionRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__storeSolutionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__storeSolutionRequest, sizeof(_ns1__storeSolutionRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__storeSolutionRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__storeSolutionRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idAnalysis1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idAnalysis1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idAnalysis", &(a->_ns1__storeSolutionRequest::idAnalysis), "xsd:int"))
				{	soap_flag_idAnalysis1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__entityValues(soap, "entityValues", &(a->_ns1__storeSolutionRequest::entityValues), "ns3:entityValues"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__storeSolutionRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__storeSolutionRequest, 0, sizeof(_ns1__storeSolutionRequest), 0, soap_copy__ns1__storeSolutionRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idAnalysis1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__storeSolutionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__storeSolutionRequest);
	if (this->soap_out(soap, tag?tag:"ns1:storeSolutionRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__storeSolutionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__storeSolutionRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__storeSolutionRequest * SOAP_FMAC4 soap_get__ns1__storeSolutionRequest(struct soap *soap, _ns1__storeSolutionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__storeSolutionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__storeSolutionRequest * SOAP_FMAC2 soap_instantiate__ns1__storeSolutionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__storeSolutionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__storeSolutionRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__storeSolutionRequest);
		if (size)
			*size = sizeof(_ns1__storeSolutionRequest);
		((_ns1__storeSolutionRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__storeSolutionRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__storeSolutionRequest);
		for (int i = 0; i < n; i++)
			((_ns1__storeSolutionRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__storeSolutionRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__storeSolutionRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__storeSolutionRequest %p -> %p\n", q, p));
	*(_ns1__storeSolutionRequest*)p = *(_ns1__storeSolutionRequest*)q;
}

void _ns1__getPreferenceResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__getPreferenceResponse::idModelSpec);
	soap_default_int(soap, &this->_ns1__getPreferenceResponse::idModelData);
	soap_default_int(soap, &this->_ns1__getPreferenceResponse::idAnalysis);
	soap_default_std__vectorTemplateOfPointerTons4__preference(soap, &this->_ns1__getPreferenceResponse::preference);
	/* transient soap skipped */
}

void _ns1__getPreferenceResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getPreferenceResponse::idModelSpec, SOAP_TYPE_int);
	soap_embedded(soap, &this->_ns1__getPreferenceResponse::idModelData, SOAP_TYPE_int);
	soap_embedded(soap, &this->_ns1__getPreferenceResponse::idAnalysis, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfPointerTons4__preference(soap, &this->_ns1__getPreferenceResponse::preference);
	/* transient soap skipped */
}

int _ns1__getPreferenceResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getPreferenceResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPreferenceResponse(struct soap *soap, const char *tag, int id, const _ns1__getPreferenceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPreferenceResponse), type))
		return soap->error;
	if (soap_out_int(soap, "idModelSpec", -1, &(a->_ns1__getPreferenceResponse::idModelSpec), ""))
		return soap->error;
	if (soap_out_int(soap, "idModelData", -1, &(a->_ns1__getPreferenceResponse::idModelData), ""))
		return soap->error;
	if (soap_out_int(soap, "idAnalysis", -1, &(a->_ns1__getPreferenceResponse::idAnalysis), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__preference(soap, "preference", -1, &(a->_ns1__getPreferenceResponse::preference), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getPreferenceResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getPreferenceResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getPreferenceResponse * SOAP_FMAC4 soap_in__ns1__getPreferenceResponse(struct soap *soap, const char *tag, _ns1__getPreferenceResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getPreferenceResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPreferenceResponse, sizeof(_ns1__getPreferenceResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getPreferenceResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getPreferenceResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idModelSpec1 = 1;
	size_t soap_flag_idModelData1 = 1;
	size_t soap_flag_idAnalysis1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idModelSpec1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModelSpec", &(a->_ns1__getPreferenceResponse::idModelSpec), "xsd:int"))
				{	soap_flag_idModelSpec1--;
					continue;
				}
			if (soap_flag_idModelData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModelData", &(a->_ns1__getPreferenceResponse::idModelData), "xsd:int"))
				{	soap_flag_idModelData1--;
					continue;
				}
			if (soap_flag_idAnalysis1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idAnalysis", &(a->_ns1__getPreferenceResponse::idAnalysis), "xsd:int"))
				{	soap_flag_idAnalysis1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__preference(soap, "preference", &(a->_ns1__getPreferenceResponse::preference), "ns4:preference"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getPreferenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPreferenceResponse, 0, sizeof(_ns1__getPreferenceResponse), 0, soap_copy__ns1__getPreferenceResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idModelSpec1 > 0 || soap_flag_idModelData1 > 0 || soap_flag_idAnalysis1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getPreferenceResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getPreferenceResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getPreferenceResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getPreferenceResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getPreferenceResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getPreferenceResponse * SOAP_FMAC4 soap_get__ns1__getPreferenceResponse(struct soap *soap, _ns1__getPreferenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPreferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getPreferenceResponse * SOAP_FMAC2 soap_instantiate__ns1__getPreferenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getPreferenceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getPreferenceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getPreferenceResponse);
		if (size)
			*size = sizeof(_ns1__getPreferenceResponse);
		((_ns1__getPreferenceResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getPreferenceResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getPreferenceResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getPreferenceResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getPreferenceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getPreferenceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getPreferenceResponse %p -> %p\n", q, p));
	*(_ns1__getPreferenceResponse*)p = *(_ns1__getPreferenceResponse*)q;
}

void _ns1__getPreferenceRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__getPreferenceRequest::idAnalysis);
	/* transient soap skipped */
}

void _ns1__getPreferenceRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getPreferenceRequest::idAnalysis, SOAP_TYPE_int);
	/* transient soap skipped */
}

int _ns1__getPreferenceRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getPreferenceRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPreferenceRequest(struct soap *soap, const char *tag, int id, const _ns1__getPreferenceRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPreferenceRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idAnalysis", -1, &(a->_ns1__getPreferenceRequest::idAnalysis), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getPreferenceRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getPreferenceRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getPreferenceRequest * SOAP_FMAC4 soap_in__ns1__getPreferenceRequest(struct soap *soap, const char *tag, _ns1__getPreferenceRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getPreferenceRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPreferenceRequest, sizeof(_ns1__getPreferenceRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getPreferenceRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getPreferenceRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idAnalysis1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idAnalysis1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idAnalysis", &(a->_ns1__getPreferenceRequest::idAnalysis), "xsd:int"))
				{	soap_flag_idAnalysis1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getPreferenceRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPreferenceRequest, 0, sizeof(_ns1__getPreferenceRequest), 0, soap_copy__ns1__getPreferenceRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idAnalysis1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getPreferenceRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getPreferenceRequest);
	if (this->soap_out(soap, tag?tag:"ns1:getPreferenceRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getPreferenceRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getPreferenceRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getPreferenceRequest * SOAP_FMAC4 soap_get__ns1__getPreferenceRequest(struct soap *soap, _ns1__getPreferenceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPreferenceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getPreferenceRequest * SOAP_FMAC2 soap_instantiate__ns1__getPreferenceRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getPreferenceRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getPreferenceRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getPreferenceRequest);
		if (size)
			*size = sizeof(_ns1__getPreferenceRequest);
		((_ns1__getPreferenceRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getPreferenceRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getPreferenceRequest);
		for (int i = 0; i < n; i++)
			((_ns1__getPreferenceRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getPreferenceRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getPreferenceRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getPreferenceRequest %p -> %p\n", q, p));
	*(_ns1__getPreferenceRequest*)p = *(_ns1__getPreferenceRequest*)q;
}

void _ns1__definePreferenceResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__definePreferenceResponse::result);
	/* transient soap skipped */
}

void _ns1__definePreferenceResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__definePreferenceResponse::result, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__definePreferenceResponse::result);
	/* transient soap skipped */
}

int _ns1__definePreferenceResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__definePreferenceResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__definePreferenceResponse(struct soap *soap, const char *tag, int id, const _ns1__definePreferenceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__definePreferenceResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &(a->_ns1__definePreferenceResponse::result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__definePreferenceResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__definePreferenceResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__definePreferenceResponse * SOAP_FMAC4 soap_in__ns1__definePreferenceResponse(struct soap *soap, const char *tag, _ns1__definePreferenceResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__definePreferenceResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__definePreferenceResponse, sizeof(_ns1__definePreferenceResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__definePreferenceResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__definePreferenceResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &(a->_ns1__definePreferenceResponse::result), "xsd:string"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__definePreferenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__definePreferenceResponse, 0, sizeof(_ns1__definePreferenceResponse), 0, soap_copy__ns1__definePreferenceResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__definePreferenceResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__definePreferenceResponse);
	if (this->soap_out(soap, tag?tag:"ns1:definePreferenceResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__definePreferenceResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__definePreferenceResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__definePreferenceResponse * SOAP_FMAC4 soap_get__ns1__definePreferenceResponse(struct soap *soap, _ns1__definePreferenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__definePreferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__definePreferenceResponse * SOAP_FMAC2 soap_instantiate__ns1__definePreferenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__definePreferenceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__definePreferenceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__definePreferenceResponse);
		if (size)
			*size = sizeof(_ns1__definePreferenceResponse);
		((_ns1__definePreferenceResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__definePreferenceResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__definePreferenceResponse);
		for (int i = 0; i < n; i++)
			((_ns1__definePreferenceResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__definePreferenceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__definePreferenceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__definePreferenceResponse %p -> %p\n", q, p));
	*(_ns1__definePreferenceResponse*)p = *(_ns1__definePreferenceResponse*)q;
}

void _ns1__definePreferenceRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__definePreferenceRequest::idAnalysis);
	soap_default_std__vectorTemplateOfPointerTons4__preference(soap, &this->_ns1__definePreferenceRequest::preference);
	/* transient soap skipped */
}

void _ns1__definePreferenceRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__definePreferenceRequest::idAnalysis, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfPointerTons4__preference(soap, &this->_ns1__definePreferenceRequest::preference);
	/* transient soap skipped */
}

int _ns1__definePreferenceRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__definePreferenceRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__definePreferenceRequest(struct soap *soap, const char *tag, int id, const _ns1__definePreferenceRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__definePreferenceRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idAnalysis", -1, &(a->_ns1__definePreferenceRequest::idAnalysis), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__preference(soap, "preference", -1, &(a->_ns1__definePreferenceRequest::preference), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__definePreferenceRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__definePreferenceRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__definePreferenceRequest * SOAP_FMAC4 soap_in__ns1__definePreferenceRequest(struct soap *soap, const char *tag, _ns1__definePreferenceRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__definePreferenceRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__definePreferenceRequest, sizeof(_ns1__definePreferenceRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__definePreferenceRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__definePreferenceRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idAnalysis1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idAnalysis1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idAnalysis", &(a->_ns1__definePreferenceRequest::idAnalysis), "xsd:int"))
				{	soap_flag_idAnalysis1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__preference(soap, "preference", &(a->_ns1__definePreferenceRequest::preference), "ns4:preference"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__definePreferenceRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__definePreferenceRequest, 0, sizeof(_ns1__definePreferenceRequest), 0, soap_copy__ns1__definePreferenceRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idAnalysis1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__definePreferenceRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__definePreferenceRequest);
	if (this->soap_out(soap, tag?tag:"ns1:definePreferenceRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__definePreferenceRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__definePreferenceRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__definePreferenceRequest * SOAP_FMAC4 soap_get__ns1__definePreferenceRequest(struct soap *soap, _ns1__definePreferenceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__definePreferenceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__definePreferenceRequest * SOAP_FMAC2 soap_instantiate__ns1__definePreferenceRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__definePreferenceRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__definePreferenceRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__definePreferenceRequest);
		if (size)
			*size = sizeof(_ns1__definePreferenceRequest);
		((_ns1__definePreferenceRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__definePreferenceRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__definePreferenceRequest);
		for (int i = 0; i < n; i++)
			((_ns1__definePreferenceRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__definePreferenceRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__definePreferenceRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__definePreferenceRequest %p -> %p\n", q, p));
	*(_ns1__definePreferenceRequest*)p = *(_ns1__definePreferenceRequest*)q;
}

void _ns1__getAnalysesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons4__analysis(soap, &this->_ns1__getAnalysesResponse::analysis);
	/* transient soap skipped */
}

void _ns1__getAnalysesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons4__analysis(soap, &this->_ns1__getAnalysesResponse::analysis);
	/* transient soap skipped */
}

int _ns1__getAnalysesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getAnalysesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAnalysesResponse(struct soap *soap, const char *tag, int id, const _ns1__getAnalysesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAnalysesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons4__analysis(soap, "analysis", -1, &(a->_ns1__getAnalysesResponse::analysis), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getAnalysesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getAnalysesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getAnalysesResponse * SOAP_FMAC4 soap_in__ns1__getAnalysesResponse(struct soap *soap, const char *tag, _ns1__getAnalysesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getAnalysesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAnalysesResponse, sizeof(_ns1__getAnalysesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getAnalysesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getAnalysesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons4__analysis(soap, "analysis", &(a->_ns1__getAnalysesResponse::analysis), "ns4:analysis"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getAnalysesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAnalysesResponse, 0, sizeof(_ns1__getAnalysesResponse), 0, soap_copy__ns1__getAnalysesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__getAnalysesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getAnalysesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getAnalysesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getAnalysesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getAnalysesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getAnalysesResponse * SOAP_FMAC4 soap_get__ns1__getAnalysesResponse(struct soap *soap, _ns1__getAnalysesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAnalysesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getAnalysesResponse * SOAP_FMAC2 soap_instantiate__ns1__getAnalysesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getAnalysesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getAnalysesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAnalysesResponse);
		if (size)
			*size = sizeof(_ns1__getAnalysesResponse);
		((_ns1__getAnalysesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAnalysesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getAnalysesResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getAnalysesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getAnalysesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getAnalysesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getAnalysesResponse %p -> %p\n", q, p));
	*(_ns1__getAnalysesResponse*)p = *(_ns1__getAnalysesResponse*)q;
}

void _ns1__getAnalysesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__getAnalysesRequest::idModelInstance);
	/* transient soap skipped */
}

void _ns1__getAnalysesRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getAnalysesRequest::idModelInstance, SOAP_TYPE_int);
	/* transient soap skipped */
}

int _ns1__getAnalysesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getAnalysesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAnalysesRequest(struct soap *soap, const char *tag, int id, const _ns1__getAnalysesRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAnalysesRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idModelInstance", -1, &(a->_ns1__getAnalysesRequest::idModelInstance), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getAnalysesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getAnalysesRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getAnalysesRequest * SOAP_FMAC4 soap_in__ns1__getAnalysesRequest(struct soap *soap, const char *tag, _ns1__getAnalysesRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getAnalysesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAnalysesRequest, sizeof(_ns1__getAnalysesRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getAnalysesRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getAnalysesRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idModelInstance1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idModelInstance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModelInstance", &(a->_ns1__getAnalysesRequest::idModelInstance), "xsd:int"))
				{	soap_flag_idModelInstance1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getAnalysesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAnalysesRequest, 0, sizeof(_ns1__getAnalysesRequest), 0, soap_copy__ns1__getAnalysesRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idModelInstance1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getAnalysesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getAnalysesRequest);
	if (this->soap_out(soap, tag?tag:"ns1:getAnalysesRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getAnalysesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getAnalysesRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getAnalysesRequest * SOAP_FMAC4 soap_get__ns1__getAnalysesRequest(struct soap *soap, _ns1__getAnalysesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAnalysesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getAnalysesRequest * SOAP_FMAC2 soap_instantiate__ns1__getAnalysesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getAnalysesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getAnalysesRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAnalysesRequest);
		if (size)
			*size = sizeof(_ns1__getAnalysesRequest);
		((_ns1__getAnalysesRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getAnalysesRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getAnalysesRequest);
		for (int i = 0; i < n; i++)
			((_ns1__getAnalysesRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getAnalysesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getAnalysesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getAnalysesRequest %p -> %p\n", q, p));
	*(_ns1__getAnalysesRequest*)p = *(_ns1__getAnalysesRequest*)q;
}

void _ns1__defineAnalysisResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__defineAnalysisResponse::analysis = NULL;
	/* transient soap skipped */
}

void _ns1__defineAnalysisResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__analysis(soap, &this->_ns1__defineAnalysisResponse::analysis);
	/* transient soap skipped */
}

int _ns1__defineAnalysisResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__defineAnalysisResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__defineAnalysisResponse(struct soap *soap, const char *tag, int id, const _ns1__defineAnalysisResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__defineAnalysisResponse), type))
		return soap->error;
	if (a->_ns1__defineAnalysisResponse::analysis)
	{	if (soap_out_PointerTons4__analysis(soap, "analysis", -1, &a->_ns1__defineAnalysisResponse::analysis, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "analysis"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__defineAnalysisResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__defineAnalysisResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__defineAnalysisResponse * SOAP_FMAC4 soap_in__ns1__defineAnalysisResponse(struct soap *soap, const char *tag, _ns1__defineAnalysisResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__defineAnalysisResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__defineAnalysisResponse, sizeof(_ns1__defineAnalysisResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__defineAnalysisResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__defineAnalysisResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_analysis1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_analysis1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__analysis(soap, "analysis", &(a->_ns1__defineAnalysisResponse::analysis), "ns4:analysis"))
				{	soap_flag_analysis1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__defineAnalysisResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__defineAnalysisResponse, 0, sizeof(_ns1__defineAnalysisResponse), 0, soap_copy__ns1__defineAnalysisResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_analysis1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__defineAnalysisResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__defineAnalysisResponse);
	if (this->soap_out(soap, tag?tag:"ns1:defineAnalysisResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__defineAnalysisResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__defineAnalysisResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__defineAnalysisResponse * SOAP_FMAC4 soap_get__ns1__defineAnalysisResponse(struct soap *soap, _ns1__defineAnalysisResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__defineAnalysisResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__defineAnalysisResponse * SOAP_FMAC2 soap_instantiate__ns1__defineAnalysisResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__defineAnalysisResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__defineAnalysisResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__defineAnalysisResponse);
		if (size)
			*size = sizeof(_ns1__defineAnalysisResponse);
		((_ns1__defineAnalysisResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__defineAnalysisResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__defineAnalysisResponse);
		for (int i = 0; i < n; i++)
			((_ns1__defineAnalysisResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__defineAnalysisResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__defineAnalysisResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__defineAnalysisResponse %p -> %p\n", q, p));
	*(_ns1__defineAnalysisResponse*)p = *(_ns1__defineAnalysisResponse*)q;
}

void _ns1__defineAnalysisRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__defineAnalysisRequest::analysis = NULL;
	/* transient soap skipped */
}

void _ns1__defineAnalysisRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__analysis(soap, &this->_ns1__defineAnalysisRequest::analysis);
	/* transient soap skipped */
}

int _ns1__defineAnalysisRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__defineAnalysisRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__defineAnalysisRequest(struct soap *soap, const char *tag, int id, const _ns1__defineAnalysisRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__defineAnalysisRequest), type))
		return soap->error;
	if (a->_ns1__defineAnalysisRequest::analysis)
	{	if (soap_out_PointerTons4__analysis(soap, "analysis", -1, &a->_ns1__defineAnalysisRequest::analysis, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "analysis"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__defineAnalysisRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__defineAnalysisRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__defineAnalysisRequest * SOAP_FMAC4 soap_in__ns1__defineAnalysisRequest(struct soap *soap, const char *tag, _ns1__defineAnalysisRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__defineAnalysisRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__defineAnalysisRequest, sizeof(_ns1__defineAnalysisRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__defineAnalysisRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__defineAnalysisRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_analysis1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_analysis1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__analysis(soap, "analysis", &(a->_ns1__defineAnalysisRequest::analysis), "ns4:analysis"))
				{	soap_flag_analysis1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__defineAnalysisRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__defineAnalysisRequest, 0, sizeof(_ns1__defineAnalysisRequest), 0, soap_copy__ns1__defineAnalysisRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_analysis1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__defineAnalysisRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__defineAnalysisRequest);
	if (this->soap_out(soap, tag?tag:"ns1:defineAnalysisRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__defineAnalysisRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__defineAnalysisRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__defineAnalysisRequest * SOAP_FMAC4 soap_get__ns1__defineAnalysisRequest(struct soap *soap, _ns1__defineAnalysisRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__defineAnalysisRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__defineAnalysisRequest * SOAP_FMAC2 soap_instantiate__ns1__defineAnalysisRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__defineAnalysisRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__defineAnalysisRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__defineAnalysisRequest);
		if (size)
			*size = sizeof(_ns1__defineAnalysisRequest);
		((_ns1__defineAnalysisRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__defineAnalysisRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__defineAnalysisRequest);
		for (int i = 0; i < n; i++)
			((_ns1__defineAnalysisRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__defineAnalysisRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__defineAnalysisRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__defineAnalysisRequest %p -> %p\n", q, p));
	*(_ns1__defineAnalysisRequest*)p = *(_ns1__defineAnalysisRequest*)q;
}

void _ns1__getDataSummaryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getDataSummaryResponse::modelData = NULL;
	soap_default_std__vectorTemplateOfPointerTons3__modelInstance(soap, &this->_ns1__getDataSummaryResponse::modelInstance);
	/* transient soap skipped */
}

void _ns1__getDataSummaryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__modelData(soap, &this->_ns1__getDataSummaryResponse::modelData);
	soap_serialize_std__vectorTemplateOfPointerTons3__modelInstance(soap, &this->_ns1__getDataSummaryResponse::modelInstance);
	/* transient soap skipped */
}

int _ns1__getDataSummaryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getDataSummaryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDataSummaryResponse(struct soap *soap, const char *tag, int id, const _ns1__getDataSummaryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDataSummaryResponse), type))
		return soap->error;
	if (a->_ns1__getDataSummaryResponse::modelData)
	{	if (soap_out_PointerTons3__modelData(soap, "modelData", -1, &a->_ns1__getDataSummaryResponse::modelData, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "modelData"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__modelInstance(soap, "modelInstance", -1, &(a->_ns1__getDataSummaryResponse::modelInstance), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getDataSummaryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getDataSummaryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getDataSummaryResponse * SOAP_FMAC4 soap_in__ns1__getDataSummaryResponse(struct soap *soap, const char *tag, _ns1__getDataSummaryResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getDataSummaryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDataSummaryResponse, sizeof(_ns1__getDataSummaryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getDataSummaryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getDataSummaryResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_modelData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_modelData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__modelData(soap, "modelData", &(a->_ns1__getDataSummaryResponse::modelData), "ns3:modelData"))
				{	soap_flag_modelData1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__modelInstance(soap, "modelInstance", &(a->_ns1__getDataSummaryResponse::modelInstance), "ns3:modelInstance"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getDataSummaryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDataSummaryResponse, 0, sizeof(_ns1__getDataSummaryResponse), 0, soap_copy__ns1__getDataSummaryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_modelData1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getDataSummaryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getDataSummaryResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getDataSummaryResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getDataSummaryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getDataSummaryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getDataSummaryResponse * SOAP_FMAC4 soap_get__ns1__getDataSummaryResponse(struct soap *soap, _ns1__getDataSummaryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDataSummaryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getDataSummaryResponse * SOAP_FMAC2 soap_instantiate__ns1__getDataSummaryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getDataSummaryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getDataSummaryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getDataSummaryResponse);
		if (size)
			*size = sizeof(_ns1__getDataSummaryResponse);
		((_ns1__getDataSummaryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getDataSummaryResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getDataSummaryResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getDataSummaryResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getDataSummaryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getDataSummaryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getDataSummaryResponse %p -> %p\n", q, p));
	*(_ns1__getDataSummaryResponse*)p = *(_ns1__getDataSummaryResponse*)q;
}

void _ns1__getDataSummaryRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__getDataSummaryRequest::idModelData);
	/* transient soap skipped */
}

void _ns1__getDataSummaryRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getDataSummaryRequest::idModelData, SOAP_TYPE_int);
	/* transient soap skipped */
}

int _ns1__getDataSummaryRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getDataSummaryRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDataSummaryRequest(struct soap *soap, const char *tag, int id, const _ns1__getDataSummaryRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDataSummaryRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idModelData", -1, &(a->_ns1__getDataSummaryRequest::idModelData), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getDataSummaryRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getDataSummaryRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getDataSummaryRequest * SOAP_FMAC4 soap_in__ns1__getDataSummaryRequest(struct soap *soap, const char *tag, _ns1__getDataSummaryRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getDataSummaryRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDataSummaryRequest, sizeof(_ns1__getDataSummaryRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getDataSummaryRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getDataSummaryRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idModelData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idModelData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModelData", &(a->_ns1__getDataSummaryRequest::idModelData), "xsd:int"))
				{	soap_flag_idModelData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getDataSummaryRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDataSummaryRequest, 0, sizeof(_ns1__getDataSummaryRequest), 0, soap_copy__ns1__getDataSummaryRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idModelData1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getDataSummaryRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getDataSummaryRequest);
	if (this->soap_out(soap, tag?tag:"ns1:getDataSummaryRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getDataSummaryRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getDataSummaryRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getDataSummaryRequest * SOAP_FMAC4 soap_get__ns1__getDataSummaryRequest(struct soap *soap, _ns1__getDataSummaryRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDataSummaryRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getDataSummaryRequest * SOAP_FMAC2 soap_instantiate__ns1__getDataSummaryRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getDataSummaryRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getDataSummaryRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getDataSummaryRequest);
		if (size)
			*size = sizeof(_ns1__getDataSummaryRequest);
		((_ns1__getDataSummaryRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getDataSummaryRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getDataSummaryRequest);
		for (int i = 0; i < n; i++)
			((_ns1__getDataSummaryRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getDataSummaryRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getDataSummaryRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getDataSummaryRequest %p -> %p\n", q, p));
	*(_ns1__getDataSummaryRequest*)p = *(_ns1__getDataSummaryRequest*)q;
}

void _ns1__defineInstanceResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__defineInstanceResponse::modelInstance = NULL;
	/* transient soap skipped */
}

void _ns1__defineInstanceResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__modelInstance(soap, &this->_ns1__defineInstanceResponse::modelInstance);
	/* transient soap skipped */
}

int _ns1__defineInstanceResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__defineInstanceResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__defineInstanceResponse(struct soap *soap, const char *tag, int id, const _ns1__defineInstanceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__defineInstanceResponse), type))
		return soap->error;
	if (a->_ns1__defineInstanceResponse::modelInstance)
	{	if (soap_out_PointerTons3__modelInstance(soap, "modelInstance", -1, &a->_ns1__defineInstanceResponse::modelInstance, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "modelInstance"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__defineInstanceResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__defineInstanceResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__defineInstanceResponse * SOAP_FMAC4 soap_in__ns1__defineInstanceResponse(struct soap *soap, const char *tag, _ns1__defineInstanceResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__defineInstanceResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__defineInstanceResponse, sizeof(_ns1__defineInstanceResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__defineInstanceResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__defineInstanceResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_modelInstance1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_modelInstance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__modelInstance(soap, "modelInstance", &(a->_ns1__defineInstanceResponse::modelInstance), "ns3:modelInstance"))
				{	soap_flag_modelInstance1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__defineInstanceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__defineInstanceResponse, 0, sizeof(_ns1__defineInstanceResponse), 0, soap_copy__ns1__defineInstanceResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_modelInstance1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__defineInstanceResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__defineInstanceResponse);
	if (this->soap_out(soap, tag?tag:"ns1:defineInstanceResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__defineInstanceResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__defineInstanceResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__defineInstanceResponse * SOAP_FMAC4 soap_get__ns1__defineInstanceResponse(struct soap *soap, _ns1__defineInstanceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__defineInstanceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__defineInstanceResponse * SOAP_FMAC2 soap_instantiate__ns1__defineInstanceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__defineInstanceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__defineInstanceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__defineInstanceResponse);
		if (size)
			*size = sizeof(_ns1__defineInstanceResponse);
		((_ns1__defineInstanceResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__defineInstanceResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__defineInstanceResponse);
		for (int i = 0; i < n; i++)
			((_ns1__defineInstanceResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__defineInstanceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__defineInstanceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__defineInstanceResponse %p -> %p\n", q, p));
	*(_ns1__defineInstanceResponse*)p = *(_ns1__defineInstanceResponse*)q;
}

void _ns1__defineInstanceRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__defineInstanceRequest::modelInstance = NULL;
	/* transient soap skipped */
}

void _ns1__defineInstanceRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__modelInstance(soap, &this->_ns1__defineInstanceRequest::modelInstance);
	/* transient soap skipped */
}

int _ns1__defineInstanceRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__defineInstanceRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__defineInstanceRequest(struct soap *soap, const char *tag, int id, const _ns1__defineInstanceRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__defineInstanceRequest), type))
		return soap->error;
	if (a->_ns1__defineInstanceRequest::modelInstance)
	{	if (soap_out_PointerTons3__modelInstance(soap, "modelInstance", -1, &a->_ns1__defineInstanceRequest::modelInstance, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "modelInstance"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__defineInstanceRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__defineInstanceRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__defineInstanceRequest * SOAP_FMAC4 soap_in__ns1__defineInstanceRequest(struct soap *soap, const char *tag, _ns1__defineInstanceRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__defineInstanceRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__defineInstanceRequest, sizeof(_ns1__defineInstanceRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__defineInstanceRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__defineInstanceRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_modelInstance1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_modelInstance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__modelInstance(soap, "modelInstance", &(a->_ns1__defineInstanceRequest::modelInstance), "ns3:modelInstance"))
				{	soap_flag_modelInstance1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__defineInstanceRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__defineInstanceRequest, 0, sizeof(_ns1__defineInstanceRequest), 0, soap_copy__ns1__defineInstanceRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_modelInstance1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__defineInstanceRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__defineInstanceRequest);
	if (this->soap_out(soap, tag?tag:"ns1:defineInstanceRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__defineInstanceRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__defineInstanceRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__defineInstanceRequest * SOAP_FMAC4 soap_get__ns1__defineInstanceRequest(struct soap *soap, _ns1__defineInstanceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__defineInstanceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__defineInstanceRequest * SOAP_FMAC2 soap_instantiate__ns1__defineInstanceRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__defineInstanceRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__defineInstanceRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__defineInstanceRequest);
		if (size)
			*size = sizeof(_ns1__defineInstanceRequest);
		((_ns1__defineInstanceRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__defineInstanceRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__defineInstanceRequest);
		for (int i = 0; i < n; i++)
			((_ns1__defineInstanceRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__defineInstanceRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__defineInstanceRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__defineInstanceRequest %p -> %p\n", q, p));
	*(_ns1__defineInstanceRequest*)p = *(_ns1__defineInstanceRequest*)q;
}

void _ns1__changeModelDataStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__changeModelDataStatusResponse::result);
	/* transient soap skipped */
}

void _ns1__changeModelDataStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__changeModelDataStatusResponse::result, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__changeModelDataStatusResponse::result);
	/* transient soap skipped */
}

int _ns1__changeModelDataStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__changeModelDataStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__changeModelDataStatusResponse(struct soap *soap, const char *tag, int id, const _ns1__changeModelDataStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__changeModelDataStatusResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &(a->_ns1__changeModelDataStatusResponse::result), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__changeModelDataStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__changeModelDataStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__changeModelDataStatusResponse * SOAP_FMAC4 soap_in__ns1__changeModelDataStatusResponse(struct soap *soap, const char *tag, _ns1__changeModelDataStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__changeModelDataStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__changeModelDataStatusResponse, sizeof(_ns1__changeModelDataStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__changeModelDataStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__changeModelDataStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &(a->_ns1__changeModelDataStatusResponse::result), "xsd:string"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__changeModelDataStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__changeModelDataStatusResponse, 0, sizeof(_ns1__changeModelDataStatusResponse), 0, soap_copy__ns1__changeModelDataStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__changeModelDataStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__changeModelDataStatusResponse);
	if (this->soap_out(soap, tag?tag:"ns1:changeModelDataStatusResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__changeModelDataStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__changeModelDataStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__changeModelDataStatusResponse * SOAP_FMAC4 soap_get__ns1__changeModelDataStatusResponse(struct soap *soap, _ns1__changeModelDataStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__changeModelDataStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__changeModelDataStatusResponse * SOAP_FMAC2 soap_instantiate__ns1__changeModelDataStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__changeModelDataStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__changeModelDataStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__changeModelDataStatusResponse);
		if (size)
			*size = sizeof(_ns1__changeModelDataStatusResponse);
		((_ns1__changeModelDataStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__changeModelDataStatusResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__changeModelDataStatusResponse);
		for (int i = 0; i < n; i++)
			((_ns1__changeModelDataStatusResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__changeModelDataStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__changeModelDataStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__changeModelDataStatusResponse %p -> %p\n", q, p));
	*(_ns1__changeModelDataStatusResponse*)p = *(_ns1__changeModelDataStatusResponse*)q;
}

void _ns1__changeModelDataStatusRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__changeModelDataStatusRequest::idModelData);
	soap_default_ns2__status(soap, &this->_ns1__changeModelDataStatusRequest::status);
	/* transient soap skipped */
}

void _ns1__changeModelDataStatusRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__changeModelDataStatusRequest::idModelData, SOAP_TYPE_int);
	/* transient soap skipped */
}

int _ns1__changeModelDataStatusRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__changeModelDataStatusRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__changeModelDataStatusRequest(struct soap *soap, const char *tag, int id, const _ns1__changeModelDataStatusRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__changeModelDataStatusRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idModelData", -1, &(a->_ns1__changeModelDataStatusRequest::idModelData), ""))
		return soap->error;
	if (soap_out_ns2__status(soap, "status", -1, &(a->_ns1__changeModelDataStatusRequest::status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__changeModelDataStatusRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__changeModelDataStatusRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__changeModelDataStatusRequest * SOAP_FMAC4 soap_in__ns1__changeModelDataStatusRequest(struct soap *soap, const char *tag, _ns1__changeModelDataStatusRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__changeModelDataStatusRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__changeModelDataStatusRequest, sizeof(_ns1__changeModelDataStatusRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__changeModelDataStatusRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__changeModelDataStatusRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idModelData1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idModelData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModelData", &(a->_ns1__changeModelDataStatusRequest::idModelData), "xsd:int"))
				{	soap_flag_idModelData1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__status(soap, "status", &(a->_ns1__changeModelDataStatusRequest::status), "ns2:status"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__changeModelDataStatusRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__changeModelDataStatusRequest, 0, sizeof(_ns1__changeModelDataStatusRequest), 0, soap_copy__ns1__changeModelDataStatusRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idModelData1 > 0 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__changeModelDataStatusRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__changeModelDataStatusRequest);
	if (this->soap_out(soap, tag?tag:"ns1:changeModelDataStatusRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__changeModelDataStatusRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__changeModelDataStatusRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__changeModelDataStatusRequest * SOAP_FMAC4 soap_get__ns1__changeModelDataStatusRequest(struct soap *soap, _ns1__changeModelDataStatusRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__changeModelDataStatusRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__changeModelDataStatusRequest * SOAP_FMAC2 soap_instantiate__ns1__changeModelDataStatusRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__changeModelDataStatusRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__changeModelDataStatusRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__changeModelDataStatusRequest);
		if (size)
			*size = sizeof(_ns1__changeModelDataStatusRequest);
		((_ns1__changeModelDataStatusRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__changeModelDataStatusRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__changeModelDataStatusRequest);
		for (int i = 0; i < n; i++)
			((_ns1__changeModelDataStatusRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__changeModelDataStatusRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__changeModelDataStatusRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__changeModelDataStatusRequest %p -> %p\n", q, p));
	*(_ns1__changeModelDataStatusRequest*)p = *(_ns1__changeModelDataStatusRequest*)q;
}

void _ns1__defineModelDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__defineModelDataResponse::modelData = NULL;
	/* transient soap skipped */
}

void _ns1__defineModelDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__modelData(soap, &this->_ns1__defineModelDataResponse::modelData);
	/* transient soap skipped */
}

int _ns1__defineModelDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__defineModelDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__defineModelDataResponse(struct soap *soap, const char *tag, int id, const _ns1__defineModelDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__defineModelDataResponse), type))
		return soap->error;
	if (a->_ns1__defineModelDataResponse::modelData)
	{	if (soap_out_PointerTons3__modelData(soap, "modelData", -1, &a->_ns1__defineModelDataResponse::modelData, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "modelData"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__defineModelDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__defineModelDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__defineModelDataResponse * SOAP_FMAC4 soap_in__ns1__defineModelDataResponse(struct soap *soap, const char *tag, _ns1__defineModelDataResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__defineModelDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__defineModelDataResponse, sizeof(_ns1__defineModelDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__defineModelDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__defineModelDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_modelData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_modelData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__modelData(soap, "modelData", &(a->_ns1__defineModelDataResponse::modelData), "ns3:modelData"))
				{	soap_flag_modelData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__defineModelDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__defineModelDataResponse, 0, sizeof(_ns1__defineModelDataResponse), 0, soap_copy__ns1__defineModelDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_modelData1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__defineModelDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__defineModelDataResponse);
	if (this->soap_out(soap, tag?tag:"ns1:defineModelDataResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__defineModelDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__defineModelDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__defineModelDataResponse * SOAP_FMAC4 soap_get__ns1__defineModelDataResponse(struct soap *soap, _ns1__defineModelDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__defineModelDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__defineModelDataResponse * SOAP_FMAC2 soap_instantiate__ns1__defineModelDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__defineModelDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__defineModelDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__defineModelDataResponse);
		if (size)
			*size = sizeof(_ns1__defineModelDataResponse);
		((_ns1__defineModelDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__defineModelDataResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__defineModelDataResponse);
		for (int i = 0; i < n; i++)
			((_ns1__defineModelDataResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__defineModelDataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__defineModelDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__defineModelDataResponse %p -> %p\n", q, p));
	*(_ns1__defineModelDataResponse*)p = *(_ns1__defineModelDataResponse*)q;
}

void _ns1__defineModelDataRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__defineModelDataRequest::modelData = NULL;
	/* transient soap skipped */
}

void _ns1__defineModelDataRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__modelData(soap, &this->_ns1__defineModelDataRequest::modelData);
	/* transient soap skipped */
}

int _ns1__defineModelDataRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__defineModelDataRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__defineModelDataRequest(struct soap *soap, const char *tag, int id, const _ns1__defineModelDataRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__defineModelDataRequest), type))
		return soap->error;
	if (a->_ns1__defineModelDataRequest::modelData)
	{	if (soap_out_PointerTons3__modelData(soap, "modelData", -1, &a->_ns1__defineModelDataRequest::modelData, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "modelData"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__defineModelDataRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__defineModelDataRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__defineModelDataRequest * SOAP_FMAC4 soap_in__ns1__defineModelDataRequest(struct soap *soap, const char *tag, _ns1__defineModelDataRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__defineModelDataRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__defineModelDataRequest, sizeof(_ns1__defineModelDataRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__defineModelDataRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__defineModelDataRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_modelData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_modelData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__modelData(soap, "modelData", &(a->_ns1__defineModelDataRequest::modelData), "ns3:modelData"))
				{	soap_flag_modelData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__defineModelDataRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__defineModelDataRequest, 0, sizeof(_ns1__defineModelDataRequest), 0, soap_copy__ns1__defineModelDataRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_modelData1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__defineModelDataRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__defineModelDataRequest);
	if (this->soap_out(soap, tag?tag:"ns1:defineModelDataRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__defineModelDataRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__defineModelDataRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__defineModelDataRequest * SOAP_FMAC4 soap_get__ns1__defineModelDataRequest(struct soap *soap, _ns1__defineModelDataRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__defineModelDataRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__defineModelDataRequest * SOAP_FMAC2 soap_instantiate__ns1__defineModelDataRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__defineModelDataRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__defineModelDataRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__defineModelDataRequest);
		if (size)
			*size = sizeof(_ns1__defineModelDataRequest);
		((_ns1__defineModelDataRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__defineModelDataRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__defineModelDataRequest);
		for (int i = 0; i < n; i++)
			((_ns1__defineModelDataRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__defineModelDataRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__defineModelDataRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__defineModelDataRequest %p -> %p\n", q, p));
	*(_ns1__defineModelDataRequest*)p = *(_ns1__defineModelDataRequest*)q;
}

void _ns1__removeEntityValuesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__responseStatus(soap, &this->_ns1__removeEntityValuesResponse::status);
	this->_ns1__removeEntityValuesResponse::msg = NULL;
	/* transient soap skipped */
}

void _ns1__removeEntityValuesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__removeEntityValuesResponse::msg);
	/* transient soap skipped */
}

int _ns1__removeEntityValuesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeEntityValuesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeEntityValuesResponse(struct soap *soap, const char *tag, int id, const _ns1__removeEntityValuesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeEntityValuesResponse), type))
		return soap->error;
	if (soap_out_ns1__responseStatus(soap, "status", -1, &(a->_ns1__removeEntityValuesResponse::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "msg", -1, &(a->_ns1__removeEntityValuesResponse::msg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeEntityValuesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeEntityValuesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeEntityValuesResponse * SOAP_FMAC4 soap_in__ns1__removeEntityValuesResponse(struct soap *soap, const char *tag, _ns1__removeEntityValuesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeEntityValuesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeEntityValuesResponse, sizeof(_ns1__removeEntityValuesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeEntityValuesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeEntityValuesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_status1 = 1;
	size_t soap_flag_msg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__responseStatus(soap, "status", &(a->_ns1__removeEntityValuesResponse::status), "ns1:responseStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "msg", &(a->_ns1__removeEntityValuesResponse::msg), "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeEntityValuesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeEntityValuesResponse, 0, sizeof(_ns1__removeEntityValuesResponse), 0, soap_copy__ns1__removeEntityValuesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeEntityValuesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeEntityValuesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeEntityValuesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeEntityValuesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeEntityValuesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeEntityValuesResponse * SOAP_FMAC4 soap_get__ns1__removeEntityValuesResponse(struct soap *soap, _ns1__removeEntityValuesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeEntityValuesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeEntityValuesResponse * SOAP_FMAC2 soap_instantiate__ns1__removeEntityValuesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeEntityValuesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeEntityValuesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeEntityValuesResponse);
		if (size)
			*size = sizeof(_ns1__removeEntityValuesResponse);
		((_ns1__removeEntityValuesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeEntityValuesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeEntityValuesResponse);
		for (int i = 0; i < n; i++)
			((_ns1__removeEntityValuesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeEntityValuesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeEntityValuesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeEntityValuesResponse %p -> %p\n", q, p));
	*(_ns1__removeEntityValuesResponse*)p = *(_ns1__removeEntityValuesResponse*)q;
}

void _ns1__removeEntityValuesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__removeEntityValuesRequest::idModelSpec);
	soap_default_int(soap, &this->_ns1__removeEntityValuesRequest::idModeldata);
	soap_default_std__vectorTemplateOfPointerTons3__entityValues(soap, &this->_ns1__removeEntityValuesRequest::entityValues);
	/* transient soap skipped */
}

void _ns1__removeEntityValuesRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__removeEntityValuesRequest::idModelSpec, SOAP_TYPE_int);
	soap_embedded(soap, &this->_ns1__removeEntityValuesRequest::idModeldata, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfPointerTons3__entityValues(soap, &this->_ns1__removeEntityValuesRequest::entityValues);
	/* transient soap skipped */
}

int _ns1__removeEntityValuesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeEntityValuesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeEntityValuesRequest(struct soap *soap, const char *tag, int id, const _ns1__removeEntityValuesRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeEntityValuesRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idModelSpec", -1, &(a->_ns1__removeEntityValuesRequest::idModelSpec), ""))
		return soap->error;
	if (soap_out_int(soap, "idModeldata", -1, &(a->_ns1__removeEntityValuesRequest::idModeldata), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__entityValues(soap, "entityValues", -1, &(a->_ns1__removeEntityValuesRequest::entityValues), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeEntityValuesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeEntityValuesRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeEntityValuesRequest * SOAP_FMAC4 soap_in__ns1__removeEntityValuesRequest(struct soap *soap, const char *tag, _ns1__removeEntityValuesRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeEntityValuesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeEntityValuesRequest, sizeof(_ns1__removeEntityValuesRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeEntityValuesRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeEntityValuesRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idModelSpec1 = 1;
	size_t soap_flag_idModeldata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idModelSpec1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModelSpec", &(a->_ns1__removeEntityValuesRequest::idModelSpec), "xsd:int"))
				{	soap_flag_idModelSpec1--;
					continue;
				}
			if (soap_flag_idModeldata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModeldata", &(a->_ns1__removeEntityValuesRequest::idModeldata), "xsd:int"))
				{	soap_flag_idModeldata1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__entityValues(soap, "entityValues", &(a->_ns1__removeEntityValuesRequest::entityValues), "ns3:entityValues"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeEntityValuesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeEntityValuesRequest, 0, sizeof(_ns1__removeEntityValuesRequest), 0, soap_copy__ns1__removeEntityValuesRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idModelSpec1 > 0 || soap_flag_idModeldata1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeEntityValuesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeEntityValuesRequest);
	if (this->soap_out(soap, tag?tag:"ns1:removeEntityValuesRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeEntityValuesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeEntityValuesRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeEntityValuesRequest * SOAP_FMAC4 soap_get__ns1__removeEntityValuesRequest(struct soap *soap, _ns1__removeEntityValuesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeEntityValuesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeEntityValuesRequest * SOAP_FMAC2 soap_instantiate__ns1__removeEntityValuesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeEntityValuesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeEntityValuesRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeEntityValuesRequest);
		if (size)
			*size = sizeof(_ns1__removeEntityValuesRequest);
		((_ns1__removeEntityValuesRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeEntityValuesRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeEntityValuesRequest);
		for (int i = 0; i < n; i++)
			((_ns1__removeEntityValuesRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeEntityValuesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeEntityValuesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeEntityValuesRequest %p -> %p\n", q, p));
	*(_ns1__removeEntityValuesRequest*)p = *(_ns1__removeEntityValuesRequest*)q;
}

void _ns1__storeEntityValuesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__responseStatus(soap, &this->_ns1__storeEntityValuesResponse::status);
	this->_ns1__storeEntityValuesResponse::msg = NULL;
	/* transient soap skipped */
}

void _ns1__storeEntityValuesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__storeEntityValuesResponse::msg);
	/* transient soap skipped */
}

int _ns1__storeEntityValuesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__storeEntityValuesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__storeEntityValuesResponse(struct soap *soap, const char *tag, int id, const _ns1__storeEntityValuesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__storeEntityValuesResponse), type))
		return soap->error;
	if (soap_out_ns1__responseStatus(soap, "status", -1, &(a->_ns1__storeEntityValuesResponse::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "msg", -1, &(a->_ns1__storeEntityValuesResponse::msg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__storeEntityValuesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__storeEntityValuesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__storeEntityValuesResponse * SOAP_FMAC4 soap_in__ns1__storeEntityValuesResponse(struct soap *soap, const char *tag, _ns1__storeEntityValuesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__storeEntityValuesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__storeEntityValuesResponse, sizeof(_ns1__storeEntityValuesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__storeEntityValuesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__storeEntityValuesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_status1 = 1;
	size_t soap_flag_msg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__responseStatus(soap, "status", &(a->_ns1__storeEntityValuesResponse::status), "ns1:responseStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "msg", &(a->_ns1__storeEntityValuesResponse::msg), "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__storeEntityValuesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__storeEntityValuesResponse, 0, sizeof(_ns1__storeEntityValuesResponse), 0, soap_copy__ns1__storeEntityValuesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__storeEntityValuesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__storeEntityValuesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:storeEntityValuesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__storeEntityValuesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__storeEntityValuesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__storeEntityValuesResponse * SOAP_FMAC4 soap_get__ns1__storeEntityValuesResponse(struct soap *soap, _ns1__storeEntityValuesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__storeEntityValuesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__storeEntityValuesResponse * SOAP_FMAC2 soap_instantiate__ns1__storeEntityValuesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__storeEntityValuesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__storeEntityValuesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__storeEntityValuesResponse);
		if (size)
			*size = sizeof(_ns1__storeEntityValuesResponse);
		((_ns1__storeEntityValuesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__storeEntityValuesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__storeEntityValuesResponse);
		for (int i = 0; i < n; i++)
			((_ns1__storeEntityValuesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__storeEntityValuesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__storeEntityValuesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__storeEntityValuesResponse %p -> %p\n", q, p));
	*(_ns1__storeEntityValuesResponse*)p = *(_ns1__storeEntityValuesResponse*)q;
}

void _ns1__storeEntityValuesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__storeEntityValuesRequest::idModelSpec);
	soap_default_int(soap, &this->_ns1__storeEntityValuesRequest::idModeldata);
	soap_default_std__vectorTemplateOfPointerTons3__entityValues(soap, &this->_ns1__storeEntityValuesRequest::entityValues);
	/* transient soap skipped */
}

void _ns1__storeEntityValuesRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__storeEntityValuesRequest::idModelSpec, SOAP_TYPE_int);
	soap_embedded(soap, &this->_ns1__storeEntityValuesRequest::idModeldata, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfPointerTons3__entityValues(soap, &this->_ns1__storeEntityValuesRequest::entityValues);
	/* transient soap skipped */
}

int _ns1__storeEntityValuesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__storeEntityValuesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__storeEntityValuesRequest(struct soap *soap, const char *tag, int id, const _ns1__storeEntityValuesRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__storeEntityValuesRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idModelSpec", -1, &(a->_ns1__storeEntityValuesRequest::idModelSpec), ""))
		return soap->error;
	if (soap_out_int(soap, "idModeldata", -1, &(a->_ns1__storeEntityValuesRequest::idModeldata), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__entityValues(soap, "entityValues", -1, &(a->_ns1__storeEntityValuesRequest::entityValues), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__storeEntityValuesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__storeEntityValuesRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__storeEntityValuesRequest * SOAP_FMAC4 soap_in__ns1__storeEntityValuesRequest(struct soap *soap, const char *tag, _ns1__storeEntityValuesRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__storeEntityValuesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__storeEntityValuesRequest, sizeof(_ns1__storeEntityValuesRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__storeEntityValuesRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__storeEntityValuesRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idModelSpec1 = 1;
	size_t soap_flag_idModeldata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idModelSpec1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModelSpec", &(a->_ns1__storeEntityValuesRequest::idModelSpec), "xsd:int"))
				{	soap_flag_idModelSpec1--;
					continue;
				}
			if (soap_flag_idModeldata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModeldata", &(a->_ns1__storeEntityValuesRequest::idModeldata), "xsd:int"))
				{	soap_flag_idModeldata1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__entityValues(soap, "entityValues", &(a->_ns1__storeEntityValuesRequest::entityValues), "ns3:entityValues"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__storeEntityValuesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__storeEntityValuesRequest, 0, sizeof(_ns1__storeEntityValuesRequest), 0, soap_copy__ns1__storeEntityValuesRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idModelSpec1 > 0 || soap_flag_idModeldata1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__storeEntityValuesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__storeEntityValuesRequest);
	if (this->soap_out(soap, tag?tag:"ns1:storeEntityValuesRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__storeEntityValuesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__storeEntityValuesRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__storeEntityValuesRequest * SOAP_FMAC4 soap_get__ns1__storeEntityValuesRequest(struct soap *soap, _ns1__storeEntityValuesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__storeEntityValuesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__storeEntityValuesRequest * SOAP_FMAC2 soap_instantiate__ns1__storeEntityValuesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__storeEntityValuesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__storeEntityValuesRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__storeEntityValuesRequest);
		if (size)
			*size = sizeof(_ns1__storeEntityValuesRequest);
		((_ns1__storeEntityValuesRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__storeEntityValuesRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__storeEntityValuesRequest);
		for (int i = 0; i < n; i++)
			((_ns1__storeEntityValuesRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__storeEntityValuesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__storeEntityValuesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__storeEntityValuesRequest %p -> %p\n", q, p));
	*(_ns1__storeEntityValuesRequest*)p = *(_ns1__storeEntityValuesRequest*)q;
}

void _ns1__removeSetMembersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__responseStatus(soap, &this->_ns1__removeSetMembersResponse::status);
	this->_ns1__removeSetMembersResponse::msg = NULL;
	/* transient soap skipped */
}

void _ns1__removeSetMembersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__removeSetMembersResponse::msg);
	/* transient soap skipped */
}

int _ns1__removeSetMembersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeSetMembersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeSetMembersResponse(struct soap *soap, const char *tag, int id, const _ns1__removeSetMembersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeSetMembersResponse), type))
		return soap->error;
	if (soap_out_ns1__responseStatus(soap, "status", -1, &(a->_ns1__removeSetMembersResponse::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "msg", -1, &(a->_ns1__removeSetMembersResponse::msg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeSetMembersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeSetMembersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeSetMembersResponse * SOAP_FMAC4 soap_in__ns1__removeSetMembersResponse(struct soap *soap, const char *tag, _ns1__removeSetMembersResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeSetMembersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeSetMembersResponse, sizeof(_ns1__removeSetMembersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeSetMembersResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeSetMembersResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_status1 = 1;
	size_t soap_flag_msg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__responseStatus(soap, "status", &(a->_ns1__removeSetMembersResponse::status), "ns1:responseStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "msg", &(a->_ns1__removeSetMembersResponse::msg), "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeSetMembersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeSetMembersResponse, 0, sizeof(_ns1__removeSetMembersResponse), 0, soap_copy__ns1__removeSetMembersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeSetMembersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeSetMembersResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeSetMembersResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeSetMembersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeSetMembersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeSetMembersResponse * SOAP_FMAC4 soap_get__ns1__removeSetMembersResponse(struct soap *soap, _ns1__removeSetMembersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeSetMembersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeSetMembersResponse * SOAP_FMAC2 soap_instantiate__ns1__removeSetMembersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeSetMembersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeSetMembersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeSetMembersResponse);
		if (size)
			*size = sizeof(_ns1__removeSetMembersResponse);
		((_ns1__removeSetMembersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeSetMembersResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeSetMembersResponse);
		for (int i = 0; i < n; i++)
			((_ns1__removeSetMembersResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeSetMembersResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeSetMembersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeSetMembersResponse %p -> %p\n", q, p));
	*(_ns1__removeSetMembersResponse*)p = *(_ns1__removeSetMembersResponse*)q;
}

void _ns1__removeSetMembersRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__removeSetMembersRequest::idModeldata);
	soap_default_std__vectorTemplateOfPointerTons3__setMembers(soap, &this->_ns1__removeSetMembersRequest::setMembers);
	/* transient soap skipped */
}

void _ns1__removeSetMembersRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__removeSetMembersRequest::idModeldata, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfPointerTons3__setMembers(soap, &this->_ns1__removeSetMembersRequest::setMembers);
	/* transient soap skipped */
}

int _ns1__removeSetMembersRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__removeSetMembersRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__removeSetMembersRequest(struct soap *soap, const char *tag, int id, const _ns1__removeSetMembersRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__removeSetMembersRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idModeldata", -1, &(a->_ns1__removeSetMembersRequest::idModeldata), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__setMembers(soap, "setMembers", -1, &(a->_ns1__removeSetMembersRequest::setMembers), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__removeSetMembersRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__removeSetMembersRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__removeSetMembersRequest * SOAP_FMAC4 soap_in__ns1__removeSetMembersRequest(struct soap *soap, const char *tag, _ns1__removeSetMembersRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__removeSetMembersRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__removeSetMembersRequest, sizeof(_ns1__removeSetMembersRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__removeSetMembersRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__removeSetMembersRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idModeldata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idModeldata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModeldata", &(a->_ns1__removeSetMembersRequest::idModeldata), "xsd:int"))
				{	soap_flag_idModeldata1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__setMembers(soap, "setMembers", &(a->_ns1__removeSetMembersRequest::setMembers), "ns3:setMembers"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__removeSetMembersRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__removeSetMembersRequest, 0, sizeof(_ns1__removeSetMembersRequest), 0, soap_copy__ns1__removeSetMembersRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idModeldata1 > 0 || a->_ns1__removeSetMembersRequest::setMembers.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__removeSetMembersRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__removeSetMembersRequest);
	if (this->soap_out(soap, tag?tag:"ns1:removeSetMembersRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__removeSetMembersRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__removeSetMembersRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__removeSetMembersRequest * SOAP_FMAC4 soap_get__ns1__removeSetMembersRequest(struct soap *soap, _ns1__removeSetMembersRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__removeSetMembersRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__removeSetMembersRequest * SOAP_FMAC2 soap_instantiate__ns1__removeSetMembersRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__removeSetMembersRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__removeSetMembersRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeSetMembersRequest);
		if (size)
			*size = sizeof(_ns1__removeSetMembersRequest);
		((_ns1__removeSetMembersRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__removeSetMembersRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__removeSetMembersRequest);
		for (int i = 0; i < n; i++)
			((_ns1__removeSetMembersRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__removeSetMembersRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__removeSetMembersRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__removeSetMembersRequest %p -> %p\n", q, p));
	*(_ns1__removeSetMembersRequest*)p = *(_ns1__removeSetMembersRequest*)q;
}

void _ns1__storeSetMembersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__responseStatus(soap, &this->_ns1__storeSetMembersResponse::status);
	this->_ns1__storeSetMembersResponse::msg = NULL;
	/* transient soap skipped */
}

void _ns1__storeSetMembersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__storeSetMembersResponse::msg);
	/* transient soap skipped */
}

int _ns1__storeSetMembersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__storeSetMembersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__storeSetMembersResponse(struct soap *soap, const char *tag, int id, const _ns1__storeSetMembersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__storeSetMembersResponse), type))
		return soap->error;
	if (soap_out_ns1__responseStatus(soap, "status", -1, &(a->_ns1__storeSetMembersResponse::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "msg", -1, &(a->_ns1__storeSetMembersResponse::msg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__storeSetMembersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__storeSetMembersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__storeSetMembersResponse * SOAP_FMAC4 soap_in__ns1__storeSetMembersResponse(struct soap *soap, const char *tag, _ns1__storeSetMembersResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__storeSetMembersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__storeSetMembersResponse, sizeof(_ns1__storeSetMembersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__storeSetMembersResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__storeSetMembersResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_status1 = 1;
	size_t soap_flag_msg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__responseStatus(soap, "status", &(a->_ns1__storeSetMembersResponse::status), "ns1:responseStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "msg", &(a->_ns1__storeSetMembersResponse::msg), "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__storeSetMembersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__storeSetMembersResponse, 0, sizeof(_ns1__storeSetMembersResponse), 0, soap_copy__ns1__storeSetMembersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__storeSetMembersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__storeSetMembersResponse);
	if (this->soap_out(soap, tag?tag:"ns1:storeSetMembersResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__storeSetMembersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__storeSetMembersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__storeSetMembersResponse * SOAP_FMAC4 soap_get__ns1__storeSetMembersResponse(struct soap *soap, _ns1__storeSetMembersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__storeSetMembersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__storeSetMembersResponse * SOAP_FMAC2 soap_instantiate__ns1__storeSetMembersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__storeSetMembersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__storeSetMembersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__storeSetMembersResponse);
		if (size)
			*size = sizeof(_ns1__storeSetMembersResponse);
		((_ns1__storeSetMembersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__storeSetMembersResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__storeSetMembersResponse);
		for (int i = 0; i < n; i++)
			((_ns1__storeSetMembersResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__storeSetMembersResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__storeSetMembersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__storeSetMembersResponse %p -> %p\n", q, p));
	*(_ns1__storeSetMembersResponse*)p = *(_ns1__storeSetMembersResponse*)q;
}

void _ns1__storeSetMembersRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__storeSetMembersRequest::idModeldata);
	soap_default_std__vectorTemplateOfPointerTons3__setMembers(soap, &this->_ns1__storeSetMembersRequest::setMembers);
	/* transient soap skipped */
}

void _ns1__storeSetMembersRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__storeSetMembersRequest::idModeldata, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfPointerTons3__setMembers(soap, &this->_ns1__storeSetMembersRequest::setMembers);
	/* transient soap skipped */
}

int _ns1__storeSetMembersRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__storeSetMembersRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__storeSetMembersRequest(struct soap *soap, const char *tag, int id, const _ns1__storeSetMembersRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__storeSetMembersRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idModeldata", -1, &(a->_ns1__storeSetMembersRequest::idModeldata), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__setMembers(soap, "setMembers", -1, &(a->_ns1__storeSetMembersRequest::setMembers), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__storeSetMembersRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__storeSetMembersRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__storeSetMembersRequest * SOAP_FMAC4 soap_in__ns1__storeSetMembersRequest(struct soap *soap, const char *tag, _ns1__storeSetMembersRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__storeSetMembersRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__storeSetMembersRequest, sizeof(_ns1__storeSetMembersRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__storeSetMembersRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__storeSetMembersRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idModeldata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idModeldata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModeldata", &(a->_ns1__storeSetMembersRequest::idModeldata), "xsd:int"))
				{	soap_flag_idModeldata1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__setMembers(soap, "setMembers", &(a->_ns1__storeSetMembersRequest::setMembers), "ns3:setMembers"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__storeSetMembersRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__storeSetMembersRequest, 0, sizeof(_ns1__storeSetMembersRequest), 0, soap_copy__ns1__storeSetMembersRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idModeldata1 > 0 || a->_ns1__storeSetMembersRequest::setMembers.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__storeSetMembersRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__storeSetMembersRequest);
	if (this->soap_out(soap, tag?tag:"ns1:storeSetMembersRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__storeSetMembersRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__storeSetMembersRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__storeSetMembersRequest * SOAP_FMAC4 soap_get__ns1__storeSetMembersRequest(struct soap *soap, _ns1__storeSetMembersRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__storeSetMembersRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__storeSetMembersRequest * SOAP_FMAC2 soap_instantiate__ns1__storeSetMembersRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__storeSetMembersRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__storeSetMembersRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__storeSetMembersRequest);
		if (size)
			*size = sizeof(_ns1__storeSetMembersRequest);
		((_ns1__storeSetMembersRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__storeSetMembersRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__storeSetMembersRequest);
		for (int i = 0; i < n; i++)
			((_ns1__storeSetMembersRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__storeSetMembersRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__storeSetMembersRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__storeSetMembersRequest %p -> %p\n", q, p));
	*(_ns1__storeSetMembersRequest*)p = *(_ns1__storeSetMembersRequest*)q;
}

void _ns1__storeMainSetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__responseStatus(soap, &this->_ns1__storeMainSetResponse::status);
	this->_ns1__storeMainSetResponse::msg = NULL;
	/* transient soap skipped */
}

void _ns1__storeMainSetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__storeMainSetResponse::msg);
	/* transient soap skipped */
}

int _ns1__storeMainSetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__storeMainSetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__storeMainSetResponse(struct soap *soap, const char *tag, int id, const _ns1__storeMainSetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__storeMainSetResponse), type))
		return soap->error;
	if (soap_out_ns1__responseStatus(soap, "status", -1, &(a->_ns1__storeMainSetResponse::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "msg", -1, &(a->_ns1__storeMainSetResponse::msg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__storeMainSetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__storeMainSetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__storeMainSetResponse * SOAP_FMAC4 soap_in__ns1__storeMainSetResponse(struct soap *soap, const char *tag, _ns1__storeMainSetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__storeMainSetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__storeMainSetResponse, sizeof(_ns1__storeMainSetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__storeMainSetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__storeMainSetResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_status1 = 1;
	size_t soap_flag_msg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__responseStatus(soap, "status", &(a->_ns1__storeMainSetResponse::status), "ns1:responseStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "msg", &(a->_ns1__storeMainSetResponse::msg), "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__storeMainSetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__storeMainSetResponse, 0, sizeof(_ns1__storeMainSetResponse), 0, soap_copy__ns1__storeMainSetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__storeMainSetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__storeMainSetResponse);
	if (this->soap_out(soap, tag?tag:"ns1:storeMainSetResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__storeMainSetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__storeMainSetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__storeMainSetResponse * SOAP_FMAC4 soap_get__ns1__storeMainSetResponse(struct soap *soap, _ns1__storeMainSetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__storeMainSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__storeMainSetResponse * SOAP_FMAC2 soap_instantiate__ns1__storeMainSetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__storeMainSetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__storeMainSetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__storeMainSetResponse);
		if (size)
			*size = sizeof(_ns1__storeMainSetResponse);
		((_ns1__storeMainSetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__storeMainSetResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__storeMainSetResponse);
		for (int i = 0; i < n; i++)
			((_ns1__storeMainSetResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__storeMainSetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__storeMainSetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__storeMainSetResponse %p -> %p\n", q, p));
	*(_ns1__storeMainSetResponse*)p = *(_ns1__storeMainSetResponse*)q;
}

void _ns1__storeMainSetRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__storeMainSetRequest::idModeldata);
	soap_default_std__string(soap, &this->_ns1__storeMainSetRequest::setShortName);
	soap_default_std__vectorTemplateOfPointerTons3__memberDic(soap, &this->_ns1__storeMainSetRequest::member);
	/* transient soap skipped */
}

void _ns1__storeMainSetRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__storeMainSetRequest::idModeldata, SOAP_TYPE_int);
	soap_embedded(soap, &this->_ns1__storeMainSetRequest::setShortName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__storeMainSetRequest::setShortName);
	soap_serialize_std__vectorTemplateOfPointerTons3__memberDic(soap, &this->_ns1__storeMainSetRequest::member);
	/* transient soap skipped */
}

int _ns1__storeMainSetRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__storeMainSetRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__storeMainSetRequest(struct soap *soap, const char *tag, int id, const _ns1__storeMainSetRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__storeMainSetRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idModeldata", -1, &(a->_ns1__storeMainSetRequest::idModeldata), ""))
		return soap->error;
	if (soap_out_std__string(soap, "setShortName", -1, &(a->_ns1__storeMainSetRequest::setShortName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__memberDic(soap, "member", -1, &(a->_ns1__storeMainSetRequest::member), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__storeMainSetRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__storeMainSetRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__storeMainSetRequest * SOAP_FMAC4 soap_in__ns1__storeMainSetRequest(struct soap *soap, const char *tag, _ns1__storeMainSetRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__storeMainSetRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__storeMainSetRequest, sizeof(_ns1__storeMainSetRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__storeMainSetRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__storeMainSetRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idModeldata1 = 1;
	size_t soap_flag_setShortName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idModeldata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModeldata", &(a->_ns1__storeMainSetRequest::idModeldata), "xsd:int"))
				{	soap_flag_idModeldata1--;
					continue;
				}
			if (soap_flag_setShortName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "setShortName", &(a->_ns1__storeMainSetRequest::setShortName), "xsd:string"))
				{	soap_flag_setShortName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__memberDic(soap, "member", &(a->_ns1__storeMainSetRequest::member), "ns3:memberDic"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__storeMainSetRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__storeMainSetRequest, 0, sizeof(_ns1__storeMainSetRequest), 0, soap_copy__ns1__storeMainSetRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idModeldata1 > 0 || soap_flag_setShortName1 > 0 || a->_ns1__storeMainSetRequest::member.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__storeMainSetRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__storeMainSetRequest);
	if (this->soap_out(soap, tag?tag:"ns1:storeMainSetRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__storeMainSetRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__storeMainSetRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__storeMainSetRequest * SOAP_FMAC4 soap_get__ns1__storeMainSetRequest(struct soap *soap, _ns1__storeMainSetRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__storeMainSetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__storeMainSetRequest * SOAP_FMAC2 soap_instantiate__ns1__storeMainSetRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__storeMainSetRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__storeMainSetRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__storeMainSetRequest);
		if (size)
			*size = sizeof(_ns1__storeMainSetRequest);
		((_ns1__storeMainSetRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__storeMainSetRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__storeMainSetRequest);
		for (int i = 0; i < n; i++)
			((_ns1__storeMainSetRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__storeMainSetRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__storeMainSetRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__storeMainSetRequest %p -> %p\n", q, p));
	*(_ns1__storeMainSetRequest*)p = *(_ns1__storeMainSetRequest*)q;
}

void _ns1__getSetMembersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__memberDic(soap, &this->_ns1__getSetMembersResponse::member);
	/* transient soap skipped */
}

void _ns1__getSetMembersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__memberDic(soap, &this->_ns1__getSetMembersResponse::member);
	/* transient soap skipped */
}

int _ns1__getSetMembersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getSetMembersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSetMembersResponse(struct soap *soap, const char *tag, int id, const _ns1__getSetMembersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSetMembersResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__memberDic(soap, "member", -1, &(a->_ns1__getSetMembersResponse::member), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getSetMembersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getSetMembersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getSetMembersResponse * SOAP_FMAC4 soap_in__ns1__getSetMembersResponse(struct soap *soap, const char *tag, _ns1__getSetMembersResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getSetMembersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSetMembersResponse, sizeof(_ns1__getSetMembersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getSetMembersResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getSetMembersResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__memberDic(soap, "member", &(a->_ns1__getSetMembersResponse::member), "ns3:memberDic"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getSetMembersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getSetMembersResponse, 0, sizeof(_ns1__getSetMembersResponse), 0, soap_copy__ns1__getSetMembersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__getSetMembersResponse::member.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getSetMembersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getSetMembersResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getSetMembersResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getSetMembersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getSetMembersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getSetMembersResponse * SOAP_FMAC4 soap_get__ns1__getSetMembersResponse(struct soap *soap, _ns1__getSetMembersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSetMembersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getSetMembersResponse * SOAP_FMAC2 soap_instantiate__ns1__getSetMembersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getSetMembersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getSetMembersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getSetMembersResponse);
		if (size)
			*size = sizeof(_ns1__getSetMembersResponse);
		((_ns1__getSetMembersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getSetMembersResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getSetMembersResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getSetMembersResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getSetMembersResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getSetMembersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getSetMembersResponse %p -> %p\n", q, p));
	*(_ns1__getSetMembersResponse*)p = *(_ns1__getSetMembersResponse*)q;
}

void _ns1__getSetMembersRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__getSetMembersRequest::idModelData);
	soap_default_std__string(soap, &this->_ns1__getSetMembersRequest::setShortName);
	soap_default_std__vectorTemplateOfPointerTons3__memberDic(soap, &this->_ns1__getSetMembersRequest::tupleMember);
	/* transient soap skipped */
}

void _ns1__getSetMembersRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getSetMembersRequest::idModelData, SOAP_TYPE_int);
	soap_embedded(soap, &this->_ns1__getSetMembersRequest::setShortName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getSetMembersRequest::setShortName);
	soap_serialize_std__vectorTemplateOfPointerTons3__memberDic(soap, &this->_ns1__getSetMembersRequest::tupleMember);
	/* transient soap skipped */
}

int _ns1__getSetMembersRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getSetMembersRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSetMembersRequest(struct soap *soap, const char *tag, int id, const _ns1__getSetMembersRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSetMembersRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idModelData", -1, &(a->_ns1__getSetMembersRequest::idModelData), ""))
		return soap->error;
	if (soap_out_std__string(soap, "setShortName", -1, &(a->_ns1__getSetMembersRequest::setShortName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__memberDic(soap, "tupleMember", -1, &(a->_ns1__getSetMembersRequest::tupleMember), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getSetMembersRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getSetMembersRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getSetMembersRequest * SOAP_FMAC4 soap_in__ns1__getSetMembersRequest(struct soap *soap, const char *tag, _ns1__getSetMembersRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getSetMembersRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSetMembersRequest, sizeof(_ns1__getSetMembersRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getSetMembersRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getSetMembersRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idModelData1 = 1;
	size_t soap_flag_setShortName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idModelData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModelData", &(a->_ns1__getSetMembersRequest::idModelData), "xsd:int"))
				{	soap_flag_idModelData1--;
					continue;
				}
			if (soap_flag_setShortName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "setShortName", &(a->_ns1__getSetMembersRequest::setShortName), "xsd:string"))
				{	soap_flag_setShortName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__memberDic(soap, "tupleMember", &(a->_ns1__getSetMembersRequest::tupleMember), "ns3:memberDic"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getSetMembersRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getSetMembersRequest, 0, sizeof(_ns1__getSetMembersRequest), 0, soap_copy__ns1__getSetMembersRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idModelData1 > 0 || soap_flag_setShortName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getSetMembersRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getSetMembersRequest);
	if (this->soap_out(soap, tag?tag:"ns1:getSetMembersRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getSetMembersRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getSetMembersRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getSetMembersRequest * SOAP_FMAC4 soap_get__ns1__getSetMembersRequest(struct soap *soap, _ns1__getSetMembersRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSetMembersRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getSetMembersRequest * SOAP_FMAC2 soap_instantiate__ns1__getSetMembersRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getSetMembersRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getSetMembersRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getSetMembersRequest);
		if (size)
			*size = sizeof(_ns1__getSetMembersRequest);
		((_ns1__getSetMembersRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getSetMembersRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getSetMembersRequest);
		for (int i = 0; i < n; i++)
			((_ns1__getSetMembersRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getSetMembersRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getSetMembersRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getSetMembersRequest %p -> %p\n", q, p));
	*(_ns1__getSetMembersRequest*)p = *(_ns1__getSetMembersRequest*)q;
}

void _ns1__getBatchValuesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__getBatchValuesResponse::idModelData);
	soap_default_std__vectorTemplateOfPointerTons2__entitySpec(soap, &this->_ns1__getBatchValuesResponse::entitySpec);
	soap_default_std__vectorTemplateOfPointerTons3__batchValues(soap, &this->_ns1__getBatchValuesResponse::batchValues);
	/* transient soap skipped */
}

void _ns1__getBatchValuesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getBatchValuesResponse::idModelData, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfPointerTons2__entitySpec(soap, &this->_ns1__getBatchValuesResponse::entitySpec);
	soap_serialize_std__vectorTemplateOfPointerTons3__batchValues(soap, &this->_ns1__getBatchValuesResponse::batchValues);
	/* transient soap skipped */
}

int _ns1__getBatchValuesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getBatchValuesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getBatchValuesResponse(struct soap *soap, const char *tag, int id, const _ns1__getBatchValuesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getBatchValuesResponse), type))
		return soap->error;
	if (soap_out_int(soap, "idModelData", -1, &(a->_ns1__getBatchValuesResponse::idModelData), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__entitySpec(soap, "entitySpec", -1, &(a->_ns1__getBatchValuesResponse::entitySpec), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__batchValues(soap, "batchValues", -1, &(a->_ns1__getBatchValuesResponse::batchValues), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getBatchValuesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getBatchValuesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getBatchValuesResponse * SOAP_FMAC4 soap_in__ns1__getBatchValuesResponse(struct soap *soap, const char *tag, _ns1__getBatchValuesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getBatchValuesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getBatchValuesResponse, sizeof(_ns1__getBatchValuesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getBatchValuesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getBatchValuesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idModelData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idModelData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModelData", &(a->_ns1__getBatchValuesResponse::idModelData), "xsd:int"))
				{	soap_flag_idModelData1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__entitySpec(soap, "entitySpec", &(a->_ns1__getBatchValuesResponse::entitySpec), "ns2:entitySpec"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__batchValues(soap, "batchValues", &(a->_ns1__getBatchValuesResponse::batchValues), "ns3:batchValues"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getBatchValuesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getBatchValuesResponse, 0, sizeof(_ns1__getBatchValuesResponse), 0, soap_copy__ns1__getBatchValuesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idModelData1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getBatchValuesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getBatchValuesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getBatchValuesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getBatchValuesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getBatchValuesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getBatchValuesResponse * SOAP_FMAC4 soap_get__ns1__getBatchValuesResponse(struct soap *soap, _ns1__getBatchValuesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getBatchValuesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getBatchValuesResponse * SOAP_FMAC2 soap_instantiate__ns1__getBatchValuesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getBatchValuesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getBatchValuesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getBatchValuesResponse);
		if (size)
			*size = sizeof(_ns1__getBatchValuesResponse);
		((_ns1__getBatchValuesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getBatchValuesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getBatchValuesResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getBatchValuesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getBatchValuesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getBatchValuesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getBatchValuesResponse %p -> %p\n", q, p));
	*(_ns1__getBatchValuesResponse*)p = *(_ns1__getBatchValuesResponse*)q;
}

void _ns1__getBatchValuesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__getBatchValuesRequest::idModelSpec);
	soap_default_int(soap, &this->_ns1__getBatchValuesRequest::idModelData);
	soap_default_std__string(soap, &this->_ns1__getBatchValuesRequest::batch);
	/* transient soap skipped */
}

void _ns1__getBatchValuesRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getBatchValuesRequest::idModelSpec, SOAP_TYPE_int);
	soap_embedded(soap, &this->_ns1__getBatchValuesRequest::idModelData, SOAP_TYPE_int);
	soap_embedded(soap, &this->_ns1__getBatchValuesRequest::batch, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getBatchValuesRequest::batch);
	/* transient soap skipped */
}

int _ns1__getBatchValuesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getBatchValuesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getBatchValuesRequest(struct soap *soap, const char *tag, int id, const _ns1__getBatchValuesRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getBatchValuesRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idModelSpec", -1, &(a->_ns1__getBatchValuesRequest::idModelSpec), ""))
		return soap->error;
	if (soap_out_int(soap, "idModelData", -1, &(a->_ns1__getBatchValuesRequest::idModelData), ""))
		return soap->error;
	if (soap_out_std__string(soap, "batch", -1, &(a->_ns1__getBatchValuesRequest::batch), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getBatchValuesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getBatchValuesRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getBatchValuesRequest * SOAP_FMAC4 soap_in__ns1__getBatchValuesRequest(struct soap *soap, const char *tag, _ns1__getBatchValuesRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getBatchValuesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getBatchValuesRequest, sizeof(_ns1__getBatchValuesRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getBatchValuesRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getBatchValuesRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idModelSpec1 = 1;
	size_t soap_flag_idModelData1 = 1;
	size_t soap_flag_batch1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idModelSpec1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModelSpec", &(a->_ns1__getBatchValuesRequest::idModelSpec), "xsd:int"))
				{	soap_flag_idModelSpec1--;
					continue;
				}
			if (soap_flag_idModelData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModelData", &(a->_ns1__getBatchValuesRequest::idModelData), "xsd:int"))
				{	soap_flag_idModelData1--;
					continue;
				}
			if (soap_flag_batch1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "batch", &(a->_ns1__getBatchValuesRequest::batch), "xsd:string"))
				{	soap_flag_batch1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getBatchValuesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getBatchValuesRequest, 0, sizeof(_ns1__getBatchValuesRequest), 0, soap_copy__ns1__getBatchValuesRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idModelSpec1 > 0 || soap_flag_idModelData1 > 0 || soap_flag_batch1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getBatchValuesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getBatchValuesRequest);
	if (this->soap_out(soap, tag?tag:"ns1:getBatchValuesRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getBatchValuesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getBatchValuesRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getBatchValuesRequest * SOAP_FMAC4 soap_get__ns1__getBatchValuesRequest(struct soap *soap, _ns1__getBatchValuesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getBatchValuesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getBatchValuesRequest * SOAP_FMAC2 soap_instantiate__ns1__getBatchValuesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getBatchValuesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getBatchValuesRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getBatchValuesRequest);
		if (size)
			*size = sizeof(_ns1__getBatchValuesRequest);
		((_ns1__getBatchValuesRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getBatchValuesRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getBatchValuesRequest);
		for (int i = 0; i < n; i++)
			((_ns1__getBatchValuesRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getBatchValuesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getBatchValuesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getBatchValuesRequest %p -> %p\n", q, p));
	*(_ns1__getBatchValuesRequest*)p = *(_ns1__getBatchValuesRequest*)q;
}

void _ns1__getEntityValuesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getEntityValuesResponse::entitySpec = NULL;
	soap_default_std__vectorTemplateOfPointerTons3__tupleValue(soap, &this->_ns1__getEntityValuesResponse::tupleValue);
	/* transient soap skipped */
}

void _ns1__getEntityValuesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__entitySpec(soap, &this->_ns1__getEntityValuesResponse::entitySpec);
	soap_serialize_std__vectorTemplateOfPointerTons3__tupleValue(soap, &this->_ns1__getEntityValuesResponse::tupleValue);
	/* transient soap skipped */
}

int _ns1__getEntityValuesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getEntityValuesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getEntityValuesResponse(struct soap *soap, const char *tag, int id, const _ns1__getEntityValuesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getEntityValuesResponse), type))
		return soap->error;
	if (a->_ns1__getEntityValuesResponse::entitySpec)
	{	if (soap_out_PointerTons2__entitySpec(soap, "entitySpec", -1, &a->_ns1__getEntityValuesResponse::entitySpec, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "entitySpec"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__tupleValue(soap, "tupleValue", -1, &(a->_ns1__getEntityValuesResponse::tupleValue), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getEntityValuesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getEntityValuesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getEntityValuesResponse * SOAP_FMAC4 soap_in__ns1__getEntityValuesResponse(struct soap *soap, const char *tag, _ns1__getEntityValuesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getEntityValuesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getEntityValuesResponse, sizeof(_ns1__getEntityValuesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getEntityValuesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getEntityValuesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entitySpec1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entitySpec1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__entitySpec(soap, "entitySpec", &(a->_ns1__getEntityValuesResponse::entitySpec), "ns2:entitySpec"))
				{	soap_flag_entitySpec1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__tupleValue(soap, "tupleValue", &(a->_ns1__getEntityValuesResponse::tupleValue), "ns3:tupleValue"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getEntityValuesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getEntityValuesResponse, 0, sizeof(_ns1__getEntityValuesResponse), 0, soap_copy__ns1__getEntityValuesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entitySpec1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getEntityValuesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getEntityValuesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getEntityValuesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getEntityValuesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getEntityValuesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getEntityValuesResponse * SOAP_FMAC4 soap_get__ns1__getEntityValuesResponse(struct soap *soap, _ns1__getEntityValuesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getEntityValuesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getEntityValuesResponse * SOAP_FMAC2 soap_instantiate__ns1__getEntityValuesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getEntityValuesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getEntityValuesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getEntityValuesResponse);
		if (size)
			*size = sizeof(_ns1__getEntityValuesResponse);
		((_ns1__getEntityValuesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getEntityValuesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getEntityValuesResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getEntityValuesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getEntityValuesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getEntityValuesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getEntityValuesResponse %p -> %p\n", q, p));
	*(_ns1__getEntityValuesResponse*)p = *(_ns1__getEntityValuesResponse*)q;
}

void _ns1__getEntityValuesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__getEntityValuesRequest::idModelSpec);
	soap_default_int(soap, &this->_ns1__getEntityValuesRequest::idModelData);
	soap_default_std__string(soap, &this->_ns1__getEntityValuesRequest::entityShortName);
	/* transient soap skipped */
}

void _ns1__getEntityValuesRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getEntityValuesRequest::idModelSpec, SOAP_TYPE_int);
	soap_embedded(soap, &this->_ns1__getEntityValuesRequest::idModelData, SOAP_TYPE_int);
	soap_embedded(soap, &this->_ns1__getEntityValuesRequest::entityShortName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__getEntityValuesRequest::entityShortName);
	/* transient soap skipped */
}

int _ns1__getEntityValuesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getEntityValuesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getEntityValuesRequest(struct soap *soap, const char *tag, int id, const _ns1__getEntityValuesRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getEntityValuesRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idModelSpec", -1, &(a->_ns1__getEntityValuesRequest::idModelSpec), ""))
		return soap->error;
	if (soap_out_int(soap, "idModelData", -1, &(a->_ns1__getEntityValuesRequest::idModelData), ""))
		return soap->error;
	if (soap_out_std__string(soap, "entityShortName", -1, &(a->_ns1__getEntityValuesRequest::entityShortName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getEntityValuesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getEntityValuesRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getEntityValuesRequest * SOAP_FMAC4 soap_in__ns1__getEntityValuesRequest(struct soap *soap, const char *tag, _ns1__getEntityValuesRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getEntityValuesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getEntityValuesRequest, sizeof(_ns1__getEntityValuesRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getEntityValuesRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getEntityValuesRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idModelSpec1 = 1;
	size_t soap_flag_idModelData1 = 1;
	size_t soap_flag_entityShortName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idModelSpec1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModelSpec", &(a->_ns1__getEntityValuesRequest::idModelSpec), "xsd:int"))
				{	soap_flag_idModelSpec1--;
					continue;
				}
			if (soap_flag_idModelData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModelData", &(a->_ns1__getEntityValuesRequest::idModelData), "xsd:int"))
				{	soap_flag_idModelData1--;
					continue;
				}
			if (soap_flag_entityShortName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "entityShortName", &(a->_ns1__getEntityValuesRequest::entityShortName), "xsd:string"))
				{	soap_flag_entityShortName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getEntityValuesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getEntityValuesRequest, 0, sizeof(_ns1__getEntityValuesRequest), 0, soap_copy__ns1__getEntityValuesRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idModelSpec1 > 0 || soap_flag_idModelData1 > 0 || soap_flag_entityShortName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getEntityValuesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getEntityValuesRequest);
	if (this->soap_out(soap, tag?tag:"ns1:getEntityValuesRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getEntityValuesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getEntityValuesRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getEntityValuesRequest * SOAP_FMAC4 soap_get__ns1__getEntityValuesRequest(struct soap *soap, _ns1__getEntityValuesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getEntityValuesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getEntityValuesRequest * SOAP_FMAC2 soap_instantiate__ns1__getEntityValuesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getEntityValuesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getEntityValuesRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getEntityValuesRequest);
		if (size)
			*size = sizeof(_ns1__getEntityValuesRequest);
		((_ns1__getEntityValuesRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getEntityValuesRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getEntityValuesRequest);
		for (int i = 0; i < n; i++)
			((_ns1__getEntityValuesRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getEntityValuesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getEntityValuesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getEntityValuesRequest %p -> %p\n", q, p));
	*(_ns1__getEntityValuesRequest*)p = *(_ns1__getEntityValuesRequest*)q;
}

void _ns1__getSMSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getSMSResponse::modelSpec = NULL;
	/* transient soap skipped */
}

void _ns1__getSMSResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__modelSpec(soap, &this->_ns1__getSMSResponse::modelSpec);
	/* transient soap skipped */
}

int _ns1__getSMSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getSMSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSMSResponse(struct soap *soap, const char *tag, int id, const _ns1__getSMSResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSMSResponse), type))
		return soap->error;
	if (a->_ns1__getSMSResponse::modelSpec)
	{	if (soap_out_PointerTons2__modelSpec(soap, "modelSpec", -1, &a->_ns1__getSMSResponse::modelSpec, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "modelSpec"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getSMSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getSMSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getSMSResponse * SOAP_FMAC4 soap_in__ns1__getSMSResponse(struct soap *soap, const char *tag, _ns1__getSMSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getSMSResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSMSResponse, sizeof(_ns1__getSMSResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getSMSResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getSMSResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_modelSpec1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_modelSpec1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__modelSpec(soap, "modelSpec", &(a->_ns1__getSMSResponse::modelSpec), "ns2:modelSpec"))
				{	soap_flag_modelSpec1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getSMSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getSMSResponse, 0, sizeof(_ns1__getSMSResponse), 0, soap_copy__ns1__getSMSResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_modelSpec1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getSMSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getSMSResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getSMSResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getSMSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getSMSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getSMSResponse * SOAP_FMAC4 soap_get__ns1__getSMSResponse(struct soap *soap, _ns1__getSMSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSMSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getSMSResponse * SOAP_FMAC2 soap_instantiate__ns1__getSMSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getSMSResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getSMSResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getSMSResponse);
		if (size)
			*size = sizeof(_ns1__getSMSResponse);
		((_ns1__getSMSResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getSMSResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getSMSResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getSMSResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getSMSResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getSMSResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getSMSResponse %p -> %p\n", q, p));
	*(_ns1__getSMSResponse*)p = *(_ns1__getSMSResponse*)q;
}

void _ns1__getSMSRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__getSMSRequest::idModelSpec);
	/* transient soap skipped */
}

void _ns1__getSMSRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__getSMSRequest::idModelSpec, SOAP_TYPE_int);
	/* transient soap skipped */
}

int _ns1__getSMSRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getSMSRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSMSRequest(struct soap *soap, const char *tag, int id, const _ns1__getSMSRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSMSRequest), type))
		return soap->error;
	if (soap_out_int(soap, "idModelSpec", -1, &(a->_ns1__getSMSRequest::idModelSpec), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getSMSRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getSMSRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getSMSRequest * SOAP_FMAC4 soap_in__ns1__getSMSRequest(struct soap *soap, const char *tag, _ns1__getSMSRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getSMSRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSMSRequest, sizeof(_ns1__getSMSRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getSMSRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getSMSRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idModelSpec1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idModelSpec1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModelSpec", &(a->_ns1__getSMSRequest::idModelSpec), "xsd:int"))
				{	soap_flag_idModelSpec1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getSMSRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getSMSRequest, 0, sizeof(_ns1__getSMSRequest), 0, soap_copy__ns1__getSMSRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idModelSpec1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getSMSRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getSMSRequest);
	if (this->soap_out(soap, tag?tag:"ns1:getSMSRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getSMSRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getSMSRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getSMSRequest * SOAP_FMAC4 soap_get__ns1__getSMSRequest(struct soap *soap, _ns1__getSMSRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSMSRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getSMSRequest * SOAP_FMAC2 soap_instantiate__ns1__getSMSRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getSMSRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getSMSRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getSMSRequest);
		if (size)
			*size = sizeof(_ns1__getSMSRequest);
		((_ns1__getSMSRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getSMSRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getSMSRequest);
		for (int i = 0; i < n; i++)
			((_ns1__getSMSRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getSMSRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getSMSRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getSMSRequest %p -> %p\n", q, p));
	*(_ns1__getSMSRequest*)p = *(_ns1__getSMSRequest*)q;
}

void ns4__preference::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns4__preference::idEntitySpec);
	soap_default_ns4__preferenceType(soap, &this->ns4__preference::preferenceType);
	this->ns4__preference::prefValue = NULL;
	/* transient soap skipped */
}

void ns4__preference::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns4__preference::idEntitySpec, SOAP_TYPE_int);
	soap_serialize_PointerTodouble(soap, &this->ns4__preference::prefValue);
	/* transient soap skipped */
}

int ns4__preference::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__preference(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__preference(struct soap *soap, const char *tag, int id, const ns4__preference *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__preference), type))
		return soap->error;
	if (soap_out_int(soap, "idEntitySpec", -1, &(a->ns4__preference::idEntitySpec), ""))
		return soap->error;
	if (soap_out_ns4__preferenceType(soap, "preferenceType", -1, &(a->ns4__preference::preferenceType), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "prefValue", -1, &(a->ns4__preference::prefValue), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__preference::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__preference(soap, tag, this, type);
}

SOAP_FMAC3 ns4__preference * SOAP_FMAC4 soap_in_ns4__preference(struct soap *soap, const char *tag, ns4__preference *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__preference *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__preference, sizeof(ns4__preference), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__preference)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__preference *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_idEntitySpec1 = 1;
	size_t soap_flag_preferenceType1 = 1;
	size_t soap_flag_prefValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idEntitySpec1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idEntitySpec", &(a->ns4__preference::idEntitySpec), "xsd:int"))
				{	soap_flag_idEntitySpec1--;
					continue;
				}
			if (soap_flag_preferenceType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns4__preferenceType(soap, "preferenceType", &(a->ns4__preference::preferenceType), "ns4:preferenceType"))
				{	soap_flag_preferenceType1--;
					continue;
				}
			if (soap_flag_prefValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "prefValue", &(a->ns4__preference::prefValue), "xsd:double"))
				{	soap_flag_prefValue1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__preference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__preference, 0, sizeof(ns4__preference), 0, soap_copy_ns4__preference);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idEntitySpec1 > 0 || soap_flag_preferenceType1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__preference::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__preference);
	if (this->soap_out(soap, tag?tag:"ns4:preference", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__preference::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__preference(soap, this, tag, type);
}

SOAP_FMAC3 ns4__preference * SOAP_FMAC4 soap_get_ns4__preference(struct soap *soap, ns4__preference *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__preference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__preference * SOAP_FMAC2 soap_instantiate_ns4__preference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__preference(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__preference, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__preference);
		if (size)
			*size = sizeof(ns4__preference);
		((ns4__preference*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns4__preference[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__preference);
		for (int i = 0; i < n; i++)
			((ns4__preference*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__preference*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__preference(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__preference %p -> %p\n", q, p));
	*(ns4__preference*)p = *(ns4__preference*)q;
}

void ns4__analysis::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__analysis::id = NULL;
	soap_default_int(soap, &this->ns4__analysis::idModelInstance);
	soap_default_ns2__shortName(soap, &this->ns4__analysis::shortName);
	this->ns4__analysis::name = NULL;
	this->ns4__analysis::description = NULL;
	soap_default_std__string(soap, &this->ns4__analysis::status);
	/* transient soap skipped */
}

void ns4__analysis::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->ns4__analysis::id);
	soap_embedded(soap, &this->ns4__analysis::idModelInstance, SOAP_TYPE_int);
	soap_embedded(soap, &this->ns4__analysis::shortName, SOAP_TYPE_ns2__shortName);
	soap_serialize_ns2__shortName(soap, &this->ns4__analysis::shortName);
	soap_serialize_PointerTons2__name(soap, &this->ns4__analysis::name);
	soap_serialize_PointerTons2__description(soap, &this->ns4__analysis::description);
	soap_embedded(soap, &this->ns4__analysis::status, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns4__analysis::status);
	/* transient soap skipped */
}

int ns4__analysis::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__analysis(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__analysis(struct soap *soap, const char *tag, int id, const ns4__analysis *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__analysis), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "id", -1, &(a->ns4__analysis::id), ""))
		return soap->error;
	if (soap_out_int(soap, "idModelInstance", -1, &(a->ns4__analysis::idModelInstance), ""))
		return soap->error;
	if (soap_out_ns2__shortName(soap, "shortName", -1, &(a->ns4__analysis::shortName), ""))
		return soap->error;
	if (soap_out_PointerTons2__name(soap, "name", -1, &(a->ns4__analysis::name), ""))
		return soap->error;
	if (soap_out_PointerTons2__description(soap, "description", -1, &(a->ns4__analysis::description), ""))
		return soap->error;
	if (soap_out_std__string(soap, "status", -1, &(a->ns4__analysis::status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns4__analysis::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__analysis(soap, tag, this, type);
}

SOAP_FMAC3 ns4__analysis * SOAP_FMAC4 soap_in_ns4__analysis(struct soap *soap, const char *tag, ns4__analysis *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__analysis *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__analysis, sizeof(ns4__analysis), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__analysis)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__analysis *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_idModelInstance1 = 1;
	size_t soap_flag_shortName1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "id", &(a->ns4__analysis::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_idModelInstance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModelInstance", &(a->ns4__analysis::idModelInstance), "xsd:int"))
				{	soap_flag_idModelInstance1--;
					continue;
				}
			if (soap_flag_shortName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__shortName(soap, "shortName", &(a->ns4__analysis::shortName), "ns2:shortName"))
				{	soap_flag_shortName1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__name(soap, "name", &(a->ns4__analysis::name), "ns2:name"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__description(soap, "description", &(a->ns4__analysis::description), "ns2:description"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "status", &(a->ns4__analysis::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__analysis *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__analysis, 0, sizeof(ns4__analysis), 0, soap_copy_ns4__analysis);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idModelInstance1 > 0 || soap_flag_shortName1 > 0 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns4__analysis::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__analysis);
	if (this->soap_out(soap, tag?tag:"ns4:analysis", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__analysis::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__analysis(soap, this, tag, type);
}

SOAP_FMAC3 ns4__analysis * SOAP_FMAC4 soap_get_ns4__analysis(struct soap *soap, ns4__analysis *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__analysis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__analysis * SOAP_FMAC2 soap_instantiate_ns4__analysis(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__analysis(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__analysis, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__analysis);
		if (size)
			*size = sizeof(ns4__analysis);
		((ns4__analysis*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns4__analysis[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__analysis);
		for (int i = 0; i < n; i++)
			((ns4__analysis*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__analysis*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__analysis(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__analysis %p -> %p\n", q, p));
	*(ns4__analysis*)p = *(ns4__analysis*)q;
}

void _ns3__dataSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__setMembers(soap, &this->_ns3__dataSet::setMembers);
	soap_default_std__vectorTemplateOfPointerTons3__entityValues(soap, &this->_ns3__dataSet::entityValues);
	/* transient soap skipped */
}

void _ns3__dataSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__setMembers(soap, &this->_ns3__dataSet::setMembers);
	soap_serialize_std__vectorTemplateOfPointerTons3__entityValues(soap, &this->_ns3__dataSet::entityValues);
	/* transient soap skipped */
}

int _ns3__dataSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__dataSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__dataSet(struct soap *soap, const char *tag, int id, const _ns3__dataSet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__dataSet), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__setMembers(soap, "setMembers", -1, &(a->_ns3__dataSet::setMembers), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__entityValues(soap, "entityValues", -1, &(a->_ns3__dataSet::entityValues), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__dataSet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__dataSet(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__dataSet * SOAP_FMAC4 soap_in__ns3__dataSet(struct soap *soap, const char *tag, _ns3__dataSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__dataSet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__dataSet, sizeof(_ns3__dataSet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__dataSet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__dataSet *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__setMembers(soap, "setMembers", &(a->_ns3__dataSet::setMembers), "ns3:setMembers"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__entityValues(soap, "entityValues", &(a->_ns3__dataSet::entityValues), "ns3:entityValues"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__dataSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__dataSet, 0, sizeof(_ns3__dataSet), 0, soap_copy__ns3__dataSet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_ns3__dataSet::setMembers.size() < 1 || a->_ns3__dataSet::entityValues.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns3__dataSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__dataSet);
	if (this->soap_out(soap, tag?tag:"ns3:dataSet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns3__dataSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__dataSet(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__dataSet * SOAP_FMAC4 soap_get__ns3__dataSet(struct soap *soap, _ns3__dataSet *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__dataSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns3__dataSet * SOAP_FMAC2 soap_instantiate__ns3__dataSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__dataSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__dataSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns3__dataSet);
		if (size)
			*size = sizeof(_ns3__dataSet);
		((_ns3__dataSet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns3__dataSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__dataSet);
		for (int i = 0; i < n; i++)
			((_ns3__dataSet*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__dataSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__dataSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__dataSet %p -> %p\n", q, p));
	*(_ns3__dataSet*)p = *(_ns3__dataSet*)q;
}

void ns3__value::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__value::__union_value = 0;
	/* transient soap skipped */
}

void ns3__value::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns3__union_value(soap, this->ns3__value::__union_value, &this->ns3__value::union_value);
	/* transient soap skipped */
}

int ns3__value::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__value(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__value(struct soap *soap, const char *tag, int id, const ns3__value *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__value), type))
		return soap->error;
	if (soap_out__ns3__union_value(soap, a->ns3__value::__union_value, &a->ns3__value::union_value))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__value::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__value(soap, tag, this, type);
}

SOAP_FMAC3 ns3__value * SOAP_FMAC4 soap_in_ns3__value(struct soap *soap, const char *tag, ns3__value *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__value *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__value, sizeof(ns3__value), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && !*soap->href))
	{
		if (!soap_in__ns3__union_value(soap, &a->__union_value, &a->union_value))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__value *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__value, 0, sizeof(ns3__value), 0, soap_copy_ns3__value);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__value::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__value);
	if (this->soap_out(soap, tag?tag:"ns3:value", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__value::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__value(soap, this, tag, type);
}

SOAP_FMAC3 ns3__value * SOAP_FMAC4 soap_get_ns3__value(struct soap *soap, ns3__value *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__value(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__value * SOAP_FMAC2 soap_instantiate_ns3__value(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__value(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__value, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__value);
		if (size)
			*size = sizeof(ns3__value);
		((ns3__value*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__value[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__value);
		for (int i = 0; i < n; i++)
			((ns3__value*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__value*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__value(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__value %p -> %p\n", q, p));
	*(ns3__value*)p = *(ns3__value*)q;
}

void ns3__batchValues::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__memberDic(soap, &this->ns3__batchValues::tupleMember);
	soap_default_std__vectorTemplateOfPointerTons3__value(soap, &this->ns3__batchValues::value);
	/* transient soap skipped */
}

void ns3__batchValues::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__memberDic(soap, &this->ns3__batchValues::tupleMember);
	soap_serialize_std__vectorTemplateOfPointerTons3__value(soap, &this->ns3__batchValues::value);
	/* transient soap skipped */
}

int ns3__batchValues::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__batchValues(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__batchValues(struct soap *soap, const char *tag, int id, const ns3__batchValues *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__batchValues), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__memberDic(soap, "tupleMember", -1, &(a->ns3__batchValues::tupleMember), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__value(soap, "value", -1, &(a->ns3__batchValues::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__batchValues::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__batchValues(soap, tag, this, type);
}

SOAP_FMAC3 ns3__batchValues * SOAP_FMAC4 soap_in_ns3__batchValues(struct soap *soap, const char *tag, ns3__batchValues *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__batchValues *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__batchValues, sizeof(ns3__batchValues), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__batchValues)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__batchValues *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__memberDic(soap, "tupleMember", &(a->ns3__batchValues::tupleMember), "ns3:memberDic"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__value(soap, "value", &(a->ns3__batchValues::value), "ns3:value"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__batchValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__batchValues, 0, sizeof(ns3__batchValues), 0, soap_copy_ns3__batchValues);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__batchValues::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__batchValues);
	if (this->soap_out(soap, tag?tag:"ns3:batchValues", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__batchValues::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__batchValues(soap, this, tag, type);
}

SOAP_FMAC3 ns3__batchValues * SOAP_FMAC4 soap_get_ns3__batchValues(struct soap *soap, ns3__batchValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__batchValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__batchValues * SOAP_FMAC2 soap_instantiate_ns3__batchValues(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__batchValues(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__batchValues, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__batchValues);
		if (size)
			*size = sizeof(ns3__batchValues);
		((ns3__batchValues*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__batchValues[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__batchValues);
		for (int i = 0; i < n; i++)
			((ns3__batchValues*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__batchValues*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__batchValues(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__batchValues %p -> %p\n", q, p));
	*(ns3__batchValues*)p = *(ns3__batchValues*)q;
}

void ns3__tupleValues::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__tupleValues::tuple = NULL;
	this->ns3__tupleValues::value = NULL;
	/* transient soap skipped */
}

void ns3__tupleValues::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns3__tupleValues::tuple);
	soap_serialize_PointerTons3__value(soap, &this->ns3__tupleValues::value);
	/* transient soap skipped */
}

int ns3__tupleValues::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__tupleValues(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__tupleValues(struct soap *soap, const char *tag, int id, const ns3__tupleValues *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__tupleValues), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tuple", -1, &(a->ns3__tupleValues::tuple), ""))
		return soap->error;
	if (a->ns3__tupleValues::value)
	{	if (soap_out_PointerTons3__value(soap, "value", -1, &a->ns3__tupleValues::value, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "value"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__tupleValues::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__tupleValues(soap, tag, this, type);
}

SOAP_FMAC3 ns3__tupleValues * SOAP_FMAC4 soap_in_ns3__tupleValues(struct soap *soap, const char *tag, ns3__tupleValues *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__tupleValues *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__tupleValues, sizeof(ns3__tupleValues), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__tupleValues)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__tupleValues *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tuple1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tuple1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "tuple", &(a->ns3__tupleValues::tuple), "xsd:string"))
				{	soap_flag_tuple1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__value(soap, "value", &(a->ns3__tupleValues::value), "ns3:value"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__tupleValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__tupleValues, 0, sizeof(ns3__tupleValues), 0, soap_copy_ns3__tupleValues);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__tupleValues::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__tupleValues);
	if (this->soap_out(soap, tag?tag:"ns3:tupleValues", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__tupleValues::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__tupleValues(soap, this, tag, type);
}

SOAP_FMAC3 ns3__tupleValues * SOAP_FMAC4 soap_get_ns3__tupleValues(struct soap *soap, ns3__tupleValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__tupleValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__tupleValues * SOAP_FMAC2 soap_instantiate_ns3__tupleValues(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__tupleValues(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__tupleValues, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__tupleValues);
		if (size)
			*size = sizeof(ns3__tupleValues);
		((ns3__tupleValues*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__tupleValues[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__tupleValues);
		for (int i = 0; i < n; i++)
			((ns3__tupleValues*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__tupleValues*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__tupleValues(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__tupleValues %p -> %p\n", q, p));
	*(ns3__tupleValues*)p = *(ns3__tupleValues*)q;
}

void ns3__entityValues::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__entityValues::entityShortName);
	soap_default_std__vectorTemplateOfPointerTons3__tupleValues(soap, &this->ns3__entityValues::tupleValues);
	/* transient soap skipped */
}

void ns3__entityValues::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns3__entityValues::entityShortName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__entityValues::entityShortName);
	soap_serialize_std__vectorTemplateOfPointerTons3__tupleValues(soap, &this->ns3__entityValues::tupleValues);
	/* transient soap skipped */
}

int ns3__entityValues::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__entityValues(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__entityValues(struct soap *soap, const char *tag, int id, const ns3__entityValues *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__entityValues), type))
		return soap->error;
	if (soap_out_std__string(soap, "entityShortName", -1, &(a->ns3__entityValues::entityShortName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__tupleValues(soap, "tupleValues", -1, &(a->ns3__entityValues::tupleValues), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__entityValues::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__entityValues(soap, tag, this, type);
}

SOAP_FMAC3 ns3__entityValues * SOAP_FMAC4 soap_in_ns3__entityValues(struct soap *soap, const char *tag, ns3__entityValues *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__entityValues *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__entityValues, sizeof(ns3__entityValues), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__entityValues)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__entityValues *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityShortName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityShortName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "entityShortName", &(a->ns3__entityValues::entityShortName), "xsd:string"))
				{	soap_flag_entityShortName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__tupleValues(soap, "tupleValues", &(a->ns3__entityValues::tupleValues), "ns3:tupleValues"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__entityValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__entityValues, 0, sizeof(ns3__entityValues), 0, soap_copy_ns3__entityValues);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityShortName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__entityValues::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__entityValues);
	if (this->soap_out(soap, tag?tag:"ns3:entityValues", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__entityValues::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__entityValues(soap, this, tag, type);
}

SOAP_FMAC3 ns3__entityValues * SOAP_FMAC4 soap_get_ns3__entityValues(struct soap *soap, ns3__entityValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__entityValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__entityValues * SOAP_FMAC2 soap_instantiate_ns3__entityValues(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__entityValues(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__entityValues, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__entityValues);
		if (size)
			*size = sizeof(ns3__entityValues);
		((ns3__entityValues*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__entityValues[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__entityValues);
		for (int i = 0; i < n; i++)
			((ns3__entityValues*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__entityValues*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__entityValues(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__entityValues %p -> %p\n", q, p));
	*(ns3__entityValues*)p = *(ns3__entityValues*)q;
}

void ns3__tupleMembers::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__tupleMembers::tuple = NULL;
	soap_default_std__string(soap, &this->ns3__tupleMembers::members);
	/* transient soap skipped */
}

void ns3__tupleMembers::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns3__tupleMembers::tuple);
	soap_embedded(soap, &this->ns3__tupleMembers::members, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__tupleMembers::members);
	/* transient soap skipped */
}

int ns3__tupleMembers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__tupleMembers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__tupleMembers(struct soap *soap, const char *tag, int id, const ns3__tupleMembers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__tupleMembers), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tuple", -1, &(a->ns3__tupleMembers::tuple), ""))
		return soap->error;
	if (soap_out_std__string(soap, "members", -1, &(a->ns3__tupleMembers::members), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__tupleMembers::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__tupleMembers(soap, tag, this, type);
}

SOAP_FMAC3 ns3__tupleMembers * SOAP_FMAC4 soap_in_ns3__tupleMembers(struct soap *soap, const char *tag, ns3__tupleMembers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__tupleMembers *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__tupleMembers, sizeof(ns3__tupleMembers), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__tupleMembers)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__tupleMembers *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tuple1 = 1;
	size_t soap_flag_members1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tuple1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "tuple", &(a->ns3__tupleMembers::tuple), "xsd:string"))
				{	soap_flag_tuple1--;
					continue;
				}
			if (soap_flag_members1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "members", &(a->ns3__tupleMembers::members), "xsd:string"))
				{	soap_flag_members1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__tupleMembers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__tupleMembers, 0, sizeof(ns3__tupleMembers), 0, soap_copy_ns3__tupleMembers);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_members1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__tupleMembers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__tupleMembers);
	if (this->soap_out(soap, tag?tag:"ns3:tupleMembers", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__tupleMembers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__tupleMembers(soap, this, tag, type);
}

SOAP_FMAC3 ns3__tupleMembers * SOAP_FMAC4 soap_get_ns3__tupleMembers(struct soap *soap, ns3__tupleMembers *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__tupleMembers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__tupleMembers * SOAP_FMAC2 soap_instantiate_ns3__tupleMembers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__tupleMembers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__tupleMembers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__tupleMembers);
		if (size)
			*size = sizeof(ns3__tupleMembers);
		((ns3__tupleMembers*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__tupleMembers[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__tupleMembers);
		for (int i = 0; i < n; i++)
			((ns3__tupleMembers*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__tupleMembers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__tupleMembers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__tupleMembers %p -> %p\n", q, p));
	*(ns3__tupleMembers*)p = *(ns3__tupleMembers*)q;
}

void ns3__setMembers::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns3__setMembers::setShortName);
	soap_default_std__vectorTemplateOfPointerTons3__tupleMembers(soap, &this->ns3__setMembers::tupleMembers);
	/* transient soap skipped */
}

void ns3__setMembers::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns3__setMembers::setShortName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns3__setMembers::setShortName);
	soap_serialize_std__vectorTemplateOfPointerTons3__tupleMembers(soap, &this->ns3__setMembers::tupleMembers);
	/* transient soap skipped */
}

int ns3__setMembers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__setMembers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__setMembers(struct soap *soap, const char *tag, int id, const ns3__setMembers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__setMembers), type))
		return soap->error;
	if (soap_out_std__string(soap, "setShortName", -1, &(a->ns3__setMembers::setShortName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__tupleMembers(soap, "tupleMembers", -1, &(a->ns3__setMembers::tupleMembers), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__setMembers::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__setMembers(soap, tag, this, type);
}

SOAP_FMAC3 ns3__setMembers * SOAP_FMAC4 soap_in_ns3__setMembers(struct soap *soap, const char *tag, ns3__setMembers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__setMembers *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__setMembers, sizeof(ns3__setMembers), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__setMembers)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__setMembers *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_setShortName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_setShortName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "setShortName", &(a->ns3__setMembers::setShortName), "xsd:string"))
				{	soap_flag_setShortName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__tupleMembers(soap, "tupleMembers", &(a->ns3__setMembers::tupleMembers), "ns3:tupleMembers"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__setMembers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__setMembers, 0, sizeof(ns3__setMembers), 0, soap_copy_ns3__setMembers);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_setShortName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__setMembers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__setMembers);
	if (this->soap_out(soap, tag?tag:"ns3:setMembers", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__setMembers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__setMembers(soap, this, tag, type);
}

SOAP_FMAC3 ns3__setMembers * SOAP_FMAC4 soap_get_ns3__setMembers(struct soap *soap, ns3__setMembers *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__setMembers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__setMembers * SOAP_FMAC2 soap_instantiate_ns3__setMembers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__setMembers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__setMembers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__setMembers);
		if (size)
			*size = sizeof(ns3__setMembers);
		((ns3__setMembers*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__setMembers[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__setMembers);
		for (int i = 0; i < n; i++)
			((ns3__setMembers*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__setMembers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__setMembers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__setMembers %p -> %p\n", q, p));
	*(ns3__setMembers*)p = *(ns3__setMembers*)q;
}

void ns3__tupleValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons3__memberDic(soap, &this->ns3__tupleValue::tupleMember);
	this->ns3__tupleValue::value = NULL;
	/* transient soap skipped */
}

void ns3__tupleValue::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons3__memberDic(soap, &this->ns3__tupleValue::tupleMember);
	soap_serialize_PointerTons3__value(soap, &this->ns3__tupleValue::value);
	/* transient soap skipped */
}

int ns3__tupleValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__tupleValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__tupleValue(struct soap *soap, const char *tag, int id, const ns3__tupleValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__tupleValue), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons3__memberDic(soap, "tupleMember", -1, &(a->ns3__tupleValue::tupleMember), ""))
		return soap->error;
	if (a->ns3__tupleValue::value)
	{	if (soap_out_PointerTons3__value(soap, "value", -1, &a->ns3__tupleValue::value, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "value"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__tupleValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__tupleValue(soap, tag, this, type);
}

SOAP_FMAC3 ns3__tupleValue * SOAP_FMAC4 soap_in_ns3__tupleValue(struct soap *soap, const char *tag, ns3__tupleValue *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__tupleValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__tupleValue, sizeof(ns3__tupleValue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__tupleValue)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__tupleValue *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons3__memberDic(soap, "tupleMember", &(a->ns3__tupleValue::tupleMember), "ns3:memberDic"))
					continue;
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__value(soap, "value", &(a->ns3__tupleValue::value), "ns3:value"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__tupleValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__tupleValue, 0, sizeof(ns3__tupleValue), 0, soap_copy_ns3__tupleValue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__tupleValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__tupleValue);
	if (this->soap_out(soap, tag?tag:"ns3:tupleValue", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__tupleValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__tupleValue(soap, this, tag, type);
}

SOAP_FMAC3 ns3__tupleValue * SOAP_FMAC4 soap_get_ns3__tupleValue(struct soap *soap, ns3__tupleValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__tupleValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__tupleValue * SOAP_FMAC2 soap_instantiate_ns3__tupleValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__tupleValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__tupleValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__tupleValue);
		if (size)
			*size = sizeof(ns3__tupleValue);
		((ns3__tupleValue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__tupleValue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__tupleValue);
		for (int i = 0; i < n; i++)
			((ns3__tupleValue*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__tupleValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__tupleValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__tupleValue %p -> %p\n", q, p));
	*(ns3__tupleValue*)p = *(ns3__tupleValue*)q;
}

void ns3__memberDic::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__memberDic::id = NULL;
	soap_default_ns2__name(soap, &this->ns3__memberDic::code);
	this->ns3__memberDic::description = NULL;
	/* transient soap skipped */
}

void ns3__memberDic::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->ns3__memberDic::id);
	soap_embedded(soap, &this->ns3__memberDic::code, SOAP_TYPE_ns2__name);
	soap_serialize_ns2__name(soap, &this->ns3__memberDic::code);
	soap_serialize_PointerTons2__description(soap, &this->ns3__memberDic::description);
	/* transient soap skipped */
}

int ns3__memberDic::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__memberDic(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__memberDic(struct soap *soap, const char *tag, int id, const ns3__memberDic *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__memberDic), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "id", -1, &(a->ns3__memberDic::id), ""))
		return soap->error;
	if (soap_out_ns2__name(soap, "code", -1, &(a->ns3__memberDic::code), ""))
		return soap->error;
	if (soap_out_PointerTons2__description(soap, "description", -1, &(a->ns3__memberDic::description), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__memberDic::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__memberDic(soap, tag, this, type);
}

SOAP_FMAC3 ns3__memberDic * SOAP_FMAC4 soap_in_ns3__memberDic(struct soap *soap, const char *tag, ns3__memberDic *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__memberDic *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__memberDic, sizeof(ns3__memberDic), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__memberDic)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__memberDic *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "id", &(a->ns3__memberDic::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__name(soap, "code", &(a->ns3__memberDic::code), "ns2:name"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__description(soap, "description", &(a->ns3__memberDic::description), "ns2:description"))
				{	soap_flag_description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__memberDic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__memberDic, 0, sizeof(ns3__memberDic), 0, soap_copy_ns3__memberDic);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__memberDic::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__memberDic);
	if (this->soap_out(soap, tag?tag:"ns3:memberDic", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__memberDic::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__memberDic(soap, this, tag, type);
}

SOAP_FMAC3 ns3__memberDic * SOAP_FMAC4 soap_get_ns3__memberDic(struct soap *soap, ns3__memberDic *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__memberDic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__memberDic * SOAP_FMAC2 soap_instantiate_ns3__memberDic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__memberDic(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__memberDic, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__memberDic);
		if (size)
			*size = sizeof(ns3__memberDic);
		((ns3__memberDic*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__memberDic[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__memberDic);
		for (int i = 0; i < n; i++)
			((ns3__memberDic*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__memberDic*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__memberDic(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__memberDic %p -> %p\n", q, p));
	*(ns3__memberDic*)p = *(ns3__memberDic*)q;
}

void ns3__modelInstance::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__modelInstance::id = NULL;
	soap_default_int(soap, &this->ns3__modelInstance::idModelSpec);
	soap_default_int(soap, &this->ns3__modelInstance::idModelData);
	this->ns3__modelInstance::shortName = NULL;
	this->ns3__modelInstance::name = NULL;
	this->ns3__modelInstance::description = NULL;
	/* transient soap skipped */
}

void ns3__modelInstance::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->ns3__modelInstance::id);
	soap_embedded(soap, &this->ns3__modelInstance::idModelSpec, SOAP_TYPE_int);
	soap_embedded(soap, &this->ns3__modelInstance::idModelData, SOAP_TYPE_int);
	soap_serialize_PointerTons2__shortName(soap, &this->ns3__modelInstance::shortName);
	soap_serialize_PointerTons2__name(soap, &this->ns3__modelInstance::name);
	soap_serialize_PointerTons2__description(soap, &this->ns3__modelInstance::description);
	/* transient soap skipped */
}

int ns3__modelInstance::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__modelInstance(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__modelInstance(struct soap *soap, const char *tag, int id, const ns3__modelInstance *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__modelInstance), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "id", -1, &(a->ns3__modelInstance::id), ""))
		return soap->error;
	if (soap_out_int(soap, "idModelSpec", -1, &(a->ns3__modelInstance::idModelSpec), ""))
		return soap->error;
	if (soap_out_int(soap, "idModelData", -1, &(a->ns3__modelInstance::idModelData), ""))
		return soap->error;
	if (soap_out_PointerTons2__shortName(soap, "shortName", -1, &(a->ns3__modelInstance::shortName), ""))
		return soap->error;
	if (soap_out_PointerTons2__name(soap, "name", -1, &(a->ns3__modelInstance::name), ""))
		return soap->error;
	if (soap_out_PointerTons2__description(soap, "description", -1, &(a->ns3__modelInstance::description), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__modelInstance::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__modelInstance(soap, tag, this, type);
}

SOAP_FMAC3 ns3__modelInstance * SOAP_FMAC4 soap_in_ns3__modelInstance(struct soap *soap, const char *tag, ns3__modelInstance *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__modelInstance *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__modelInstance, sizeof(ns3__modelInstance), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__modelInstance)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__modelInstance *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_idModelSpec1 = 1;
	size_t soap_flag_idModelData1 = 1;
	size_t soap_flag_shortName1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "id", &(a->ns3__modelInstance::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_idModelSpec1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModelSpec", &(a->ns3__modelInstance::idModelSpec), "xsd:int"))
				{	soap_flag_idModelSpec1--;
					continue;
				}
			if (soap_flag_idModelData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idModelData", &(a->ns3__modelInstance::idModelData), "xsd:int"))
				{	soap_flag_idModelData1--;
					continue;
				}
			if (soap_flag_shortName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__shortName(soap, "shortName", &(a->ns3__modelInstance::shortName), "ns2:shortName"))
				{	soap_flag_shortName1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__name(soap, "name", &(a->ns3__modelInstance::name), "ns2:name"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__description(soap, "description", &(a->ns3__modelInstance::description), "ns2:description"))
				{	soap_flag_description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__modelInstance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__modelInstance, 0, sizeof(ns3__modelInstance), 0, soap_copy_ns3__modelInstance);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idModelSpec1 > 0 || soap_flag_idModelData1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__modelInstance::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__modelInstance);
	if (this->soap_out(soap, tag?tag:"ns3:modelInstance", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__modelInstance::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__modelInstance(soap, this, tag, type);
}

SOAP_FMAC3 ns3__modelInstance * SOAP_FMAC4 soap_get_ns3__modelInstance(struct soap *soap, ns3__modelInstance *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__modelInstance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__modelInstance * SOAP_FMAC2 soap_instantiate_ns3__modelInstance(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__modelInstance(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__modelInstance, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__modelInstance);
		if (size)
			*size = sizeof(ns3__modelInstance);
		((ns3__modelInstance*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__modelInstance[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__modelInstance);
		for (int i = 0; i < n; i++)
			((ns3__modelInstance*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__modelInstance*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__modelInstance(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__modelInstance %p -> %p\n", q, p));
	*(ns3__modelInstance*)p = *(ns3__modelInstance*)q;
}

void ns3__modelData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__modelData::id = NULL;
	soap_default_std__vectorTemplateOfint(soap, &this->ns3__modelData::idModelSpec);
	this->ns3__modelData::idParent = NULL;
	this->ns3__modelData::description = NULL;
	soap_default_ns2__status(soap, &this->ns3__modelData::status);
	/* transient soap skipped */
}

void ns3__modelData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->ns3__modelData::id);
	soap_serialize_std__vectorTemplateOfint(soap, &this->ns3__modelData::idModelSpec);
	soap_serialize_PointerToint(soap, &this->ns3__modelData::idParent);
	soap_serialize_PointerTons2__description(soap, &this->ns3__modelData::description);
	/* transient soap skipped */
}

int ns3__modelData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__modelData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__modelData(struct soap *soap, const char *tag, int id, const ns3__modelData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__modelData), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "id", -1, &(a->ns3__modelData::id), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "idModelSpec", -1, &(a->ns3__modelData::idModelSpec), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "idParent", -1, &(a->ns3__modelData::idParent), ""))
		return soap->error;
	if (soap_out_PointerTons2__description(soap, "description", -1, &(a->ns3__modelData::description), ""))
		return soap->error;
	if (soap_out_ns2__status(soap, "status", -1, &(a->ns3__modelData::status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__modelData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__modelData(soap, tag, this, type);
}

SOAP_FMAC3 ns3__modelData * SOAP_FMAC4 soap_in_ns3__modelData(struct soap *soap, const char *tag, ns3__modelData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__modelData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__modelData, sizeof(ns3__modelData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__modelData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__modelData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_idParent1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "id", &(a->ns3__modelData::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "idModelSpec", &(a->ns3__modelData::idModelSpec), "xsd:int"))
					continue;
			if (soap_flag_idParent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "idParent", &(a->ns3__modelData::idParent), "xsd:int"))
				{	soap_flag_idParent1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__description(soap, "description", &(a->ns3__modelData::description), "ns2:description"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__status(soap, "status", &(a->ns3__modelData::status), "ns2:status"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__modelData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__modelData, 0, sizeof(ns3__modelData), 0, soap_copy_ns3__modelData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns3__modelData::idModelSpec.size() < 1 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__modelData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__modelData);
	if (this->soap_out(soap, tag?tag:"ns3:modelData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__modelData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__modelData(soap, this, tag, type);
}

SOAP_FMAC3 ns3__modelData * SOAP_FMAC4 soap_get_ns3__modelData(struct soap *soap, ns3__modelData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__modelData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__modelData * SOAP_FMAC2 soap_instantiate_ns3__modelData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__modelData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__modelData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__modelData);
		if (size)
			*size = sizeof(ns3__modelData);
		((ns3__modelData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__modelData[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__modelData);
		for (int i = 0; i < n; i++)
			((ns3__modelData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__modelData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__modelData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__modelData %p -> %p\n", q, p));
	*(ns3__modelData*)p = *(ns3__modelData*)q;
}

void ns2__iteratorContainer::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfint(soap, &this->ns2__iteratorContainer::idSetSpec);
	/* transient soap skipped */
}

void ns2__iteratorContainer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &this->ns2__iteratorContainer::idSetSpec);
	/* transient soap skipped */
}

int ns2__iteratorContainer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__iteratorContainer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__iteratorContainer(struct soap *soap, const char *tag, int id, const ns2__iteratorContainer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__iteratorContainer), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "idSetSpec", -1, &(a->ns2__iteratorContainer::idSetSpec), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__iteratorContainer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__iteratorContainer(soap, tag, this, type);
}

SOAP_FMAC3 ns2__iteratorContainer * SOAP_FMAC4 soap_in_ns2__iteratorContainer(struct soap *soap, const char *tag, ns2__iteratorContainer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__iteratorContainer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__iteratorContainer, sizeof(ns2__iteratorContainer), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__iteratorContainer)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__iteratorContainer *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "idSetSpec", &(a->ns2__iteratorContainer::idSetSpec), "xsd:int"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__iteratorContainer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__iteratorContainer, 0, sizeof(ns2__iteratorContainer), 0, soap_copy_ns2__iteratorContainer);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__iteratorContainer::idSetSpec.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__iteratorContainer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__iteratorContainer);
	if (this->soap_out(soap, tag?tag:"ns2:iteratorContainer", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__iteratorContainer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__iteratorContainer(soap, this, tag, type);
}

SOAP_FMAC3 ns2__iteratorContainer * SOAP_FMAC4 soap_get_ns2__iteratorContainer(struct soap *soap, ns2__iteratorContainer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__iteratorContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__iteratorContainer * SOAP_FMAC2 soap_instantiate_ns2__iteratorContainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__iteratorContainer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__iteratorContainer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__iteratorContainer);
		if (size)
			*size = sizeof(ns2__iteratorContainer);
		((ns2__iteratorContainer*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__iteratorContainer[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__iteratorContainer);
		for (int i = 0; i < n; i++)
			((ns2__iteratorContainer*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__iteratorContainer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__iteratorContainer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__iteratorContainer %p -> %p\n", q, p));
	*(ns2__iteratorContainer*)p = *(ns2__iteratorContainer*)q;
}

void ns2__entitySpec::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__entitySpec::id = NULL;
	soap_default_ns2__shortName(soap, &this->ns2__entitySpec::shortName);
	this->ns2__entitySpec::name = NULL;
	this->ns2__entitySpec::description = NULL;
	this->ns2__entitySpec::idLowerBound = NULL;
	this->ns2__entitySpec::idUpperBound = NULL;
	this->ns2__entitySpec::constantValue = NULL;
	this->ns2__entitySpec::iteratorContainer = NULL;
	this->ns2__entitySpec::role = NULL;
	soap_default_ns2__mathType(soap, &this->ns2__entitySpec::mathType);
	this->ns2__entitySpec::unit = NULL;
	this->ns2__entitySpec::formula = NULL;
	this->ns2__entitySpec::source = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__entitySpec::group);
	this->ns2__entitySpec::modelSpec = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__entitySpec::batch);
	/* transient soap skipped */
}

void ns2__entitySpec::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->ns2__entitySpec::id);
	soap_embedded(soap, &this->ns2__entitySpec::shortName, SOAP_TYPE_ns2__shortName);
	soap_serialize_ns2__shortName(soap, &this->ns2__entitySpec::shortName);
	soap_serialize_PointerTons2__name(soap, &this->ns2__entitySpec::name);
	soap_serialize_PointerTons2__description(soap, &this->ns2__entitySpec::description);
	soap_serialize_PointerToint(soap, &this->ns2__entitySpec::idLowerBound);
	soap_serialize_PointerToint(soap, &this->ns2__entitySpec::idUpperBound);
	soap_serialize_PointerTodouble(soap, &this->ns2__entitySpec::constantValue);
	soap_serialize_PointerTons2__iteratorContainer(soap, &this->ns2__entitySpec::iteratorContainer);
	soap_serialize_PointerTons2__entityRole(soap, &this->ns2__entitySpec::role);
	soap_serialize_PointerTostd__string(soap, &this->ns2__entitySpec::unit);
	soap_serialize_PointerTostd__string(soap, &this->ns2__entitySpec::formula);
	soap_serialize_PointerTostd__string(soap, &this->ns2__entitySpec::source);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__entitySpec::group);
	soap_serialize_PointerTostd__string(soap, &this->ns2__entitySpec::modelSpec);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__entitySpec::batch);
	/* transient soap skipped */
}

int ns2__entitySpec::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__entitySpec(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__entitySpec(struct soap *soap, const char *tag, int id, const ns2__entitySpec *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__entitySpec), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "id", -1, &(a->ns2__entitySpec::id), ""))
		return soap->error;
	if (soap_out_ns2__shortName(soap, "shortName", -1, &(a->ns2__entitySpec::shortName), ""))
		return soap->error;
	if (soap_out_PointerTons2__name(soap, "name", -1, &(a->ns2__entitySpec::name), ""))
		return soap->error;
	if (soap_out_PointerTons2__description(soap, "description", -1, &(a->ns2__entitySpec::description), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "idLowerBound", -1, &(a->ns2__entitySpec::idLowerBound), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "idUpperBound", -1, &(a->ns2__entitySpec::idUpperBound), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "constantValue", -1, &(a->ns2__entitySpec::constantValue), ""))
		return soap->error;
	if (soap_out_PointerTons2__iteratorContainer(soap, "iteratorContainer", -1, &(a->ns2__entitySpec::iteratorContainer), ""))
		return soap->error;
	if (soap_out_PointerTons2__entityRole(soap, "role", -1, &(a->ns2__entitySpec::role), ""))
		return soap->error;
	if (soap_out_ns2__mathType(soap, "mathType", -1, &(a->ns2__entitySpec::mathType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "unit", -1, &(a->ns2__entitySpec::unit), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "formula", -1, &(a->ns2__entitySpec::formula), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "source", -1, &(a->ns2__entitySpec::source), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "group", -1, &(a->ns2__entitySpec::group), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "modelSpec", -1, &(a->ns2__entitySpec::modelSpec), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "batch", -1, &(a->ns2__entitySpec::batch), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__entitySpec::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__entitySpec(soap, tag, this, type);
}

SOAP_FMAC3 ns2__entitySpec * SOAP_FMAC4 soap_in_ns2__entitySpec(struct soap *soap, const char *tag, ns2__entitySpec *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__entitySpec *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__entitySpec, sizeof(ns2__entitySpec), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__entitySpec)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__entitySpec *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_shortName1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_idLowerBound1 = 1;
	size_t soap_flag_idUpperBound1 = 1;
	size_t soap_flag_constantValue1 = 1;
	size_t soap_flag_iteratorContainer1 = 1;
	size_t soap_flag_role1 = 1;
	size_t soap_flag_mathType1 = 1;
	size_t soap_flag_unit1 = 1;
	size_t soap_flag_formula1 = 1;
	size_t soap_flag_source1 = 1;
	size_t soap_flag_modelSpec1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "id", &(a->ns2__entitySpec::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_shortName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__shortName(soap, "shortName", &(a->ns2__entitySpec::shortName), "ns2:shortName"))
				{	soap_flag_shortName1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__name(soap, "name", &(a->ns2__entitySpec::name), "ns2:name"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__description(soap, "description", &(a->ns2__entitySpec::description), "ns2:description"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_idLowerBound1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "idLowerBound", &(a->ns2__entitySpec::idLowerBound), "xsd:int"))
				{	soap_flag_idLowerBound1--;
					continue;
				}
			if (soap_flag_idUpperBound1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "idUpperBound", &(a->ns2__entitySpec::idUpperBound), "xsd:int"))
				{	soap_flag_idUpperBound1--;
					continue;
				}
			if (soap_flag_constantValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "constantValue", &(a->ns2__entitySpec::constantValue), "xsd:double"))
				{	soap_flag_constantValue1--;
					continue;
				}
			if (soap_flag_iteratorContainer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__iteratorContainer(soap, "iteratorContainer", &(a->ns2__entitySpec::iteratorContainer), "ns2:iteratorContainer"))
				{	soap_flag_iteratorContainer1--;
					continue;
				}
			if (soap_flag_role1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__entityRole(soap, "role", &(a->ns2__entitySpec::role), "ns2:entityRole"))
				{	soap_flag_role1--;
					continue;
				}
			if (soap_flag_mathType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__mathType(soap, "mathType", &(a->ns2__entitySpec::mathType), "ns2:mathType"))
				{	soap_flag_mathType1--;
					continue;
				}
			if (soap_flag_unit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "unit", &(a->ns2__entitySpec::unit), "xsd:string"))
				{	soap_flag_unit1--;
					continue;
				}
			if (soap_flag_formula1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "formula", &(a->ns2__entitySpec::formula), "xsd:string"))
				{	soap_flag_formula1--;
					continue;
				}
			if (soap_flag_source1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "source", &(a->ns2__entitySpec::source), "xsd:string"))
				{	soap_flag_source1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "group", &(a->ns2__entitySpec::group), "xsd:string"))
					continue;
			if (soap_flag_modelSpec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "modelSpec", &(a->ns2__entitySpec::modelSpec), "xsd:string"))
				{	soap_flag_modelSpec1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "batch", &(a->ns2__entitySpec::batch), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__entitySpec *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__entitySpec, 0, sizeof(ns2__entitySpec), 0, soap_copy_ns2__entitySpec);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_shortName1 > 0 || soap_flag_mathType1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__entitySpec::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__entitySpec);
	if (this->soap_out(soap, tag?tag:"ns2:entitySpec", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__entitySpec::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__entitySpec(soap, this, tag, type);
}

SOAP_FMAC3 ns2__entitySpec * SOAP_FMAC4 soap_get_ns2__entitySpec(struct soap *soap, ns2__entitySpec *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__entitySpec(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__entitySpec * SOAP_FMAC2 soap_instantiate_ns2__entitySpec(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__entitySpec(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__entitySpec, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__entitySpec);
		if (size)
			*size = sizeof(ns2__entitySpec);
		((ns2__entitySpec*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__entitySpec[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__entitySpec);
		for (int i = 0; i < n; i++)
			((ns2__entitySpec*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__entitySpec*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__entitySpec(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__entitySpec %p -> %p\n", q, p));
	*(ns2__entitySpec*)p = *(ns2__entitySpec*)q;
}

void ns2__setSpec::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__setSpec::id = NULL;
	this->ns2__setSpec::idParent = NULL;
	soap_default_ns2__shortName(soap, &this->ns2__setSpec::shortName);
	this->ns2__setSpec::name = NULL;
	this->ns2__setSpec::description = NULL;
	soap_default_ns2__setSpecType(soap, &this->ns2__setSpec::type);
	this->ns2__setSpec::idx = NULL;
	this->ns2__setSpec::iteratorContainer = NULL;
	/* transient soap skipped */
}

void ns2__setSpec::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->ns2__setSpec::id);
	soap_serialize_PointerToint(soap, &this->ns2__setSpec::idParent);
	soap_embedded(soap, &this->ns2__setSpec::shortName, SOAP_TYPE_ns2__shortName);
	soap_serialize_ns2__shortName(soap, &this->ns2__setSpec::shortName);
	soap_serialize_PointerTons2__name(soap, &this->ns2__setSpec::name);
	soap_serialize_PointerTons2__description(soap, &this->ns2__setSpec::description);
	soap_serialize_PointerTostd__string(soap, &this->ns2__setSpec::idx);
	soap_serialize_PointerTons2__iteratorContainer(soap, &this->ns2__setSpec::iteratorContainer);
	/* transient soap skipped */
}

int ns2__setSpec::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__setSpec(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__setSpec(struct soap *soap, const char *tag, int id, const ns2__setSpec *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__setSpec), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "id", -1, &(a->ns2__setSpec::id), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "idParent", -1, &(a->ns2__setSpec::idParent), ""))
		return soap->error;
	if (soap_out_ns2__shortName(soap, "shortName", -1, &(a->ns2__setSpec::shortName), ""))
		return soap->error;
	if (soap_out_PointerTons2__name(soap, "name", -1, &(a->ns2__setSpec::name), ""))
		return soap->error;
	if (soap_out_PointerTons2__description(soap, "description", -1, &(a->ns2__setSpec::description), ""))
		return soap->error;
	if (soap_out_ns2__setSpecType(soap, "type", -1, &(a->ns2__setSpec::type), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "idx", -1, &(a->ns2__setSpec::idx), ""))
		return soap->error;
	if (soap_out_PointerTons2__iteratorContainer(soap, "iteratorContainer", -1, &(a->ns2__setSpec::iteratorContainer), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__setSpec::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__setSpec(soap, tag, this, type);
}

SOAP_FMAC3 ns2__setSpec * SOAP_FMAC4 soap_in_ns2__setSpec(struct soap *soap, const char *tag, ns2__setSpec *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__setSpec *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__setSpec, sizeof(ns2__setSpec), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__setSpec)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__setSpec *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_idParent1 = 1;
	size_t soap_flag_shortName1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_idx1 = 1;
	size_t soap_flag_iteratorContainer1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "id", &(a->ns2__setSpec::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_idParent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "idParent", &(a->ns2__setSpec::idParent), "xsd:int"))
				{	soap_flag_idParent1--;
					continue;
				}
			if (soap_flag_shortName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__shortName(soap, "shortName", &(a->ns2__setSpec::shortName), "ns2:shortName"))
				{	soap_flag_shortName1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__name(soap, "name", &(a->ns2__setSpec::name), "ns2:name"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__description(soap, "description", &(a->ns2__setSpec::description), "ns2:description"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__setSpecType(soap, "type", &(a->ns2__setSpec::type), "ns2:setSpecType"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_idx1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "idx", &(a->ns2__setSpec::idx), "xsd:string"))
				{	soap_flag_idx1--;
					continue;
				}
			if (soap_flag_iteratorContainer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__iteratorContainer(soap, "iteratorContainer", &(a->ns2__setSpec::iteratorContainer), "ns2:iteratorContainer"))
				{	soap_flag_iteratorContainer1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__setSpec *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__setSpec, 0, sizeof(ns2__setSpec), 0, soap_copy_ns2__setSpec);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_shortName1 > 0 || soap_flag_type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__setSpec::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__setSpec);
	if (this->soap_out(soap, tag?tag:"ns2:setSpec", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__setSpec::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__setSpec(soap, this, tag, type);
}

SOAP_FMAC3 ns2__setSpec * SOAP_FMAC4 soap_get_ns2__setSpec(struct soap *soap, ns2__setSpec *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__setSpec(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__setSpec * SOAP_FMAC2 soap_instantiate_ns2__setSpec(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__setSpec(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__setSpec, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__setSpec);
		if (size)
			*size = sizeof(ns2__setSpec);
		((ns2__setSpec*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__setSpec[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__setSpec);
		for (int i = 0; i < n; i++)
			((ns2__setSpec*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__setSpec*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__setSpec(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__setSpec %p -> %p\n", q, p));
	*(ns2__setSpec*)p = *(ns2__setSpec*)q;
}

void ns2__modelSpec::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__modelSpec::id = NULL;
	soap_default_ns2__shortName(soap, &this->ns2__modelSpec::shortName);
	this->ns2__modelSpec::name = NULL;
	this->ns2__modelSpec::description = NULL;
	soap_default_ns2__status(soap, &this->ns2__modelSpec::status);
	soap_default_std__vectorTemplateOfPointerTons2__setSpec(soap, &this->ns2__modelSpec::setSpec);
	soap_default_std__vectorTemplateOfPointerTons2__entitySpec(soap, &this->ns2__modelSpec::entitySpec);
	/* transient soap skipped */
}

void ns2__modelSpec::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->ns2__modelSpec::id);
	soap_embedded(soap, &this->ns2__modelSpec::shortName, SOAP_TYPE_ns2__shortName);
	soap_serialize_ns2__shortName(soap, &this->ns2__modelSpec::shortName);
	soap_serialize_PointerTons2__name(soap, &this->ns2__modelSpec::name);
	soap_serialize_PointerTons2__description(soap, &this->ns2__modelSpec::description);
	soap_serialize_std__vectorTemplateOfPointerTons2__setSpec(soap, &this->ns2__modelSpec::setSpec);
	soap_serialize_std__vectorTemplateOfPointerTons2__entitySpec(soap, &this->ns2__modelSpec::entitySpec);
	/* transient soap skipped */
}

int ns2__modelSpec::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__modelSpec(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__modelSpec(struct soap *soap, const char *tag, int id, const ns2__modelSpec *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__modelSpec), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "id", -1, &(a->ns2__modelSpec::id), ""))
		return soap->error;
	if (soap_out_ns2__shortName(soap, "shortName", -1, &(a->ns2__modelSpec::shortName), ""))
		return soap->error;
	if (soap_out_PointerTons2__name(soap, "name", -1, &(a->ns2__modelSpec::name), ""))
		return soap->error;
	if (soap_out_PointerTons2__description(soap, "description", -1, &(a->ns2__modelSpec::description), ""))
		return soap->error;
	if (soap_out_ns2__status(soap, "status", -1, &(a->ns2__modelSpec::status), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__setSpec(soap, "setSpec", -1, &(a->ns2__modelSpec::setSpec), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__entitySpec(soap, "entitySpec", -1, &(a->ns2__modelSpec::entitySpec), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__modelSpec::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__modelSpec(soap, tag, this, type);
}

SOAP_FMAC3 ns2__modelSpec * SOAP_FMAC4 soap_in_ns2__modelSpec(struct soap *soap, const char *tag, ns2__modelSpec *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__modelSpec *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__modelSpec, sizeof(ns2__modelSpec), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__modelSpec)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__modelSpec *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_shortName1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "id", &(a->ns2__modelSpec::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_shortName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__shortName(soap, "shortName", &(a->ns2__modelSpec::shortName), "ns2:shortName"))
				{	soap_flag_shortName1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__name(soap, "name", &(a->ns2__modelSpec::name), "ns2:name"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons2__description(soap, "description", &(a->ns2__modelSpec::description), "ns2:description"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__status(soap, "status", &(a->ns2__modelSpec::status), "ns2:status"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__setSpec(soap, "setSpec", &(a->ns2__modelSpec::setSpec), "ns2:setSpec"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__entitySpec(soap, "entitySpec", &(a->ns2__modelSpec::entitySpec), "ns2:entitySpec"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__modelSpec *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__modelSpec, 0, sizeof(ns2__modelSpec), 0, soap_copy_ns2__modelSpec);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_shortName1 > 0 || soap_flag_status1 > 0 || a->ns2__modelSpec::setSpec.size() < 1 || a->ns2__modelSpec::entitySpec.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__modelSpec::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__modelSpec);
	if (this->soap_out(soap, tag?tag:"ns2:modelSpec", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__modelSpec::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__modelSpec(soap, this, tag, type);
}

SOAP_FMAC3 ns2__modelSpec * SOAP_FMAC4 soap_get_ns2__modelSpec(struct soap *soap, ns2__modelSpec *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__modelSpec(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__modelSpec * SOAP_FMAC2 soap_instantiate_ns2__modelSpec(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__modelSpec(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__modelSpec, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__modelSpec);
		if (size)
			*size = sizeof(ns2__modelSpec);
		((ns2__modelSpec*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__modelSpec[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__modelSpec);
		for (int i = 0; i < n; i++)
			((ns2__modelSpec*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__modelSpec*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__modelSpec(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__modelSpec %p -> %p\n", q, p));
	*(ns2__modelSpec*)p = *(ns2__modelSpec*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSolverStatus(struct soap *soap, struct __ns1__getSolverStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getSolverStatusRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSolverStatus(struct soap *soap, const struct __ns1__getSolverStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getSolverStatusRequest(soap, &a->ns1__getSolverStatusRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSolverStatus(struct soap *soap, const char *tag, int id, const struct __ns1__getSolverStatus *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getSolverStatusRequest(soap, "ns1:getSolverStatusRequest", -1, &a->ns1__getSolverStatusRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSolverStatus * SOAP_FMAC4 soap_in___ns1__getSolverStatus(struct soap *soap, const char *tag, struct __ns1__getSolverStatus *a, const char *type)
{
	size_t soap_flag_ns1__getSolverStatusRequest = 1;
	short soap_flag;
	a = (struct __ns1__getSolverStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSolverStatus, sizeof(struct __ns1__getSolverStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSolverStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getSolverStatusRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getSolverStatusRequest(soap, "ns1:getSolverStatusRequest", &a->ns1__getSolverStatusRequest, ""))
				{	soap_flag_ns1__getSolverStatusRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSolverStatus(struct soap *soap, const struct __ns1__getSolverStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSolverStatus(soap, tag?tag:"-ns1:getSolverStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSolverStatus * SOAP_FMAC4 soap_get___ns1__getSolverStatus(struct soap *soap, struct __ns1__getSolverStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSolverStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSolverStatus * SOAP_FMAC2 soap_instantiate___ns1__getSolverStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSolverStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSolverStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSolverStatus);
		if (size)
			*size = sizeof(struct __ns1__getSolverStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSolverStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getSolverStatus);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getSolverStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSolverStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSolverStatus %p -> %p\n", q, p));
	*(struct __ns1__getSolverStatus*)p = *(struct __ns1__getSolverStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__storeEntityValues(struct soap *soap, struct __ns1__storeEntityValues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__storeEntityValuesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__storeEntityValues(struct soap *soap, const struct __ns1__storeEntityValues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__storeEntityValuesRequest(soap, &a->ns1__storeEntityValuesRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__storeEntityValues(struct soap *soap, const char *tag, int id, const struct __ns1__storeEntityValues *a, const char *type)
{
	if (soap_out_PointerTo_ns1__storeEntityValuesRequest(soap, "ns1:storeEntityValuesRequest", -1, &a->ns1__storeEntityValuesRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__storeEntityValues * SOAP_FMAC4 soap_in___ns1__storeEntityValues(struct soap *soap, const char *tag, struct __ns1__storeEntityValues *a, const char *type)
{
	size_t soap_flag_ns1__storeEntityValuesRequest = 1;
	short soap_flag;
	a = (struct __ns1__storeEntityValues *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__storeEntityValues, sizeof(struct __ns1__storeEntityValues), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__storeEntityValues(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__storeEntityValuesRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__storeEntityValuesRequest(soap, "ns1:storeEntityValuesRequest", &a->ns1__storeEntityValuesRequest, ""))
				{	soap_flag_ns1__storeEntityValuesRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__storeEntityValues(struct soap *soap, const struct __ns1__storeEntityValues *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__storeEntityValues(soap, tag?tag:"-ns1:storeEntityValues", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__storeEntityValues * SOAP_FMAC4 soap_get___ns1__storeEntityValues(struct soap *soap, struct __ns1__storeEntityValues *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__storeEntityValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__storeEntityValues * SOAP_FMAC2 soap_instantiate___ns1__storeEntityValues(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__storeEntityValues(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__storeEntityValues, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__storeEntityValues);
		if (size)
			*size = sizeof(struct __ns1__storeEntityValues);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__storeEntityValues[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__storeEntityValues);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__storeEntityValues*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__storeEntityValues(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__storeEntityValues %p -> %p\n", q, p));
	*(struct __ns1__storeEntityValues*)p = *(struct __ns1__storeEntityValues*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeSetMembers(struct soap *soap, struct __ns1__removeSetMembers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeSetMembersRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeSetMembers(struct soap *soap, const struct __ns1__removeSetMembers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__removeSetMembersRequest(soap, &a->ns1__removeSetMembersRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeSetMembers(struct soap *soap, const char *tag, int id, const struct __ns1__removeSetMembers *a, const char *type)
{
	if (soap_out_PointerTo_ns1__removeSetMembersRequest(soap, "ns1:removeSetMembersRequest", -1, &a->ns1__removeSetMembersRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeSetMembers * SOAP_FMAC4 soap_in___ns1__removeSetMembers(struct soap *soap, const char *tag, struct __ns1__removeSetMembers *a, const char *type)
{
	size_t soap_flag_ns1__removeSetMembersRequest = 1;
	short soap_flag;
	a = (struct __ns1__removeSetMembers *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeSetMembers, sizeof(struct __ns1__removeSetMembers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeSetMembers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeSetMembersRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__removeSetMembersRequest(soap, "ns1:removeSetMembersRequest", &a->ns1__removeSetMembersRequest, ""))
				{	soap_flag_ns1__removeSetMembersRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeSetMembers(struct soap *soap, const struct __ns1__removeSetMembers *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeSetMembers(soap, tag?tag:"-ns1:removeSetMembers", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeSetMembers * SOAP_FMAC4 soap_get___ns1__removeSetMembers(struct soap *soap, struct __ns1__removeSetMembers *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeSetMembers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeSetMembers * SOAP_FMAC2 soap_instantiate___ns1__removeSetMembers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeSetMembers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeSetMembers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeSetMembers);
		if (size)
			*size = sizeof(struct __ns1__removeSetMembers);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeSetMembers[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeSetMembers);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeSetMembers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeSetMembers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeSetMembers %p -> %p\n", q, p));
	*(struct __ns1__removeSetMembers*)p = *(struct __ns1__removeSetMembers*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__defineInstance(struct soap *soap, struct __ns1__defineInstance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__defineInstanceRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__defineInstance(struct soap *soap, const struct __ns1__defineInstance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__defineInstanceRequest(soap, &a->ns1__defineInstanceRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__defineInstance(struct soap *soap, const char *tag, int id, const struct __ns1__defineInstance *a, const char *type)
{
	if (soap_out_PointerTo_ns1__defineInstanceRequest(soap, "ns1:defineInstanceRequest", -1, &a->ns1__defineInstanceRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__defineInstance * SOAP_FMAC4 soap_in___ns1__defineInstance(struct soap *soap, const char *tag, struct __ns1__defineInstance *a, const char *type)
{
	size_t soap_flag_ns1__defineInstanceRequest = 1;
	short soap_flag;
	a = (struct __ns1__defineInstance *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__defineInstance, sizeof(struct __ns1__defineInstance), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__defineInstance(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__defineInstanceRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__defineInstanceRequest(soap, "ns1:defineInstanceRequest", &a->ns1__defineInstanceRequest, ""))
				{	soap_flag_ns1__defineInstanceRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__defineInstance(struct soap *soap, const struct __ns1__defineInstance *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__defineInstance(soap, tag?tag:"-ns1:defineInstance", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__defineInstance * SOAP_FMAC4 soap_get___ns1__defineInstance(struct soap *soap, struct __ns1__defineInstance *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__defineInstance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__defineInstance * SOAP_FMAC2 soap_instantiate___ns1__defineInstance(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__defineInstance(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__defineInstance, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__defineInstance);
		if (size)
			*size = sizeof(struct __ns1__defineInstance);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__defineInstance[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__defineInstance);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__defineInstance*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__defineInstance(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__defineInstance %p -> %p\n", q, p));
	*(struct __ns1__defineInstance*)p = *(struct __ns1__defineInstance*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__runSolver(struct soap *soap, struct __ns1__runSolver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__runSolverRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__runSolver(struct soap *soap, const struct __ns1__runSolver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__runSolverRequest(soap, &a->ns1__runSolverRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__runSolver(struct soap *soap, const char *tag, int id, const struct __ns1__runSolver *a, const char *type)
{
	if (soap_out_PointerTo_ns1__runSolverRequest(soap, "ns1:runSolverRequest", -1, &a->ns1__runSolverRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__runSolver * SOAP_FMAC4 soap_in___ns1__runSolver(struct soap *soap, const char *tag, struct __ns1__runSolver *a, const char *type)
{
	size_t soap_flag_ns1__runSolverRequest = 1;
	short soap_flag;
	a = (struct __ns1__runSolver *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__runSolver, sizeof(struct __ns1__runSolver), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__runSolver(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__runSolverRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__runSolverRequest(soap, "ns1:runSolverRequest", &a->ns1__runSolverRequest, ""))
				{	soap_flag_ns1__runSolverRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__runSolver(struct soap *soap, const struct __ns1__runSolver *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__runSolver(soap, tag?tag:"-ns1:runSolver", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__runSolver * SOAP_FMAC4 soap_get___ns1__runSolver(struct soap *soap, struct __ns1__runSolver *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__runSolver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__runSolver * SOAP_FMAC2 soap_instantiate___ns1__runSolver(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__runSolver(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__runSolver, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__runSolver);
		if (size)
			*size = sizeof(struct __ns1__runSolver);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__runSolver[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__runSolver);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__runSolver*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__runSolver(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__runSolver %p -> %p\n", q, p));
	*(struct __ns1__runSolver*)p = *(struct __ns1__runSolver*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__storeSetMembers(struct soap *soap, struct __ns1__storeSetMembers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__storeSetMembersRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__storeSetMembers(struct soap *soap, const struct __ns1__storeSetMembers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__storeSetMembersRequest(soap, &a->ns1__storeSetMembersRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__storeSetMembers(struct soap *soap, const char *tag, int id, const struct __ns1__storeSetMembers *a, const char *type)
{
	if (soap_out_PointerTo_ns1__storeSetMembersRequest(soap, "ns1:storeSetMembersRequest", -1, &a->ns1__storeSetMembersRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__storeSetMembers * SOAP_FMAC4 soap_in___ns1__storeSetMembers(struct soap *soap, const char *tag, struct __ns1__storeSetMembers *a, const char *type)
{
	size_t soap_flag_ns1__storeSetMembersRequest = 1;
	short soap_flag;
	a = (struct __ns1__storeSetMembers *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__storeSetMembers, sizeof(struct __ns1__storeSetMembers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__storeSetMembers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__storeSetMembersRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__storeSetMembersRequest(soap, "ns1:storeSetMembersRequest", &a->ns1__storeSetMembersRequest, ""))
				{	soap_flag_ns1__storeSetMembersRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__storeSetMembers(struct soap *soap, const struct __ns1__storeSetMembers *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__storeSetMembers(soap, tag?tag:"-ns1:storeSetMembers", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__storeSetMembers * SOAP_FMAC4 soap_get___ns1__storeSetMembers(struct soap *soap, struct __ns1__storeSetMembers *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__storeSetMembers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__storeSetMembers * SOAP_FMAC2 soap_instantiate___ns1__storeSetMembers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__storeSetMembers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__storeSetMembers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__storeSetMembers);
		if (size)
			*size = sizeof(struct __ns1__storeSetMembers);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__storeSetMembers[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__storeSetMembers);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__storeSetMembers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__storeSetMembers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__storeSetMembers %p -> %p\n", q, p));
	*(struct __ns1__storeSetMembers*)p = *(struct __ns1__storeSetMembers*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__definePreference(struct soap *soap, struct __ns1__definePreference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__definePreferenceRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__definePreference(struct soap *soap, const struct __ns1__definePreference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__definePreferenceRequest(soap, &a->ns1__definePreferenceRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__definePreference(struct soap *soap, const char *tag, int id, const struct __ns1__definePreference *a, const char *type)
{
	if (soap_out_PointerTo_ns1__definePreferenceRequest(soap, "ns1:definePreferenceRequest", -1, &a->ns1__definePreferenceRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__definePreference * SOAP_FMAC4 soap_in___ns1__definePreference(struct soap *soap, const char *tag, struct __ns1__definePreference *a, const char *type)
{
	size_t soap_flag_ns1__definePreferenceRequest = 1;
	short soap_flag;
	a = (struct __ns1__definePreference *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__definePreference, sizeof(struct __ns1__definePreference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__definePreference(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__definePreferenceRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__definePreferenceRequest(soap, "ns1:definePreferenceRequest", &a->ns1__definePreferenceRequest, ""))
				{	soap_flag_ns1__definePreferenceRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__definePreference(struct soap *soap, const struct __ns1__definePreference *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__definePreference(soap, tag?tag:"-ns1:definePreference", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__definePreference * SOAP_FMAC4 soap_get___ns1__definePreference(struct soap *soap, struct __ns1__definePreference *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__definePreference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__definePreference * SOAP_FMAC2 soap_instantiate___ns1__definePreference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__definePreference(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__definePreference, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__definePreference);
		if (size)
			*size = sizeof(struct __ns1__definePreference);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__definePreference[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__definePreference);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__definePreference*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__definePreference(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__definePreference %p -> %p\n", q, p));
	*(struct __ns1__definePreference*)p = *(struct __ns1__definePreference*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSetMembers(struct soap *soap, struct __ns1__getSetMembers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getSetMembersRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSetMembers(struct soap *soap, const struct __ns1__getSetMembers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getSetMembersRequest(soap, &a->ns1__getSetMembersRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSetMembers(struct soap *soap, const char *tag, int id, const struct __ns1__getSetMembers *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getSetMembersRequest(soap, "ns1:getSetMembersRequest", -1, &a->ns1__getSetMembersRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSetMembers * SOAP_FMAC4 soap_in___ns1__getSetMembers(struct soap *soap, const char *tag, struct __ns1__getSetMembers *a, const char *type)
{
	size_t soap_flag_ns1__getSetMembersRequest = 1;
	short soap_flag;
	a = (struct __ns1__getSetMembers *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSetMembers, sizeof(struct __ns1__getSetMembers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSetMembers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getSetMembersRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getSetMembersRequest(soap, "ns1:getSetMembersRequest", &a->ns1__getSetMembersRequest, ""))
				{	soap_flag_ns1__getSetMembersRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSetMembers(struct soap *soap, const struct __ns1__getSetMembers *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSetMembers(soap, tag?tag:"-ns1:getSetMembers", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSetMembers * SOAP_FMAC4 soap_get___ns1__getSetMembers(struct soap *soap, struct __ns1__getSetMembers *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSetMembers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSetMembers * SOAP_FMAC2 soap_instantiate___ns1__getSetMembers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSetMembers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSetMembers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSetMembers);
		if (size)
			*size = sizeof(struct __ns1__getSetMembers);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSetMembers[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getSetMembers);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getSetMembers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSetMembers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSetMembers %p -> %p\n", q, p));
	*(struct __ns1__getSetMembers*)p = *(struct __ns1__getSetMembers*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__storeSolution(struct soap *soap, struct __ns1__storeSolution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__storeSolutionRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__storeSolution(struct soap *soap, const struct __ns1__storeSolution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__storeSolutionRequest(soap, &a->ns1__storeSolutionRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__storeSolution(struct soap *soap, const char *tag, int id, const struct __ns1__storeSolution *a, const char *type)
{
	if (soap_out_PointerTo_ns1__storeSolutionRequest(soap, "ns1:storeSolutionRequest", -1, &a->ns1__storeSolutionRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__storeSolution * SOAP_FMAC4 soap_in___ns1__storeSolution(struct soap *soap, const char *tag, struct __ns1__storeSolution *a, const char *type)
{
	size_t soap_flag_ns1__storeSolutionRequest = 1;
	short soap_flag;
	a = (struct __ns1__storeSolution *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__storeSolution, sizeof(struct __ns1__storeSolution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__storeSolution(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__storeSolutionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__storeSolutionRequest(soap, "ns1:storeSolutionRequest", &a->ns1__storeSolutionRequest, ""))
				{	soap_flag_ns1__storeSolutionRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__storeSolution(struct soap *soap, const struct __ns1__storeSolution *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__storeSolution(soap, tag?tag:"-ns1:storeSolution", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__storeSolution * SOAP_FMAC4 soap_get___ns1__storeSolution(struct soap *soap, struct __ns1__storeSolution *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__storeSolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__storeSolution * SOAP_FMAC2 soap_instantiate___ns1__storeSolution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__storeSolution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__storeSolution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__storeSolution);
		if (size)
			*size = sizeof(struct __ns1__storeSolution);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__storeSolution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__storeSolution);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__storeSolution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__storeSolution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__storeSolution %p -> %p\n", q, p));
	*(struct __ns1__storeSolution*)p = *(struct __ns1__storeSolution*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDataSummary(struct soap *soap, struct __ns1__getDataSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDataSummaryRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDataSummary(struct soap *soap, const struct __ns1__getDataSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getDataSummaryRequest(soap, &a->ns1__getDataSummaryRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDataSummary(struct soap *soap, const char *tag, int id, const struct __ns1__getDataSummary *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getDataSummaryRequest(soap, "ns1:getDataSummaryRequest", -1, &a->ns1__getDataSummaryRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDataSummary * SOAP_FMAC4 soap_in___ns1__getDataSummary(struct soap *soap, const char *tag, struct __ns1__getDataSummary *a, const char *type)
{
	size_t soap_flag_ns1__getDataSummaryRequest = 1;
	short soap_flag;
	a = (struct __ns1__getDataSummary *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDataSummary, sizeof(struct __ns1__getDataSummary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDataSummary(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDataSummaryRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getDataSummaryRequest(soap, "ns1:getDataSummaryRequest", &a->ns1__getDataSummaryRequest, ""))
				{	soap_flag_ns1__getDataSummaryRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDataSummary(struct soap *soap, const struct __ns1__getDataSummary *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDataSummary(soap, tag?tag:"-ns1:getDataSummary", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDataSummary * SOAP_FMAC4 soap_get___ns1__getDataSummary(struct soap *soap, struct __ns1__getDataSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDataSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getDataSummary * SOAP_FMAC2 soap_instantiate___ns1__getDataSummary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getDataSummary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getDataSummary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDataSummary);
		if (size)
			*size = sizeof(struct __ns1__getDataSummary);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDataSummary[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getDataSummary);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getDataSummary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getDataSummary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getDataSummary %p -> %p\n", q, p));
	*(struct __ns1__getDataSummary*)p = *(struct __ns1__getDataSummary*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeEntityValues(struct soap *soap, struct __ns1__removeEntityValues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeEntityValuesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeEntityValues(struct soap *soap, const struct __ns1__removeEntityValues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__removeEntityValuesRequest(soap, &a->ns1__removeEntityValuesRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeEntityValues(struct soap *soap, const char *tag, int id, const struct __ns1__removeEntityValues *a, const char *type)
{
	if (soap_out_PointerTo_ns1__removeEntityValuesRequest(soap, "ns1:removeEntityValuesRequest", -1, &a->ns1__removeEntityValuesRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeEntityValues * SOAP_FMAC4 soap_in___ns1__removeEntityValues(struct soap *soap, const char *tag, struct __ns1__removeEntityValues *a, const char *type)
{
	size_t soap_flag_ns1__removeEntityValuesRequest = 1;
	short soap_flag;
	a = (struct __ns1__removeEntityValues *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeEntityValues, sizeof(struct __ns1__removeEntityValues), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeEntityValues(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeEntityValuesRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__removeEntityValuesRequest(soap, "ns1:removeEntityValuesRequest", &a->ns1__removeEntityValuesRequest, ""))
				{	soap_flag_ns1__removeEntityValuesRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeEntityValues(struct soap *soap, const struct __ns1__removeEntityValues *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeEntityValues(soap, tag?tag:"-ns1:removeEntityValues", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeEntityValues * SOAP_FMAC4 soap_get___ns1__removeEntityValues(struct soap *soap, struct __ns1__removeEntityValues *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeEntityValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeEntityValues * SOAP_FMAC2 soap_instantiate___ns1__removeEntityValues(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeEntityValues(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeEntityValues, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeEntityValues);
		if (size)
			*size = sizeof(struct __ns1__removeEntityValues);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeEntityValues[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeEntityValues);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeEntityValues*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeEntityValues(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeEntityValues %p -> %p\n", q, p));
	*(struct __ns1__removeEntityValues*)p = *(struct __ns1__removeEntityValues*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getBatchValues(struct soap *soap, struct __ns1__getBatchValues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getBatchValuesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getBatchValues(struct soap *soap, const struct __ns1__getBatchValues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getBatchValuesRequest(soap, &a->ns1__getBatchValuesRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getBatchValues(struct soap *soap, const char *tag, int id, const struct __ns1__getBatchValues *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getBatchValuesRequest(soap, "ns1:getBatchValuesRequest", -1, &a->ns1__getBatchValuesRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getBatchValues * SOAP_FMAC4 soap_in___ns1__getBatchValues(struct soap *soap, const char *tag, struct __ns1__getBatchValues *a, const char *type)
{
	size_t soap_flag_ns1__getBatchValuesRequest = 1;
	short soap_flag;
	a = (struct __ns1__getBatchValues *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getBatchValues, sizeof(struct __ns1__getBatchValues), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getBatchValues(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getBatchValuesRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getBatchValuesRequest(soap, "ns1:getBatchValuesRequest", &a->ns1__getBatchValuesRequest, ""))
				{	soap_flag_ns1__getBatchValuesRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getBatchValues(struct soap *soap, const struct __ns1__getBatchValues *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getBatchValues(soap, tag?tag:"-ns1:getBatchValues", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getBatchValues * SOAP_FMAC4 soap_get___ns1__getBatchValues(struct soap *soap, struct __ns1__getBatchValues *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getBatchValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getBatchValues * SOAP_FMAC2 soap_instantiate___ns1__getBatchValues(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getBatchValues(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getBatchValues, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getBatchValues);
		if (size)
			*size = sizeof(struct __ns1__getBatchValues);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getBatchValues[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getBatchValues);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getBatchValues*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getBatchValues(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getBatchValues %p -> %p\n", q, p));
	*(struct __ns1__getBatchValues*)p = *(struct __ns1__getBatchValues*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSolution(struct soap *soap, struct __ns1__getSolution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getSolutionRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSolution(struct soap *soap, const struct __ns1__getSolution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getSolutionRequest(soap, &a->ns1__getSolutionRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSolution(struct soap *soap, const char *tag, int id, const struct __ns1__getSolution *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getSolutionRequest(soap, "ns1:getSolutionRequest", -1, &a->ns1__getSolutionRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSolution * SOAP_FMAC4 soap_in___ns1__getSolution(struct soap *soap, const char *tag, struct __ns1__getSolution *a, const char *type)
{
	size_t soap_flag_ns1__getSolutionRequest = 1;
	short soap_flag;
	a = (struct __ns1__getSolution *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSolution, sizeof(struct __ns1__getSolution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSolution(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getSolutionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getSolutionRequest(soap, "ns1:getSolutionRequest", &a->ns1__getSolutionRequest, ""))
				{	soap_flag_ns1__getSolutionRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSolution(struct soap *soap, const struct __ns1__getSolution *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSolution(soap, tag?tag:"-ns1:getSolution", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSolution * SOAP_FMAC4 soap_get___ns1__getSolution(struct soap *soap, struct __ns1__getSolution *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSolution * SOAP_FMAC2 soap_instantiate___ns1__getSolution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSolution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSolution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSolution);
		if (size)
			*size = sizeof(struct __ns1__getSolution);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSolution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getSolution);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getSolution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSolution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSolution %p -> %p\n", q, p));
	*(struct __ns1__getSolution*)p = *(struct __ns1__getSolution*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSMS(struct soap *soap, struct __ns1__getSMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getSMSRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSMS(struct soap *soap, const struct __ns1__getSMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getSMSRequest(soap, &a->ns1__getSMSRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSMS(struct soap *soap, const char *tag, int id, const struct __ns1__getSMS *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getSMSRequest(soap, "ns1:getSMSRequest", -1, &a->ns1__getSMSRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSMS * SOAP_FMAC4 soap_in___ns1__getSMS(struct soap *soap, const char *tag, struct __ns1__getSMS *a, const char *type)
{
	size_t soap_flag_ns1__getSMSRequest = 1;
	short soap_flag;
	a = (struct __ns1__getSMS *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSMS, sizeof(struct __ns1__getSMS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSMS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getSMSRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getSMSRequest(soap, "ns1:getSMSRequest", &a->ns1__getSMSRequest, ""))
				{	soap_flag_ns1__getSMSRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSMS(struct soap *soap, const struct __ns1__getSMS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSMS(soap, tag?tag:"-ns1:getSMS", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSMS * SOAP_FMAC4 soap_get___ns1__getSMS(struct soap *soap, struct __ns1__getSMS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSMS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSMS * SOAP_FMAC2 soap_instantiate___ns1__getSMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSMS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSMS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSMS);
		if (size)
			*size = sizeof(struct __ns1__getSMS);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSMS[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getSMS);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getSMS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSMS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSMS %p -> %p\n", q, p));
	*(struct __ns1__getSMS*)p = *(struct __ns1__getSMS*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__storeMainSet(struct soap *soap, struct __ns1__storeMainSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__storeMainSetRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__storeMainSet(struct soap *soap, const struct __ns1__storeMainSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__storeMainSetRequest(soap, &a->ns1__storeMainSetRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__storeMainSet(struct soap *soap, const char *tag, int id, const struct __ns1__storeMainSet *a, const char *type)
{
	if (soap_out_PointerTo_ns1__storeMainSetRequest(soap, "ns1:storeMainSetRequest", -1, &a->ns1__storeMainSetRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__storeMainSet * SOAP_FMAC4 soap_in___ns1__storeMainSet(struct soap *soap, const char *tag, struct __ns1__storeMainSet *a, const char *type)
{
	size_t soap_flag_ns1__storeMainSetRequest = 1;
	short soap_flag;
	a = (struct __ns1__storeMainSet *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__storeMainSet, sizeof(struct __ns1__storeMainSet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__storeMainSet(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__storeMainSetRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__storeMainSetRequest(soap, "ns1:storeMainSetRequest", &a->ns1__storeMainSetRequest, ""))
				{	soap_flag_ns1__storeMainSetRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__storeMainSet(struct soap *soap, const struct __ns1__storeMainSet *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__storeMainSet(soap, tag?tag:"-ns1:storeMainSet", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__storeMainSet * SOAP_FMAC4 soap_get___ns1__storeMainSet(struct soap *soap, struct __ns1__storeMainSet *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__storeMainSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__storeMainSet * SOAP_FMAC2 soap_instantiate___ns1__storeMainSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__storeMainSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__storeMainSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__storeMainSet);
		if (size)
			*size = sizeof(struct __ns1__storeMainSet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__storeMainSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__storeMainSet);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__storeMainSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__storeMainSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__storeMainSet %p -> %p\n", q, p));
	*(struct __ns1__storeMainSet*)p = *(struct __ns1__storeMainSet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getEntityValues(struct soap *soap, struct __ns1__getEntityValues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getEntityValuesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getEntityValues(struct soap *soap, const struct __ns1__getEntityValues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getEntityValuesRequest(soap, &a->ns1__getEntityValuesRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getEntityValues(struct soap *soap, const char *tag, int id, const struct __ns1__getEntityValues *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getEntityValuesRequest(soap, "ns1:getEntityValuesRequest", -1, &a->ns1__getEntityValuesRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getEntityValues * SOAP_FMAC4 soap_in___ns1__getEntityValues(struct soap *soap, const char *tag, struct __ns1__getEntityValues *a, const char *type)
{
	size_t soap_flag_ns1__getEntityValuesRequest = 1;
	short soap_flag;
	a = (struct __ns1__getEntityValues *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getEntityValues, sizeof(struct __ns1__getEntityValues), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getEntityValues(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getEntityValuesRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getEntityValuesRequest(soap, "ns1:getEntityValuesRequest", &a->ns1__getEntityValuesRequest, ""))
				{	soap_flag_ns1__getEntityValuesRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getEntityValues(struct soap *soap, const struct __ns1__getEntityValues *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getEntityValues(soap, tag?tag:"-ns1:getEntityValues", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getEntityValues * SOAP_FMAC4 soap_get___ns1__getEntityValues(struct soap *soap, struct __ns1__getEntityValues *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getEntityValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getEntityValues * SOAP_FMAC2 soap_instantiate___ns1__getEntityValues(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getEntityValues(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getEntityValues, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getEntityValues);
		if (size)
			*size = sizeof(struct __ns1__getEntityValues);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getEntityValues[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getEntityValues);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getEntityValues*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getEntityValues(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getEntityValues %p -> %p\n", q, p));
	*(struct __ns1__getEntityValues*)p = *(struct __ns1__getEntityValues*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPreference(struct soap *soap, struct __ns1__getPreference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPreferenceRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPreference(struct soap *soap, const struct __ns1__getPreference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getPreferenceRequest(soap, &a->ns1__getPreferenceRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPreference(struct soap *soap, const char *tag, int id, const struct __ns1__getPreference *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getPreferenceRequest(soap, "ns1:getPreferenceRequest", -1, &a->ns1__getPreferenceRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPreference * SOAP_FMAC4 soap_in___ns1__getPreference(struct soap *soap, const char *tag, struct __ns1__getPreference *a, const char *type)
{
	size_t soap_flag_ns1__getPreferenceRequest = 1;
	short soap_flag;
	a = (struct __ns1__getPreference *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPreference, sizeof(struct __ns1__getPreference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPreference(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPreferenceRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getPreferenceRequest(soap, "ns1:getPreferenceRequest", &a->ns1__getPreferenceRequest, ""))
				{	soap_flag_ns1__getPreferenceRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPreference(struct soap *soap, const struct __ns1__getPreference *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPreference(soap, tag?tag:"-ns1:getPreference", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPreference * SOAP_FMAC4 soap_get___ns1__getPreference(struct soap *soap, struct __ns1__getPreference *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPreference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getPreference * SOAP_FMAC2 soap_instantiate___ns1__getPreference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPreference(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getPreference, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getPreference);
		if (size)
			*size = sizeof(struct __ns1__getPreference);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getPreference[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getPreference);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getPreference*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getPreference(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getPreference %p -> %p\n", q, p));
	*(struct __ns1__getPreference*)p = *(struct __ns1__getPreference*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__defineAnalysis(struct soap *soap, struct __ns1__defineAnalysis *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__defineAnalysisRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__defineAnalysis(struct soap *soap, const struct __ns1__defineAnalysis *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__defineAnalysisRequest(soap, &a->ns1__defineAnalysisRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__defineAnalysis(struct soap *soap, const char *tag, int id, const struct __ns1__defineAnalysis *a, const char *type)
{
	if (soap_out_PointerTo_ns1__defineAnalysisRequest(soap, "ns1:defineAnalysisRequest", -1, &a->ns1__defineAnalysisRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__defineAnalysis * SOAP_FMAC4 soap_in___ns1__defineAnalysis(struct soap *soap, const char *tag, struct __ns1__defineAnalysis *a, const char *type)
{
	size_t soap_flag_ns1__defineAnalysisRequest = 1;
	short soap_flag;
	a = (struct __ns1__defineAnalysis *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__defineAnalysis, sizeof(struct __ns1__defineAnalysis), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__defineAnalysis(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__defineAnalysisRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__defineAnalysisRequest(soap, "ns1:defineAnalysisRequest", &a->ns1__defineAnalysisRequest, ""))
				{	soap_flag_ns1__defineAnalysisRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__defineAnalysis(struct soap *soap, const struct __ns1__defineAnalysis *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__defineAnalysis(soap, tag?tag:"-ns1:defineAnalysis", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__defineAnalysis * SOAP_FMAC4 soap_get___ns1__defineAnalysis(struct soap *soap, struct __ns1__defineAnalysis *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__defineAnalysis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__defineAnalysis * SOAP_FMAC2 soap_instantiate___ns1__defineAnalysis(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__defineAnalysis(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__defineAnalysis, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__defineAnalysis);
		if (size)
			*size = sizeof(struct __ns1__defineAnalysis);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__defineAnalysis[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__defineAnalysis);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__defineAnalysis*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__defineAnalysis(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__defineAnalysis %p -> %p\n", q, p));
	*(struct __ns1__defineAnalysis*)p = *(struct __ns1__defineAnalysis*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__runScenario(struct soap *soap, struct __ns1__runScenario *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__runScenarioRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__runScenario(struct soap *soap, const struct __ns1__runScenario *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__runScenarioRequest(soap, &a->ns1__runScenarioRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__runScenario(struct soap *soap, const char *tag, int id, const struct __ns1__runScenario *a, const char *type)
{
	if (soap_out_PointerTo_ns1__runScenarioRequest(soap, "ns1:runScenarioRequest", -1, &a->ns1__runScenarioRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__runScenario * SOAP_FMAC4 soap_in___ns1__runScenario(struct soap *soap, const char *tag, struct __ns1__runScenario *a, const char *type)
{
	size_t soap_flag_ns1__runScenarioRequest = 1;
	short soap_flag;
	a = (struct __ns1__runScenario *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__runScenario, sizeof(struct __ns1__runScenario), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__runScenario(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__runScenarioRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__runScenarioRequest(soap, "ns1:runScenarioRequest", &a->ns1__runScenarioRequest, ""))
				{	soap_flag_ns1__runScenarioRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__runScenario(struct soap *soap, const struct __ns1__runScenario *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__runScenario(soap, tag?tag:"-ns1:runScenario", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__runScenario * SOAP_FMAC4 soap_get___ns1__runScenario(struct soap *soap, struct __ns1__runScenario *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__runScenario(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__runScenario * SOAP_FMAC2 soap_instantiate___ns1__runScenario(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__runScenario(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__runScenario, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__runScenario);
		if (size)
			*size = sizeof(struct __ns1__runScenario);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__runScenario[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__runScenario);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__runScenario*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__runScenario(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__runScenario %p -> %p\n", q, p));
	*(struct __ns1__runScenario*)p = *(struct __ns1__runScenario*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__defineModelData(struct soap *soap, struct __ns1__defineModelData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__defineModelDataRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__defineModelData(struct soap *soap, const struct __ns1__defineModelData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__defineModelDataRequest(soap, &a->ns1__defineModelDataRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__defineModelData(struct soap *soap, const char *tag, int id, const struct __ns1__defineModelData *a, const char *type)
{
	if (soap_out_PointerTo_ns1__defineModelDataRequest(soap, "ns1:defineModelDataRequest", -1, &a->ns1__defineModelDataRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__defineModelData * SOAP_FMAC4 soap_in___ns1__defineModelData(struct soap *soap, const char *tag, struct __ns1__defineModelData *a, const char *type)
{
	size_t soap_flag_ns1__defineModelDataRequest = 1;
	short soap_flag;
	a = (struct __ns1__defineModelData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__defineModelData, sizeof(struct __ns1__defineModelData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__defineModelData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__defineModelDataRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__defineModelDataRequest(soap, "ns1:defineModelDataRequest", &a->ns1__defineModelDataRequest, ""))
				{	soap_flag_ns1__defineModelDataRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__defineModelData(struct soap *soap, const struct __ns1__defineModelData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__defineModelData(soap, tag?tag:"-ns1:defineModelData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__defineModelData * SOAP_FMAC4 soap_get___ns1__defineModelData(struct soap *soap, struct __ns1__defineModelData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__defineModelData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__defineModelData * SOAP_FMAC2 soap_instantiate___ns1__defineModelData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__defineModelData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__defineModelData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__defineModelData);
		if (size)
			*size = sizeof(struct __ns1__defineModelData);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__defineModelData[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__defineModelData);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__defineModelData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__defineModelData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__defineModelData %p -> %p\n", q, p));
	*(struct __ns1__defineModelData*)p = *(struct __ns1__defineModelData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAnalyses(struct soap *soap, struct __ns1__getAnalyses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAnalysesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAnalyses(struct soap *soap, const struct __ns1__getAnalyses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getAnalysesRequest(soap, &a->ns1__getAnalysesRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAnalyses(struct soap *soap, const char *tag, int id, const struct __ns1__getAnalyses *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getAnalysesRequest(soap, "ns1:getAnalysesRequest", -1, &a->ns1__getAnalysesRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAnalyses * SOAP_FMAC4 soap_in___ns1__getAnalyses(struct soap *soap, const char *tag, struct __ns1__getAnalyses *a, const char *type)
{
	size_t soap_flag_ns1__getAnalysesRequest = 1;
	short soap_flag;
	a = (struct __ns1__getAnalyses *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAnalyses, sizeof(struct __ns1__getAnalyses), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAnalyses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAnalysesRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getAnalysesRequest(soap, "ns1:getAnalysesRequest", &a->ns1__getAnalysesRequest, ""))
				{	soap_flag_ns1__getAnalysesRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAnalyses(struct soap *soap, const struct __ns1__getAnalyses *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAnalyses(soap, tag?tag:"-ns1:getAnalyses", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAnalyses * SOAP_FMAC4 soap_get___ns1__getAnalyses(struct soap *soap, struct __ns1__getAnalyses *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAnalyses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAnalyses * SOAP_FMAC2 soap_instantiate___ns1__getAnalyses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAnalyses(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAnalyses, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAnalyses);
		if (size)
			*size = sizeof(struct __ns1__getAnalyses);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAnalyses[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getAnalyses);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getAnalyses*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAnalyses(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAnalyses %p -> %p\n", q, p));
	*(struct __ns1__getAnalyses*)p = *(struct __ns1__getAnalyses*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateSolverStatus(struct soap *soap, struct __ns1__updateSolverStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateSolverStatusRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateSolverStatus(struct soap *soap, const struct __ns1__updateSolverStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__updateSolverStatusRequest(soap, &a->ns1__updateSolverStatusRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateSolverStatus(struct soap *soap, const char *tag, int id, const struct __ns1__updateSolverStatus *a, const char *type)
{
	if (soap_out_PointerTo_ns1__updateSolverStatusRequest(soap, "ns1:updateSolverStatusRequest", -1, &a->ns1__updateSolverStatusRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateSolverStatus * SOAP_FMAC4 soap_in___ns1__updateSolverStatus(struct soap *soap, const char *tag, struct __ns1__updateSolverStatus *a, const char *type)
{
	size_t soap_flag_ns1__updateSolverStatusRequest = 1;
	short soap_flag;
	a = (struct __ns1__updateSolverStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateSolverStatus, sizeof(struct __ns1__updateSolverStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateSolverStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateSolverStatusRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__updateSolverStatusRequest(soap, "ns1:updateSolverStatusRequest", &a->ns1__updateSolverStatusRequest, ""))
				{	soap_flag_ns1__updateSolverStatusRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateSolverStatus(struct soap *soap, const struct __ns1__updateSolverStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateSolverStatus(soap, tag?tag:"-ns1:updateSolverStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateSolverStatus * SOAP_FMAC4 soap_get___ns1__updateSolverStatus(struct soap *soap, struct __ns1__updateSolverStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateSolverStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__updateSolverStatus * SOAP_FMAC2 soap_instantiate___ns1__updateSolverStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateSolverStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__updateSolverStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateSolverStatus);
		if (size)
			*size = sizeof(struct __ns1__updateSolverStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateSolverStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__updateSolverStatus);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__updateSolverStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__updateSolverStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__updateSolverStatus %p -> %p\n", q, p));
	*(struct __ns1__updateSolverStatus*)p = *(struct __ns1__updateSolverStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__changeModelDataStatus(struct soap *soap, struct __ns1__changeModelDataStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__changeModelDataStatusRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__changeModelDataStatus(struct soap *soap, const struct __ns1__changeModelDataStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__changeModelDataStatusRequest(soap, &a->ns1__changeModelDataStatusRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__changeModelDataStatus(struct soap *soap, const char *tag, int id, const struct __ns1__changeModelDataStatus *a, const char *type)
{
	if (soap_out_PointerTo_ns1__changeModelDataStatusRequest(soap, "ns1:changeModelDataStatusRequest", -1, &a->ns1__changeModelDataStatusRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__changeModelDataStatus * SOAP_FMAC4 soap_in___ns1__changeModelDataStatus(struct soap *soap, const char *tag, struct __ns1__changeModelDataStatus *a, const char *type)
{
	size_t soap_flag_ns1__changeModelDataStatusRequest = 1;
	short soap_flag;
	a = (struct __ns1__changeModelDataStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__changeModelDataStatus, sizeof(struct __ns1__changeModelDataStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__changeModelDataStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__changeModelDataStatusRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__changeModelDataStatusRequest(soap, "ns1:changeModelDataStatusRequest", &a->ns1__changeModelDataStatusRequest, ""))
				{	soap_flag_ns1__changeModelDataStatusRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__changeModelDataStatus(struct soap *soap, const struct __ns1__changeModelDataStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__changeModelDataStatus(soap, tag?tag:"-ns1:changeModelDataStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__changeModelDataStatus * SOAP_FMAC4 soap_get___ns1__changeModelDataStatus(struct soap *soap, struct __ns1__changeModelDataStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__changeModelDataStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__changeModelDataStatus * SOAP_FMAC2 soap_instantiate___ns1__changeModelDataStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__changeModelDataStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__changeModelDataStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__changeModelDataStatus);
		if (size)
			*size = sizeof(struct __ns1__changeModelDataStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__changeModelDataStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__changeModelDataStatus);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__changeModelDataStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__changeModelDataStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__changeModelDataStatus %p -> %p\n", q, p));
	*(struct __ns1__changeModelDataStatus*)p = *(struct __ns1__changeModelDataStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__union_value(struct soap *soap, int choice, const union _ns3__union_value *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns3__union_value_intValue:
		soap_embedded(soap, &a->intValue, SOAP_TYPE_int);
		break;
	case SOAP_UNION__ns3__union_value_doubleValue:
		soap_embedded(soap, &a->doubleValue, SOAP_TYPE_double);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__union_value(struct soap *soap, int choice, const union _ns3__union_value *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns3__union_value_intValue:
		return soap_out_int(soap, "intValue", -1, &a->intValue, "");
	case SOAP_UNION__ns3__union_value_doubleValue:
		return soap_out_double(soap, "doubleValue", -1, &a->doubleValue, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns3__union_value * SOAP_FMAC4 soap_in__ns3__union_value(struct soap *soap, int *choice, union _ns3__union_value *a)
{	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_int(soap, "intValue", &a->intValue, "xsd:int"))
	{	*choice = SOAP_UNION__ns3__union_value_intValue;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_double(soap, "doubleValue", &a->doubleValue, "xsd:double"))
	{	*choice = SOAP_UNION__ns3__union_value_doubleValue;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getSolverStatusResponse(struct soap *soap, _ns1__getSolverStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getSolverStatusResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getSolverStatusResponse(struct soap *soap, const char *tag, int id, _ns1__getSolverStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getSolverStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getSolverStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getSolverStatusResponse(struct soap *soap, const char *tag, _ns1__getSolverStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getSolverStatusResponse **)soap_malloc(soap, sizeof(_ns1__getSolverStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getSolverStatusResponse *)soap_instantiate__ns1__getSolverStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getSolverStatusResponse ** p = (_ns1__getSolverStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getSolverStatusResponse, sizeof(_ns1__getSolverStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getSolverStatusResponse(struct soap *soap, _ns1__getSolverStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getSolverStatusResponse);
	if (soap_out_PointerTo_ns1__getSolverStatusResponse(soap, tag?tag:"ns1:getSolverStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getSolverStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getSolverStatusResponse(struct soap *soap, _ns1__getSolverStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getSolverStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getSolverStatusRequest(struct soap *soap, _ns1__getSolverStatusRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getSolverStatusRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getSolverStatusRequest(struct soap *soap, const char *tag, int id, _ns1__getSolverStatusRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getSolverStatusRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getSolverStatusRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getSolverStatusRequest(struct soap *soap, const char *tag, _ns1__getSolverStatusRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getSolverStatusRequest **)soap_malloc(soap, sizeof(_ns1__getSolverStatusRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getSolverStatusRequest *)soap_instantiate__ns1__getSolverStatusRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getSolverStatusRequest ** p = (_ns1__getSolverStatusRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getSolverStatusRequest, sizeof(_ns1__getSolverStatusRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getSolverStatusRequest(struct soap *soap, _ns1__getSolverStatusRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getSolverStatusRequest);
	if (soap_out_PointerTo_ns1__getSolverStatusRequest(soap, tag?tag:"ns1:getSolverStatusRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getSolverStatusRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getSolverStatusRequest(struct soap *soap, _ns1__getSolverStatusRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getSolverStatusRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__storeEntityValuesResponse(struct soap *soap, _ns1__storeEntityValuesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__storeEntityValuesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__storeEntityValuesResponse(struct soap *soap, const char *tag, int id, _ns1__storeEntityValuesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__storeEntityValuesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__storeEntityValuesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__storeEntityValuesResponse(struct soap *soap, const char *tag, _ns1__storeEntityValuesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__storeEntityValuesResponse **)soap_malloc(soap, sizeof(_ns1__storeEntityValuesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__storeEntityValuesResponse *)soap_instantiate__ns1__storeEntityValuesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__storeEntityValuesResponse ** p = (_ns1__storeEntityValuesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__storeEntityValuesResponse, sizeof(_ns1__storeEntityValuesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__storeEntityValuesResponse(struct soap *soap, _ns1__storeEntityValuesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__storeEntityValuesResponse);
	if (soap_out_PointerTo_ns1__storeEntityValuesResponse(soap, tag?tag:"ns1:storeEntityValuesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__storeEntityValuesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__storeEntityValuesResponse(struct soap *soap, _ns1__storeEntityValuesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__storeEntityValuesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__storeEntityValuesRequest(struct soap *soap, _ns1__storeEntityValuesRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__storeEntityValuesRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__storeEntityValuesRequest(struct soap *soap, const char *tag, int id, _ns1__storeEntityValuesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__storeEntityValuesRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__storeEntityValuesRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__storeEntityValuesRequest(struct soap *soap, const char *tag, _ns1__storeEntityValuesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__storeEntityValuesRequest **)soap_malloc(soap, sizeof(_ns1__storeEntityValuesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__storeEntityValuesRequest *)soap_instantiate__ns1__storeEntityValuesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__storeEntityValuesRequest ** p = (_ns1__storeEntityValuesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__storeEntityValuesRequest, sizeof(_ns1__storeEntityValuesRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__storeEntityValuesRequest(struct soap *soap, _ns1__storeEntityValuesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__storeEntityValuesRequest);
	if (soap_out_PointerTo_ns1__storeEntityValuesRequest(soap, tag?tag:"ns1:storeEntityValuesRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__storeEntityValuesRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__storeEntityValuesRequest(struct soap *soap, _ns1__storeEntityValuesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__storeEntityValuesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeSetMembersResponse(struct soap *soap, _ns1__removeSetMembersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeSetMembersResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeSetMembersResponse(struct soap *soap, const char *tag, int id, _ns1__removeSetMembersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeSetMembersResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeSetMembersResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeSetMembersResponse(struct soap *soap, const char *tag, _ns1__removeSetMembersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeSetMembersResponse **)soap_malloc(soap, sizeof(_ns1__removeSetMembersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeSetMembersResponse *)soap_instantiate__ns1__removeSetMembersResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeSetMembersResponse ** p = (_ns1__removeSetMembersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeSetMembersResponse, sizeof(_ns1__removeSetMembersResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeSetMembersResponse(struct soap *soap, _ns1__removeSetMembersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeSetMembersResponse);
	if (soap_out_PointerTo_ns1__removeSetMembersResponse(soap, tag?tag:"ns1:removeSetMembersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeSetMembersResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeSetMembersResponse(struct soap *soap, _ns1__removeSetMembersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeSetMembersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeSetMembersRequest(struct soap *soap, _ns1__removeSetMembersRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeSetMembersRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeSetMembersRequest(struct soap *soap, const char *tag, int id, _ns1__removeSetMembersRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeSetMembersRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeSetMembersRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeSetMembersRequest(struct soap *soap, const char *tag, _ns1__removeSetMembersRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeSetMembersRequest **)soap_malloc(soap, sizeof(_ns1__removeSetMembersRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeSetMembersRequest *)soap_instantiate__ns1__removeSetMembersRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeSetMembersRequest ** p = (_ns1__removeSetMembersRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeSetMembersRequest, sizeof(_ns1__removeSetMembersRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeSetMembersRequest(struct soap *soap, _ns1__removeSetMembersRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeSetMembersRequest);
	if (soap_out_PointerTo_ns1__removeSetMembersRequest(soap, tag?tag:"ns1:removeSetMembersRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeSetMembersRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeSetMembersRequest(struct soap *soap, _ns1__removeSetMembersRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeSetMembersRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__defineInstanceResponse(struct soap *soap, _ns1__defineInstanceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__defineInstanceResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__defineInstanceResponse(struct soap *soap, const char *tag, int id, _ns1__defineInstanceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__defineInstanceResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__defineInstanceResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__defineInstanceResponse(struct soap *soap, const char *tag, _ns1__defineInstanceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__defineInstanceResponse **)soap_malloc(soap, sizeof(_ns1__defineInstanceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__defineInstanceResponse *)soap_instantiate__ns1__defineInstanceResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__defineInstanceResponse ** p = (_ns1__defineInstanceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__defineInstanceResponse, sizeof(_ns1__defineInstanceResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__defineInstanceResponse(struct soap *soap, _ns1__defineInstanceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__defineInstanceResponse);
	if (soap_out_PointerTo_ns1__defineInstanceResponse(soap, tag?tag:"ns1:defineInstanceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__defineInstanceResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__defineInstanceResponse(struct soap *soap, _ns1__defineInstanceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__defineInstanceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__defineInstanceRequest(struct soap *soap, _ns1__defineInstanceRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__defineInstanceRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__defineInstanceRequest(struct soap *soap, const char *tag, int id, _ns1__defineInstanceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__defineInstanceRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__defineInstanceRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__defineInstanceRequest(struct soap *soap, const char *tag, _ns1__defineInstanceRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__defineInstanceRequest **)soap_malloc(soap, sizeof(_ns1__defineInstanceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__defineInstanceRequest *)soap_instantiate__ns1__defineInstanceRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__defineInstanceRequest ** p = (_ns1__defineInstanceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__defineInstanceRequest, sizeof(_ns1__defineInstanceRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__defineInstanceRequest(struct soap *soap, _ns1__defineInstanceRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__defineInstanceRequest);
	if (soap_out_PointerTo_ns1__defineInstanceRequest(soap, tag?tag:"ns1:defineInstanceRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__defineInstanceRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__defineInstanceRequest(struct soap *soap, _ns1__defineInstanceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__defineInstanceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__runSolverResponse(struct soap *soap, _ns1__runSolverResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__runSolverResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__runSolverResponse(struct soap *soap, const char *tag, int id, _ns1__runSolverResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__runSolverResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__runSolverResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__runSolverResponse(struct soap *soap, const char *tag, _ns1__runSolverResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__runSolverResponse **)soap_malloc(soap, sizeof(_ns1__runSolverResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__runSolverResponse *)soap_instantiate__ns1__runSolverResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__runSolverResponse ** p = (_ns1__runSolverResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__runSolverResponse, sizeof(_ns1__runSolverResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__runSolverResponse(struct soap *soap, _ns1__runSolverResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__runSolverResponse);
	if (soap_out_PointerTo_ns1__runSolverResponse(soap, tag?tag:"ns1:runSolverResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__runSolverResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__runSolverResponse(struct soap *soap, _ns1__runSolverResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__runSolverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__runSolverRequest(struct soap *soap, _ns1__runSolverRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__runSolverRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__runSolverRequest(struct soap *soap, const char *tag, int id, _ns1__runSolverRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__runSolverRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__runSolverRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__runSolverRequest(struct soap *soap, const char *tag, _ns1__runSolverRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__runSolverRequest **)soap_malloc(soap, sizeof(_ns1__runSolverRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__runSolverRequest *)soap_instantiate__ns1__runSolverRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__runSolverRequest ** p = (_ns1__runSolverRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__runSolverRequest, sizeof(_ns1__runSolverRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__runSolverRequest(struct soap *soap, _ns1__runSolverRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__runSolverRequest);
	if (soap_out_PointerTo_ns1__runSolverRequest(soap, tag?tag:"ns1:runSolverRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__runSolverRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__runSolverRequest(struct soap *soap, _ns1__runSolverRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__runSolverRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__storeSetMembersResponse(struct soap *soap, _ns1__storeSetMembersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__storeSetMembersResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__storeSetMembersResponse(struct soap *soap, const char *tag, int id, _ns1__storeSetMembersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__storeSetMembersResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__storeSetMembersResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__storeSetMembersResponse(struct soap *soap, const char *tag, _ns1__storeSetMembersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__storeSetMembersResponse **)soap_malloc(soap, sizeof(_ns1__storeSetMembersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__storeSetMembersResponse *)soap_instantiate__ns1__storeSetMembersResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__storeSetMembersResponse ** p = (_ns1__storeSetMembersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__storeSetMembersResponse, sizeof(_ns1__storeSetMembersResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__storeSetMembersResponse(struct soap *soap, _ns1__storeSetMembersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__storeSetMembersResponse);
	if (soap_out_PointerTo_ns1__storeSetMembersResponse(soap, tag?tag:"ns1:storeSetMembersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__storeSetMembersResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__storeSetMembersResponse(struct soap *soap, _ns1__storeSetMembersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__storeSetMembersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__storeSetMembersRequest(struct soap *soap, _ns1__storeSetMembersRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__storeSetMembersRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__storeSetMembersRequest(struct soap *soap, const char *tag, int id, _ns1__storeSetMembersRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__storeSetMembersRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__storeSetMembersRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__storeSetMembersRequest(struct soap *soap, const char *tag, _ns1__storeSetMembersRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__storeSetMembersRequest **)soap_malloc(soap, sizeof(_ns1__storeSetMembersRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__storeSetMembersRequest *)soap_instantiate__ns1__storeSetMembersRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__storeSetMembersRequest ** p = (_ns1__storeSetMembersRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__storeSetMembersRequest, sizeof(_ns1__storeSetMembersRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__storeSetMembersRequest(struct soap *soap, _ns1__storeSetMembersRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__storeSetMembersRequest);
	if (soap_out_PointerTo_ns1__storeSetMembersRequest(soap, tag?tag:"ns1:storeSetMembersRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__storeSetMembersRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__storeSetMembersRequest(struct soap *soap, _ns1__storeSetMembersRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__storeSetMembersRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__definePreferenceResponse(struct soap *soap, _ns1__definePreferenceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__definePreferenceResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__definePreferenceResponse(struct soap *soap, const char *tag, int id, _ns1__definePreferenceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__definePreferenceResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__definePreferenceResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__definePreferenceResponse(struct soap *soap, const char *tag, _ns1__definePreferenceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__definePreferenceResponse **)soap_malloc(soap, sizeof(_ns1__definePreferenceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__definePreferenceResponse *)soap_instantiate__ns1__definePreferenceResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__definePreferenceResponse ** p = (_ns1__definePreferenceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__definePreferenceResponse, sizeof(_ns1__definePreferenceResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__definePreferenceResponse(struct soap *soap, _ns1__definePreferenceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__definePreferenceResponse);
	if (soap_out_PointerTo_ns1__definePreferenceResponse(soap, tag?tag:"ns1:definePreferenceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__definePreferenceResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__definePreferenceResponse(struct soap *soap, _ns1__definePreferenceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__definePreferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__definePreferenceRequest(struct soap *soap, _ns1__definePreferenceRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__definePreferenceRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__definePreferenceRequest(struct soap *soap, const char *tag, int id, _ns1__definePreferenceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__definePreferenceRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__definePreferenceRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__definePreferenceRequest(struct soap *soap, const char *tag, _ns1__definePreferenceRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__definePreferenceRequest **)soap_malloc(soap, sizeof(_ns1__definePreferenceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__definePreferenceRequest *)soap_instantiate__ns1__definePreferenceRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__definePreferenceRequest ** p = (_ns1__definePreferenceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__definePreferenceRequest, sizeof(_ns1__definePreferenceRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__definePreferenceRequest(struct soap *soap, _ns1__definePreferenceRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__definePreferenceRequest);
	if (soap_out_PointerTo_ns1__definePreferenceRequest(soap, tag?tag:"ns1:definePreferenceRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__definePreferenceRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__definePreferenceRequest(struct soap *soap, _ns1__definePreferenceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__definePreferenceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getSetMembersResponse(struct soap *soap, _ns1__getSetMembersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getSetMembersResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getSetMembersResponse(struct soap *soap, const char *tag, int id, _ns1__getSetMembersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getSetMembersResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getSetMembersResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getSetMembersResponse(struct soap *soap, const char *tag, _ns1__getSetMembersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getSetMembersResponse **)soap_malloc(soap, sizeof(_ns1__getSetMembersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getSetMembersResponse *)soap_instantiate__ns1__getSetMembersResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getSetMembersResponse ** p = (_ns1__getSetMembersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getSetMembersResponse, sizeof(_ns1__getSetMembersResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getSetMembersResponse(struct soap *soap, _ns1__getSetMembersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getSetMembersResponse);
	if (soap_out_PointerTo_ns1__getSetMembersResponse(soap, tag?tag:"ns1:getSetMembersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getSetMembersResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getSetMembersResponse(struct soap *soap, _ns1__getSetMembersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getSetMembersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getSetMembersRequest(struct soap *soap, _ns1__getSetMembersRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getSetMembersRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getSetMembersRequest(struct soap *soap, const char *tag, int id, _ns1__getSetMembersRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getSetMembersRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getSetMembersRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getSetMembersRequest(struct soap *soap, const char *tag, _ns1__getSetMembersRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getSetMembersRequest **)soap_malloc(soap, sizeof(_ns1__getSetMembersRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getSetMembersRequest *)soap_instantiate__ns1__getSetMembersRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getSetMembersRequest ** p = (_ns1__getSetMembersRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getSetMembersRequest, sizeof(_ns1__getSetMembersRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getSetMembersRequest(struct soap *soap, _ns1__getSetMembersRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getSetMembersRequest);
	if (soap_out_PointerTo_ns1__getSetMembersRequest(soap, tag?tag:"ns1:getSetMembersRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getSetMembersRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getSetMembersRequest(struct soap *soap, _ns1__getSetMembersRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getSetMembersRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__storeSolutionResponse(struct soap *soap, _ns1__storeSolutionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__storeSolutionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__storeSolutionResponse(struct soap *soap, const char *tag, int id, _ns1__storeSolutionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__storeSolutionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__storeSolutionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__storeSolutionResponse(struct soap *soap, const char *tag, _ns1__storeSolutionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__storeSolutionResponse **)soap_malloc(soap, sizeof(_ns1__storeSolutionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__storeSolutionResponse *)soap_instantiate__ns1__storeSolutionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__storeSolutionResponse ** p = (_ns1__storeSolutionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__storeSolutionResponse, sizeof(_ns1__storeSolutionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__storeSolutionResponse(struct soap *soap, _ns1__storeSolutionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__storeSolutionResponse);
	if (soap_out_PointerTo_ns1__storeSolutionResponse(soap, tag?tag:"ns1:storeSolutionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__storeSolutionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__storeSolutionResponse(struct soap *soap, _ns1__storeSolutionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__storeSolutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__storeSolutionRequest(struct soap *soap, _ns1__storeSolutionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__storeSolutionRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__storeSolutionRequest(struct soap *soap, const char *tag, int id, _ns1__storeSolutionRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__storeSolutionRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__storeSolutionRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__storeSolutionRequest(struct soap *soap, const char *tag, _ns1__storeSolutionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__storeSolutionRequest **)soap_malloc(soap, sizeof(_ns1__storeSolutionRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__storeSolutionRequest *)soap_instantiate__ns1__storeSolutionRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__storeSolutionRequest ** p = (_ns1__storeSolutionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__storeSolutionRequest, sizeof(_ns1__storeSolutionRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__storeSolutionRequest(struct soap *soap, _ns1__storeSolutionRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__storeSolutionRequest);
	if (soap_out_PointerTo_ns1__storeSolutionRequest(soap, tag?tag:"ns1:storeSolutionRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__storeSolutionRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__storeSolutionRequest(struct soap *soap, _ns1__storeSolutionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__storeSolutionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDataSummaryResponse(struct soap *soap, _ns1__getDataSummaryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDataSummaryResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDataSummaryResponse(struct soap *soap, const char *tag, int id, _ns1__getDataSummaryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDataSummaryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getDataSummaryResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDataSummaryResponse(struct soap *soap, const char *tag, _ns1__getDataSummaryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getDataSummaryResponse **)soap_malloc(soap, sizeof(_ns1__getDataSummaryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getDataSummaryResponse *)soap_instantiate__ns1__getDataSummaryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getDataSummaryResponse ** p = (_ns1__getDataSummaryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDataSummaryResponse, sizeof(_ns1__getDataSummaryResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDataSummaryResponse(struct soap *soap, _ns1__getDataSummaryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDataSummaryResponse);
	if (soap_out_PointerTo_ns1__getDataSummaryResponse(soap, tag?tag:"ns1:getDataSummaryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getDataSummaryResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDataSummaryResponse(struct soap *soap, _ns1__getDataSummaryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDataSummaryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDataSummaryRequest(struct soap *soap, _ns1__getDataSummaryRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDataSummaryRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDataSummaryRequest(struct soap *soap, const char *tag, int id, _ns1__getDataSummaryRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDataSummaryRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getDataSummaryRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDataSummaryRequest(struct soap *soap, const char *tag, _ns1__getDataSummaryRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getDataSummaryRequest **)soap_malloc(soap, sizeof(_ns1__getDataSummaryRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getDataSummaryRequest *)soap_instantiate__ns1__getDataSummaryRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getDataSummaryRequest ** p = (_ns1__getDataSummaryRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDataSummaryRequest, sizeof(_ns1__getDataSummaryRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDataSummaryRequest(struct soap *soap, _ns1__getDataSummaryRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDataSummaryRequest);
	if (soap_out_PointerTo_ns1__getDataSummaryRequest(soap, tag?tag:"ns1:getDataSummaryRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getDataSummaryRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDataSummaryRequest(struct soap *soap, _ns1__getDataSummaryRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDataSummaryRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeEntityValuesResponse(struct soap *soap, _ns1__removeEntityValuesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeEntityValuesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeEntityValuesResponse(struct soap *soap, const char *tag, int id, _ns1__removeEntityValuesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeEntityValuesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeEntityValuesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeEntityValuesResponse(struct soap *soap, const char *tag, _ns1__removeEntityValuesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeEntityValuesResponse **)soap_malloc(soap, sizeof(_ns1__removeEntityValuesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeEntityValuesResponse *)soap_instantiate__ns1__removeEntityValuesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeEntityValuesResponse ** p = (_ns1__removeEntityValuesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeEntityValuesResponse, sizeof(_ns1__removeEntityValuesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeEntityValuesResponse(struct soap *soap, _ns1__removeEntityValuesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeEntityValuesResponse);
	if (soap_out_PointerTo_ns1__removeEntityValuesResponse(soap, tag?tag:"ns1:removeEntityValuesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeEntityValuesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeEntityValuesResponse(struct soap *soap, _ns1__removeEntityValuesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeEntityValuesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__removeEntityValuesRequest(struct soap *soap, _ns1__removeEntityValuesRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__removeEntityValuesRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__removeEntityValuesRequest(struct soap *soap, const char *tag, int id, _ns1__removeEntityValuesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__removeEntityValuesRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__removeEntityValuesRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__removeEntityValuesRequest(struct soap *soap, const char *tag, _ns1__removeEntityValuesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__removeEntityValuesRequest **)soap_malloc(soap, sizeof(_ns1__removeEntityValuesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__removeEntityValuesRequest *)soap_instantiate__ns1__removeEntityValuesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__removeEntityValuesRequest ** p = (_ns1__removeEntityValuesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__removeEntityValuesRequest, sizeof(_ns1__removeEntityValuesRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__removeEntityValuesRequest(struct soap *soap, _ns1__removeEntityValuesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__removeEntityValuesRequest);
	if (soap_out_PointerTo_ns1__removeEntityValuesRequest(soap, tag?tag:"ns1:removeEntityValuesRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__removeEntityValuesRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__removeEntityValuesRequest(struct soap *soap, _ns1__removeEntityValuesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__removeEntityValuesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getBatchValuesResponse(struct soap *soap, _ns1__getBatchValuesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getBatchValuesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getBatchValuesResponse(struct soap *soap, const char *tag, int id, _ns1__getBatchValuesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getBatchValuesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getBatchValuesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getBatchValuesResponse(struct soap *soap, const char *tag, _ns1__getBatchValuesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getBatchValuesResponse **)soap_malloc(soap, sizeof(_ns1__getBatchValuesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getBatchValuesResponse *)soap_instantiate__ns1__getBatchValuesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getBatchValuesResponse ** p = (_ns1__getBatchValuesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getBatchValuesResponse, sizeof(_ns1__getBatchValuesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getBatchValuesResponse(struct soap *soap, _ns1__getBatchValuesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getBatchValuesResponse);
	if (soap_out_PointerTo_ns1__getBatchValuesResponse(soap, tag?tag:"ns1:getBatchValuesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getBatchValuesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getBatchValuesResponse(struct soap *soap, _ns1__getBatchValuesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getBatchValuesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getBatchValuesRequest(struct soap *soap, _ns1__getBatchValuesRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getBatchValuesRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getBatchValuesRequest(struct soap *soap, const char *tag, int id, _ns1__getBatchValuesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getBatchValuesRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getBatchValuesRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getBatchValuesRequest(struct soap *soap, const char *tag, _ns1__getBatchValuesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getBatchValuesRequest **)soap_malloc(soap, sizeof(_ns1__getBatchValuesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getBatchValuesRequest *)soap_instantiate__ns1__getBatchValuesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getBatchValuesRequest ** p = (_ns1__getBatchValuesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getBatchValuesRequest, sizeof(_ns1__getBatchValuesRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getBatchValuesRequest(struct soap *soap, _ns1__getBatchValuesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getBatchValuesRequest);
	if (soap_out_PointerTo_ns1__getBatchValuesRequest(soap, tag?tag:"ns1:getBatchValuesRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getBatchValuesRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getBatchValuesRequest(struct soap *soap, _ns1__getBatchValuesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getBatchValuesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getSolutionResponse(struct soap *soap, _ns1__getSolutionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getSolutionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getSolutionResponse(struct soap *soap, const char *tag, int id, _ns1__getSolutionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getSolutionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getSolutionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getSolutionResponse(struct soap *soap, const char *tag, _ns1__getSolutionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getSolutionResponse **)soap_malloc(soap, sizeof(_ns1__getSolutionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getSolutionResponse *)soap_instantiate__ns1__getSolutionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getSolutionResponse ** p = (_ns1__getSolutionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getSolutionResponse, sizeof(_ns1__getSolutionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getSolutionResponse(struct soap *soap, _ns1__getSolutionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getSolutionResponse);
	if (soap_out_PointerTo_ns1__getSolutionResponse(soap, tag?tag:"ns1:getSolutionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getSolutionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getSolutionResponse(struct soap *soap, _ns1__getSolutionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getSolutionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getSolutionRequest(struct soap *soap, _ns1__getSolutionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getSolutionRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getSolutionRequest(struct soap *soap, const char *tag, int id, _ns1__getSolutionRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getSolutionRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getSolutionRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getSolutionRequest(struct soap *soap, const char *tag, _ns1__getSolutionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getSolutionRequest **)soap_malloc(soap, sizeof(_ns1__getSolutionRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getSolutionRequest *)soap_instantiate__ns1__getSolutionRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getSolutionRequest ** p = (_ns1__getSolutionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getSolutionRequest, sizeof(_ns1__getSolutionRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getSolutionRequest(struct soap *soap, _ns1__getSolutionRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getSolutionRequest);
	if (soap_out_PointerTo_ns1__getSolutionRequest(soap, tag?tag:"ns1:getSolutionRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getSolutionRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getSolutionRequest(struct soap *soap, _ns1__getSolutionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getSolutionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getSMSResponse(struct soap *soap, _ns1__getSMSResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getSMSResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getSMSResponse(struct soap *soap, const char *tag, int id, _ns1__getSMSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getSMSResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getSMSResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getSMSResponse(struct soap *soap, const char *tag, _ns1__getSMSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getSMSResponse **)soap_malloc(soap, sizeof(_ns1__getSMSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getSMSResponse *)soap_instantiate__ns1__getSMSResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getSMSResponse ** p = (_ns1__getSMSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getSMSResponse, sizeof(_ns1__getSMSResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getSMSResponse(struct soap *soap, _ns1__getSMSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getSMSResponse);
	if (soap_out_PointerTo_ns1__getSMSResponse(soap, tag?tag:"ns1:getSMSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getSMSResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getSMSResponse(struct soap *soap, _ns1__getSMSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getSMSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getSMSRequest(struct soap *soap, _ns1__getSMSRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getSMSRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getSMSRequest(struct soap *soap, const char *tag, int id, _ns1__getSMSRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getSMSRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getSMSRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getSMSRequest(struct soap *soap, const char *tag, _ns1__getSMSRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getSMSRequest **)soap_malloc(soap, sizeof(_ns1__getSMSRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getSMSRequest *)soap_instantiate__ns1__getSMSRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getSMSRequest ** p = (_ns1__getSMSRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getSMSRequest, sizeof(_ns1__getSMSRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getSMSRequest(struct soap *soap, _ns1__getSMSRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getSMSRequest);
	if (soap_out_PointerTo_ns1__getSMSRequest(soap, tag?tag:"ns1:getSMSRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getSMSRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getSMSRequest(struct soap *soap, _ns1__getSMSRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getSMSRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__storeMainSetResponse(struct soap *soap, _ns1__storeMainSetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__storeMainSetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__storeMainSetResponse(struct soap *soap, const char *tag, int id, _ns1__storeMainSetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__storeMainSetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__storeMainSetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__storeMainSetResponse(struct soap *soap, const char *tag, _ns1__storeMainSetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__storeMainSetResponse **)soap_malloc(soap, sizeof(_ns1__storeMainSetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__storeMainSetResponse *)soap_instantiate__ns1__storeMainSetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__storeMainSetResponse ** p = (_ns1__storeMainSetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__storeMainSetResponse, sizeof(_ns1__storeMainSetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__storeMainSetResponse(struct soap *soap, _ns1__storeMainSetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__storeMainSetResponse);
	if (soap_out_PointerTo_ns1__storeMainSetResponse(soap, tag?tag:"ns1:storeMainSetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__storeMainSetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__storeMainSetResponse(struct soap *soap, _ns1__storeMainSetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__storeMainSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__storeMainSetRequest(struct soap *soap, _ns1__storeMainSetRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__storeMainSetRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__storeMainSetRequest(struct soap *soap, const char *tag, int id, _ns1__storeMainSetRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__storeMainSetRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__storeMainSetRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__storeMainSetRequest(struct soap *soap, const char *tag, _ns1__storeMainSetRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__storeMainSetRequest **)soap_malloc(soap, sizeof(_ns1__storeMainSetRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__storeMainSetRequest *)soap_instantiate__ns1__storeMainSetRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__storeMainSetRequest ** p = (_ns1__storeMainSetRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__storeMainSetRequest, sizeof(_ns1__storeMainSetRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__storeMainSetRequest(struct soap *soap, _ns1__storeMainSetRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__storeMainSetRequest);
	if (soap_out_PointerTo_ns1__storeMainSetRequest(soap, tag?tag:"ns1:storeMainSetRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__storeMainSetRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__storeMainSetRequest(struct soap *soap, _ns1__storeMainSetRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__storeMainSetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getEntityValuesResponse(struct soap *soap, _ns1__getEntityValuesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getEntityValuesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getEntityValuesResponse(struct soap *soap, const char *tag, int id, _ns1__getEntityValuesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getEntityValuesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getEntityValuesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getEntityValuesResponse(struct soap *soap, const char *tag, _ns1__getEntityValuesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getEntityValuesResponse **)soap_malloc(soap, sizeof(_ns1__getEntityValuesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getEntityValuesResponse *)soap_instantiate__ns1__getEntityValuesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getEntityValuesResponse ** p = (_ns1__getEntityValuesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getEntityValuesResponse, sizeof(_ns1__getEntityValuesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getEntityValuesResponse(struct soap *soap, _ns1__getEntityValuesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getEntityValuesResponse);
	if (soap_out_PointerTo_ns1__getEntityValuesResponse(soap, tag?tag:"ns1:getEntityValuesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getEntityValuesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getEntityValuesResponse(struct soap *soap, _ns1__getEntityValuesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getEntityValuesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getEntityValuesRequest(struct soap *soap, _ns1__getEntityValuesRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getEntityValuesRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getEntityValuesRequest(struct soap *soap, const char *tag, int id, _ns1__getEntityValuesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getEntityValuesRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getEntityValuesRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getEntityValuesRequest(struct soap *soap, const char *tag, _ns1__getEntityValuesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getEntityValuesRequest **)soap_malloc(soap, sizeof(_ns1__getEntityValuesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getEntityValuesRequest *)soap_instantiate__ns1__getEntityValuesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getEntityValuesRequest ** p = (_ns1__getEntityValuesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getEntityValuesRequest, sizeof(_ns1__getEntityValuesRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getEntityValuesRequest(struct soap *soap, _ns1__getEntityValuesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getEntityValuesRequest);
	if (soap_out_PointerTo_ns1__getEntityValuesRequest(soap, tag?tag:"ns1:getEntityValuesRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getEntityValuesRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getEntityValuesRequest(struct soap *soap, _ns1__getEntityValuesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getEntityValuesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPreferenceResponse(struct soap *soap, _ns1__getPreferenceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPreferenceResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPreferenceResponse(struct soap *soap, const char *tag, int id, _ns1__getPreferenceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPreferenceResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getPreferenceResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPreferenceResponse(struct soap *soap, const char *tag, _ns1__getPreferenceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getPreferenceResponse **)soap_malloc(soap, sizeof(_ns1__getPreferenceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getPreferenceResponse *)soap_instantiate__ns1__getPreferenceResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getPreferenceResponse ** p = (_ns1__getPreferenceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPreferenceResponse, sizeof(_ns1__getPreferenceResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPreferenceResponse(struct soap *soap, _ns1__getPreferenceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPreferenceResponse);
	if (soap_out_PointerTo_ns1__getPreferenceResponse(soap, tag?tag:"ns1:getPreferenceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getPreferenceResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPreferenceResponse(struct soap *soap, _ns1__getPreferenceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPreferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPreferenceRequest(struct soap *soap, _ns1__getPreferenceRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPreferenceRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPreferenceRequest(struct soap *soap, const char *tag, int id, _ns1__getPreferenceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPreferenceRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getPreferenceRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPreferenceRequest(struct soap *soap, const char *tag, _ns1__getPreferenceRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getPreferenceRequest **)soap_malloc(soap, sizeof(_ns1__getPreferenceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getPreferenceRequest *)soap_instantiate__ns1__getPreferenceRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getPreferenceRequest ** p = (_ns1__getPreferenceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPreferenceRequest, sizeof(_ns1__getPreferenceRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPreferenceRequest(struct soap *soap, _ns1__getPreferenceRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPreferenceRequest);
	if (soap_out_PointerTo_ns1__getPreferenceRequest(soap, tag?tag:"ns1:getPreferenceRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getPreferenceRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPreferenceRequest(struct soap *soap, _ns1__getPreferenceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPreferenceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__defineAnalysisResponse(struct soap *soap, _ns1__defineAnalysisResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__defineAnalysisResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__defineAnalysisResponse(struct soap *soap, const char *tag, int id, _ns1__defineAnalysisResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__defineAnalysisResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__defineAnalysisResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__defineAnalysisResponse(struct soap *soap, const char *tag, _ns1__defineAnalysisResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__defineAnalysisResponse **)soap_malloc(soap, sizeof(_ns1__defineAnalysisResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__defineAnalysisResponse *)soap_instantiate__ns1__defineAnalysisResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__defineAnalysisResponse ** p = (_ns1__defineAnalysisResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__defineAnalysisResponse, sizeof(_ns1__defineAnalysisResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__defineAnalysisResponse(struct soap *soap, _ns1__defineAnalysisResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__defineAnalysisResponse);
	if (soap_out_PointerTo_ns1__defineAnalysisResponse(soap, tag?tag:"ns1:defineAnalysisResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__defineAnalysisResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__defineAnalysisResponse(struct soap *soap, _ns1__defineAnalysisResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__defineAnalysisResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__defineAnalysisRequest(struct soap *soap, _ns1__defineAnalysisRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__defineAnalysisRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__defineAnalysisRequest(struct soap *soap, const char *tag, int id, _ns1__defineAnalysisRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__defineAnalysisRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__defineAnalysisRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__defineAnalysisRequest(struct soap *soap, const char *tag, _ns1__defineAnalysisRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__defineAnalysisRequest **)soap_malloc(soap, sizeof(_ns1__defineAnalysisRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__defineAnalysisRequest *)soap_instantiate__ns1__defineAnalysisRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__defineAnalysisRequest ** p = (_ns1__defineAnalysisRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__defineAnalysisRequest, sizeof(_ns1__defineAnalysisRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__defineAnalysisRequest(struct soap *soap, _ns1__defineAnalysisRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__defineAnalysisRequest);
	if (soap_out_PointerTo_ns1__defineAnalysisRequest(soap, tag?tag:"ns1:defineAnalysisRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__defineAnalysisRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__defineAnalysisRequest(struct soap *soap, _ns1__defineAnalysisRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__defineAnalysisRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__runScenarioResponse(struct soap *soap, _ns1__runScenarioResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__runScenarioResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__runScenarioResponse(struct soap *soap, const char *tag, int id, _ns1__runScenarioResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__runScenarioResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__runScenarioResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__runScenarioResponse(struct soap *soap, const char *tag, _ns1__runScenarioResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__runScenarioResponse **)soap_malloc(soap, sizeof(_ns1__runScenarioResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__runScenarioResponse *)soap_instantiate__ns1__runScenarioResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__runScenarioResponse ** p = (_ns1__runScenarioResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__runScenarioResponse, sizeof(_ns1__runScenarioResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__runScenarioResponse(struct soap *soap, _ns1__runScenarioResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__runScenarioResponse);
	if (soap_out_PointerTo_ns1__runScenarioResponse(soap, tag?tag:"ns1:runScenarioResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__runScenarioResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__runScenarioResponse(struct soap *soap, _ns1__runScenarioResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__runScenarioResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__runScenarioRequest(struct soap *soap, _ns1__runScenarioRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__runScenarioRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__runScenarioRequest(struct soap *soap, const char *tag, int id, _ns1__runScenarioRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__runScenarioRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__runScenarioRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__runScenarioRequest(struct soap *soap, const char *tag, _ns1__runScenarioRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__runScenarioRequest **)soap_malloc(soap, sizeof(_ns1__runScenarioRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__runScenarioRequest *)soap_instantiate__ns1__runScenarioRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__runScenarioRequest ** p = (_ns1__runScenarioRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__runScenarioRequest, sizeof(_ns1__runScenarioRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__runScenarioRequest(struct soap *soap, _ns1__runScenarioRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__runScenarioRequest);
	if (soap_out_PointerTo_ns1__runScenarioRequest(soap, tag?tag:"ns1:runScenarioRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__runScenarioRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__runScenarioRequest(struct soap *soap, _ns1__runScenarioRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__runScenarioRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__defineModelDataResponse(struct soap *soap, _ns1__defineModelDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__defineModelDataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__defineModelDataResponse(struct soap *soap, const char *tag, int id, _ns1__defineModelDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__defineModelDataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__defineModelDataResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__defineModelDataResponse(struct soap *soap, const char *tag, _ns1__defineModelDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__defineModelDataResponse **)soap_malloc(soap, sizeof(_ns1__defineModelDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__defineModelDataResponse *)soap_instantiate__ns1__defineModelDataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__defineModelDataResponse ** p = (_ns1__defineModelDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__defineModelDataResponse, sizeof(_ns1__defineModelDataResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__defineModelDataResponse(struct soap *soap, _ns1__defineModelDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__defineModelDataResponse);
	if (soap_out_PointerTo_ns1__defineModelDataResponse(soap, tag?tag:"ns1:defineModelDataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__defineModelDataResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__defineModelDataResponse(struct soap *soap, _ns1__defineModelDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__defineModelDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__defineModelDataRequest(struct soap *soap, _ns1__defineModelDataRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__defineModelDataRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__defineModelDataRequest(struct soap *soap, const char *tag, int id, _ns1__defineModelDataRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__defineModelDataRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__defineModelDataRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__defineModelDataRequest(struct soap *soap, const char *tag, _ns1__defineModelDataRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__defineModelDataRequest **)soap_malloc(soap, sizeof(_ns1__defineModelDataRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__defineModelDataRequest *)soap_instantiate__ns1__defineModelDataRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__defineModelDataRequest ** p = (_ns1__defineModelDataRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__defineModelDataRequest, sizeof(_ns1__defineModelDataRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__defineModelDataRequest(struct soap *soap, _ns1__defineModelDataRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__defineModelDataRequest);
	if (soap_out_PointerTo_ns1__defineModelDataRequest(soap, tag?tag:"ns1:defineModelDataRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__defineModelDataRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__defineModelDataRequest(struct soap *soap, _ns1__defineModelDataRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__defineModelDataRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAnalysesResponse(struct soap *soap, _ns1__getAnalysesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAnalysesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAnalysesResponse(struct soap *soap, const char *tag, int id, _ns1__getAnalysesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAnalysesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getAnalysesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAnalysesResponse(struct soap *soap, const char *tag, _ns1__getAnalysesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getAnalysesResponse **)soap_malloc(soap, sizeof(_ns1__getAnalysesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getAnalysesResponse *)soap_instantiate__ns1__getAnalysesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getAnalysesResponse ** p = (_ns1__getAnalysesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAnalysesResponse, sizeof(_ns1__getAnalysesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAnalysesResponse(struct soap *soap, _ns1__getAnalysesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAnalysesResponse);
	if (soap_out_PointerTo_ns1__getAnalysesResponse(soap, tag?tag:"ns1:getAnalysesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getAnalysesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAnalysesResponse(struct soap *soap, _ns1__getAnalysesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAnalysesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAnalysesRequest(struct soap *soap, _ns1__getAnalysesRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAnalysesRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAnalysesRequest(struct soap *soap, const char *tag, int id, _ns1__getAnalysesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAnalysesRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getAnalysesRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAnalysesRequest(struct soap *soap, const char *tag, _ns1__getAnalysesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getAnalysesRequest **)soap_malloc(soap, sizeof(_ns1__getAnalysesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getAnalysesRequest *)soap_instantiate__ns1__getAnalysesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getAnalysesRequest ** p = (_ns1__getAnalysesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAnalysesRequest, sizeof(_ns1__getAnalysesRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAnalysesRequest(struct soap *soap, _ns1__getAnalysesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAnalysesRequest);
	if (soap_out_PointerTo_ns1__getAnalysesRequest(soap, tag?tag:"ns1:getAnalysesRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getAnalysesRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAnalysesRequest(struct soap *soap, _ns1__getAnalysesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAnalysesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateSolverStatusResponse(struct soap *soap, _ns1__updateSolverStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateSolverStatusResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateSolverStatusResponse(struct soap *soap, const char *tag, int id, _ns1__updateSolverStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateSolverStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__updateSolverStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateSolverStatusResponse(struct soap *soap, const char *tag, _ns1__updateSolverStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__updateSolverStatusResponse **)soap_malloc(soap, sizeof(_ns1__updateSolverStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__updateSolverStatusResponse *)soap_instantiate__ns1__updateSolverStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__updateSolverStatusResponse ** p = (_ns1__updateSolverStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateSolverStatusResponse, sizeof(_ns1__updateSolverStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateSolverStatusResponse(struct soap *soap, _ns1__updateSolverStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateSolverStatusResponse);
	if (soap_out_PointerTo_ns1__updateSolverStatusResponse(soap, tag?tag:"ns1:updateSolverStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__updateSolverStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateSolverStatusResponse(struct soap *soap, _ns1__updateSolverStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateSolverStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateSolverStatusRequest(struct soap *soap, _ns1__updateSolverStatusRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateSolverStatusRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateSolverStatusRequest(struct soap *soap, const char *tag, int id, _ns1__updateSolverStatusRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateSolverStatusRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__updateSolverStatusRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateSolverStatusRequest(struct soap *soap, const char *tag, _ns1__updateSolverStatusRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__updateSolverStatusRequest **)soap_malloc(soap, sizeof(_ns1__updateSolverStatusRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__updateSolverStatusRequest *)soap_instantiate__ns1__updateSolverStatusRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__updateSolverStatusRequest ** p = (_ns1__updateSolverStatusRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateSolverStatusRequest, sizeof(_ns1__updateSolverStatusRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateSolverStatusRequest(struct soap *soap, _ns1__updateSolverStatusRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateSolverStatusRequest);
	if (soap_out_PointerTo_ns1__updateSolverStatusRequest(soap, tag?tag:"ns1:updateSolverStatusRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__updateSolverStatusRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateSolverStatusRequest(struct soap *soap, _ns1__updateSolverStatusRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateSolverStatusRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__changeModelDataStatusResponse(struct soap *soap, _ns1__changeModelDataStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__changeModelDataStatusResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__changeModelDataStatusResponse(struct soap *soap, const char *tag, int id, _ns1__changeModelDataStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__changeModelDataStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__changeModelDataStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__changeModelDataStatusResponse(struct soap *soap, const char *tag, _ns1__changeModelDataStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__changeModelDataStatusResponse **)soap_malloc(soap, sizeof(_ns1__changeModelDataStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__changeModelDataStatusResponse *)soap_instantiate__ns1__changeModelDataStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__changeModelDataStatusResponse ** p = (_ns1__changeModelDataStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__changeModelDataStatusResponse, sizeof(_ns1__changeModelDataStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__changeModelDataStatusResponse(struct soap *soap, _ns1__changeModelDataStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__changeModelDataStatusResponse);
	if (soap_out_PointerTo_ns1__changeModelDataStatusResponse(soap, tag?tag:"ns1:changeModelDataStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__changeModelDataStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__changeModelDataStatusResponse(struct soap *soap, _ns1__changeModelDataStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__changeModelDataStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__changeModelDataStatusRequest(struct soap *soap, _ns1__changeModelDataStatusRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__changeModelDataStatusRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__changeModelDataStatusRequest(struct soap *soap, const char *tag, int id, _ns1__changeModelDataStatusRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__changeModelDataStatusRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__changeModelDataStatusRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__changeModelDataStatusRequest(struct soap *soap, const char *tag, _ns1__changeModelDataStatusRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__changeModelDataStatusRequest **)soap_malloc(soap, sizeof(_ns1__changeModelDataStatusRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__changeModelDataStatusRequest *)soap_instantiate__ns1__changeModelDataStatusRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__changeModelDataStatusRequest ** p = (_ns1__changeModelDataStatusRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__changeModelDataStatusRequest, sizeof(_ns1__changeModelDataStatusRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__changeModelDataStatusRequest(struct soap *soap, _ns1__changeModelDataStatusRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__changeModelDataStatusRequest);
	if (soap_out_PointerTo_ns1__changeModelDataStatusRequest(soap, tag?tag:"ns1:changeModelDataStatusRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__changeModelDataStatusRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__changeModelDataStatusRequest(struct soap *soap, _ns1__changeModelDataStatusRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__changeModelDataStatusRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__preference(struct soap *soap, ns4__preference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__preference))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__preference(struct soap *soap, const char *tag, int id, ns4__preference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__preference);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__preference ** SOAP_FMAC4 soap_in_PointerTons4__preference(struct soap *soap, const char *tag, ns4__preference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__preference **)soap_malloc(soap, sizeof(ns4__preference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__preference *)soap_instantiate_ns4__preference(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__preference ** p = (ns4__preference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__preference, sizeof(ns4__preference), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__preference(struct soap *soap, ns4__preference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__preference);
	if (soap_out_PointerTons4__preference(soap, tag?tag:"ns4:preference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__preference ** SOAP_FMAC4 soap_get_PointerTons4__preference(struct soap *soap, ns4__preference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__preference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__analysis(struct soap *soap, ns4__analysis *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__analysis))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__analysis(struct soap *soap, const char *tag, int id, ns4__analysis *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__analysis);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__analysis ** SOAP_FMAC4 soap_in_PointerTons4__analysis(struct soap *soap, const char *tag, ns4__analysis **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__analysis **)soap_malloc(soap, sizeof(ns4__analysis *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__analysis *)soap_instantiate_ns4__analysis(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__analysis ** p = (ns4__analysis **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__analysis, sizeof(ns4__analysis), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__analysis(struct soap *soap, ns4__analysis *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__analysis);
	if (soap_out_PointerTons4__analysis(soap, tag?tag:"ns4:analysis", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__analysis ** SOAP_FMAC4 soap_get_PointerTons4__analysis(struct soap *soap, ns4__analysis **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__analysis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__modelInstance(struct soap *soap, ns3__modelInstance *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__modelInstance))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__modelInstance(struct soap *soap, const char *tag, int id, ns3__modelInstance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__modelInstance);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__modelInstance ** SOAP_FMAC4 soap_in_PointerTons3__modelInstance(struct soap *soap, const char *tag, ns3__modelInstance **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__modelInstance **)soap_malloc(soap, sizeof(ns3__modelInstance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__modelInstance *)soap_instantiate_ns3__modelInstance(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__modelInstance ** p = (ns3__modelInstance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__modelInstance, sizeof(ns3__modelInstance), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__modelInstance(struct soap *soap, ns3__modelInstance *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__modelInstance);
	if (soap_out_PointerTons3__modelInstance(soap, tag?tag:"ns3:modelInstance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__modelInstance ** SOAP_FMAC4 soap_get_PointerTons3__modelInstance(struct soap *soap, ns3__modelInstance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__modelInstance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__modelData(struct soap *soap, ns3__modelData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__modelData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__modelData(struct soap *soap, const char *tag, int id, ns3__modelData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__modelData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__modelData ** SOAP_FMAC4 soap_in_PointerTons3__modelData(struct soap *soap, const char *tag, ns3__modelData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__modelData **)soap_malloc(soap, sizeof(ns3__modelData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__modelData *)soap_instantiate_ns3__modelData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__modelData ** p = (ns3__modelData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__modelData, sizeof(ns3__modelData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__modelData(struct soap *soap, ns3__modelData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__modelData);
	if (soap_out_PointerTons3__modelData(soap, tag?tag:"ns3:modelData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__modelData ** SOAP_FMAC4 soap_get_PointerTons3__modelData(struct soap *soap, ns3__modelData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__modelData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__batchValues(struct soap *soap, ns3__batchValues *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__batchValues))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__batchValues(struct soap *soap, const char *tag, int id, ns3__batchValues *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__batchValues);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__batchValues ** SOAP_FMAC4 soap_in_PointerTons3__batchValues(struct soap *soap, const char *tag, ns3__batchValues **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__batchValues **)soap_malloc(soap, sizeof(ns3__batchValues *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__batchValues *)soap_instantiate_ns3__batchValues(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__batchValues ** p = (ns3__batchValues **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__batchValues, sizeof(ns3__batchValues), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__batchValues(struct soap *soap, ns3__batchValues *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__batchValues);
	if (soap_out_PointerTons3__batchValues(soap, tag?tag:"ns3:batchValues", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__batchValues ** SOAP_FMAC4 soap_get_PointerTons3__batchValues(struct soap *soap, ns3__batchValues **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__batchValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__tupleValue(struct soap *soap, ns3__tupleValue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__tupleValue))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__tupleValue(struct soap *soap, const char *tag, int id, ns3__tupleValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__tupleValue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__tupleValue ** SOAP_FMAC4 soap_in_PointerTons3__tupleValue(struct soap *soap, const char *tag, ns3__tupleValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__tupleValue **)soap_malloc(soap, sizeof(ns3__tupleValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__tupleValue *)soap_instantiate_ns3__tupleValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__tupleValue ** p = (ns3__tupleValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__tupleValue, sizeof(ns3__tupleValue), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__tupleValue(struct soap *soap, ns3__tupleValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__tupleValue);
	if (soap_out_PointerTons3__tupleValue(soap, tag?tag:"ns3:tupleValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__tupleValue ** SOAP_FMAC4 soap_get_PointerTons3__tupleValue(struct soap *soap, ns3__tupleValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__tupleValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__modelSpec(struct soap *soap, ns2__modelSpec *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__modelSpec))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__modelSpec(struct soap *soap, const char *tag, int id, ns2__modelSpec *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__modelSpec);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__modelSpec ** SOAP_FMAC4 soap_in_PointerTons2__modelSpec(struct soap *soap, const char *tag, ns2__modelSpec **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__modelSpec **)soap_malloc(soap, sizeof(ns2__modelSpec *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__modelSpec *)soap_instantiate_ns2__modelSpec(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__modelSpec ** p = (ns2__modelSpec **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__modelSpec, sizeof(ns2__modelSpec), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__modelSpec(struct soap *soap, ns2__modelSpec *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__modelSpec);
	if (soap_out_PointerTons2__modelSpec(soap, tag?tag:"ns2:modelSpec", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__modelSpec ** SOAP_FMAC4 soap_get_PointerTons2__modelSpec(struct soap *soap, ns2__modelSpec **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__modelSpec(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__entityValues(struct soap *soap, ns3__entityValues *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__entityValues))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__entityValues(struct soap *soap, const char *tag, int id, ns3__entityValues *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__entityValues);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__entityValues ** SOAP_FMAC4 soap_in_PointerTons3__entityValues(struct soap *soap, const char *tag, ns3__entityValues **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__entityValues **)soap_malloc(soap, sizeof(ns3__entityValues *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__entityValues *)soap_instantiate_ns3__entityValues(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__entityValues ** p = (ns3__entityValues **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__entityValues, sizeof(ns3__entityValues), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__entityValues(struct soap *soap, ns3__entityValues *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__entityValues);
	if (soap_out_PointerTons3__entityValues(soap, tag?tag:"ns3:entityValues", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__entityValues ** SOAP_FMAC4 soap_get_PointerTons3__entityValues(struct soap *soap, ns3__entityValues **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__entityValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__setMembers(struct soap *soap, ns3__setMembers *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__setMembers))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__setMembers(struct soap *soap, const char *tag, int id, ns3__setMembers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__setMembers);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__setMembers ** SOAP_FMAC4 soap_in_PointerTons3__setMembers(struct soap *soap, const char *tag, ns3__setMembers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__setMembers **)soap_malloc(soap, sizeof(ns3__setMembers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__setMembers *)soap_instantiate_ns3__setMembers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__setMembers ** p = (ns3__setMembers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__setMembers, sizeof(ns3__setMembers), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__setMembers(struct soap *soap, ns3__setMembers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__setMembers);
	if (soap_out_PointerTons3__setMembers(soap, tag?tag:"ns3:setMembers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__setMembers ** SOAP_FMAC4 soap_get_PointerTons3__setMembers(struct soap *soap, ns3__setMembers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__setMembers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__tupleValues(struct soap *soap, ns3__tupleValues *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__tupleValues))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__tupleValues(struct soap *soap, const char *tag, int id, ns3__tupleValues *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__tupleValues);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__tupleValues ** SOAP_FMAC4 soap_in_PointerTons3__tupleValues(struct soap *soap, const char *tag, ns3__tupleValues **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__tupleValues **)soap_malloc(soap, sizeof(ns3__tupleValues *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__tupleValues *)soap_instantiate_ns3__tupleValues(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__tupleValues ** p = (ns3__tupleValues **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__tupleValues, sizeof(ns3__tupleValues), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__tupleValues(struct soap *soap, ns3__tupleValues *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__tupleValues);
	if (soap_out_PointerTons3__tupleValues(soap, tag?tag:"ns3:tupleValues", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__tupleValues ** SOAP_FMAC4 soap_get_PointerTons3__tupleValues(struct soap *soap, ns3__tupleValues **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__tupleValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__tupleMembers(struct soap *soap, ns3__tupleMembers *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__tupleMembers))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__tupleMembers(struct soap *soap, const char *tag, int id, ns3__tupleMembers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__tupleMembers);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__tupleMembers ** SOAP_FMAC4 soap_in_PointerTons3__tupleMembers(struct soap *soap, const char *tag, ns3__tupleMembers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__tupleMembers **)soap_malloc(soap, sizeof(ns3__tupleMembers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__tupleMembers *)soap_instantiate_ns3__tupleMembers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__tupleMembers ** p = (ns3__tupleMembers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__tupleMembers, sizeof(ns3__tupleMembers), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__tupleMembers(struct soap *soap, ns3__tupleMembers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__tupleMembers);
	if (soap_out_PointerTons3__tupleMembers(soap, tag?tag:"ns3:tupleMembers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__tupleMembers ** SOAP_FMAC4 soap_get_PointerTons3__tupleMembers(struct soap *soap, ns3__tupleMembers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__tupleMembers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__value(struct soap *soap, ns3__value *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__value))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__value(struct soap *soap, const char *tag, int id, ns3__value *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__value);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__value ** SOAP_FMAC4 soap_in_PointerTons3__value(struct soap *soap, const char *tag, ns3__value **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__value **)soap_malloc(soap, sizeof(ns3__value *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__value *)soap_instantiate_ns3__value(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__value ** p = (ns3__value **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__value, sizeof(ns3__value), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__value(struct soap *soap, ns3__value *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__value);
	if (soap_out_PointerTons3__value(soap, tag?tag:"ns3:value", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__value ** SOAP_FMAC4 soap_get_PointerTons3__value(struct soap *soap, ns3__value **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__value(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__memberDic(struct soap *soap, ns3__memberDic *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__memberDic))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__memberDic(struct soap *soap, const char *tag, int id, ns3__memberDic *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__memberDic);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__memberDic ** SOAP_FMAC4 soap_in_PointerTons3__memberDic(struct soap *soap, const char *tag, ns3__memberDic **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__memberDic **)soap_malloc(soap, sizeof(ns3__memberDic *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__memberDic *)soap_instantiate_ns3__memberDic(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__memberDic ** p = (ns3__memberDic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__memberDic, sizeof(ns3__memberDic), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__memberDic(struct soap *soap, ns3__memberDic *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__memberDic);
	if (soap_out_PointerTons3__memberDic(soap, tag?tag:"ns3:memberDic", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__memberDic ** SOAP_FMAC4 soap_get_PointerTons3__memberDic(struct soap *soap, ns3__memberDic **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__memberDic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__shortName(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__shortName))
		soap_serialize_ns2__shortName(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__shortName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__shortName);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__shortName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons2__shortName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__shortName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__shortName, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__shortName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__shortName);
	if (soap_out_PointerTons2__shortName(soap, tag?tag:"ns2:shortName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons2__shortName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__shortName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__entityRole(struct soap *soap, enum ns2__entityRole *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__entityRole);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__entityRole(struct soap *soap, const char *tag, int id, enum ns2__entityRole *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__entityRole);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__entityRole(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__entityRole ** SOAP_FMAC4 soap_in_PointerTons2__entityRole(struct soap *soap, const char *tag, enum ns2__entityRole **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__entityRole **)soap_malloc(soap, sizeof(enum ns2__entityRole *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__entityRole(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__entityRole **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__entityRole, sizeof(enum ns2__entityRole), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__entityRole(struct soap *soap, enum ns2__entityRole *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__entityRole);
	if (soap_out_PointerTons2__entityRole(soap, tag?tag:"ns2:entityRole", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__entityRole ** SOAP_FMAC4 soap_get_PointerTons2__entityRole(struct soap *soap, enum ns2__entityRole **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__entityRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__iteratorContainer(struct soap *soap, ns2__iteratorContainer *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__iteratorContainer))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__iteratorContainer(struct soap *soap, const char *tag, int id, ns2__iteratorContainer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__iteratorContainer);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__iteratorContainer ** SOAP_FMAC4 soap_in_PointerTons2__iteratorContainer(struct soap *soap, const char *tag, ns2__iteratorContainer **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__iteratorContainer **)soap_malloc(soap, sizeof(ns2__iteratorContainer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__iteratorContainer *)soap_instantiate_ns2__iteratorContainer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__iteratorContainer ** p = (ns2__iteratorContainer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__iteratorContainer, sizeof(ns2__iteratorContainer), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__iteratorContainer(struct soap *soap, ns2__iteratorContainer *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__iteratorContainer);
	if (soap_out_PointerTons2__iteratorContainer(soap, tag?tag:"ns2:iteratorContainer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__iteratorContainer ** SOAP_FMAC4 soap_get_PointerTons2__iteratorContainer(struct soap *soap, ns2__iteratorContainer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__iteratorContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__entitySpec(struct soap *soap, ns2__entitySpec *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__entitySpec))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__entitySpec(struct soap *soap, const char *tag, int id, ns2__entitySpec *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__entitySpec);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__entitySpec ** SOAP_FMAC4 soap_in_PointerTons2__entitySpec(struct soap *soap, const char *tag, ns2__entitySpec **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__entitySpec **)soap_malloc(soap, sizeof(ns2__entitySpec *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__entitySpec *)soap_instantiate_ns2__entitySpec(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__entitySpec ** p = (ns2__entitySpec **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__entitySpec, sizeof(ns2__entitySpec), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__entitySpec(struct soap *soap, ns2__entitySpec *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__entitySpec);
	if (soap_out_PointerTons2__entitySpec(soap, tag?tag:"ns2:entitySpec", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__entitySpec ** SOAP_FMAC4 soap_get_PointerTons2__entitySpec(struct soap *soap, ns2__entitySpec **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__entitySpec(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__setSpec(struct soap *soap, ns2__setSpec *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__setSpec))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__setSpec(struct soap *soap, const char *tag, int id, ns2__setSpec *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__setSpec);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__setSpec ** SOAP_FMAC4 soap_in_PointerTons2__setSpec(struct soap *soap, const char *tag, ns2__setSpec **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__setSpec **)soap_malloc(soap, sizeof(ns2__setSpec *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__setSpec *)soap_instantiate_ns2__setSpec(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__setSpec ** p = (ns2__setSpec **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__setSpec, sizeof(ns2__setSpec), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__setSpec(struct soap *soap, ns2__setSpec *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__setSpec);
	if (soap_out_PointerTons2__setSpec(soap, tag?tag:"ns2:setSpec", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__setSpec ** SOAP_FMAC4 soap_get_PointerTons2__setSpec(struct soap *soap, ns2__setSpec **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__setSpec(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__description(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__description))
		soap_serialize_ns2__description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__description(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__description);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__description(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons2__description(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__description, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__description(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__description);
	if (soap_out_PointerTons2__description(soap, tag?tag:"ns2:description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons2__description(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__name(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__name))
		soap_serialize_ns2__name(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__name(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__name);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__name(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons2__name(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__name(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__name, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__name(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__name);
	if (soap_out_PointerTons2__name(soap, tag?tag:"ns2:name", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons2__name(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__preference(struct soap *soap, std::vector<ns4__preference * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__preference(struct soap *soap, const std::vector<ns4__preference * >*a)
{
	for (std::vector<ns4__preference * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__preference(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__preference(struct soap *soap, const char *tag, int id, const std::vector<ns4__preference * >*a, const char *type)
{
	for (std::vector<ns4__preference * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__preference(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__preference * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__preference(struct soap *soap, const char *tag, std::vector<ns4__preference * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__preference(soap, -1)))
		return NULL;
	ns4__preference *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__preference, SOAP_TYPE_std__vectorTemplateOfPointerTons4__preference, sizeof(ns4__preference), 1))
				break;
			if (!soap_in_PointerTons4__preference(soap, tag, NULL, "ns4:preference"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons4__preference(soap, tag, &n, "ns4:preference"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__preference * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__preference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__preference(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__preference, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__preference * >);
		if (size)
			*size = sizeof(std::vector<ns4__preference * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__preference * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns4__preference * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns4__preference * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__preference(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__preference * > %p -> %p\n", q, p));
	*(std::vector<ns4__preference * >*)p = *(std::vector<ns4__preference * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons4__analysis(struct soap *soap, std::vector<ns4__analysis * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons4__analysis(struct soap *soap, const std::vector<ns4__analysis * >*a)
{
	for (std::vector<ns4__analysis * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons4__analysis(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons4__analysis(struct soap *soap, const char *tag, int id, const std::vector<ns4__analysis * >*a, const char *type)
{
	for (std::vector<ns4__analysis * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons4__analysis(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns4__analysis * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons4__analysis(struct soap *soap, const char *tag, std::vector<ns4__analysis * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons4__analysis(soap, -1)))
		return NULL;
	ns4__analysis *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns4__analysis, SOAP_TYPE_std__vectorTemplateOfPointerTons4__analysis, sizeof(ns4__analysis), 1))
				break;
			if (!soap_in_PointerTons4__analysis(soap, tag, NULL, "ns4:analysis"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons4__analysis(soap, tag, &n, "ns4:analysis"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns4__analysis * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons4__analysis(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons4__analysis(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons4__analysis, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__analysis * >);
		if (size)
			*size = sizeof(std::vector<ns4__analysis * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns4__analysis * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns4__analysis * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns4__analysis * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons4__analysis(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns4__analysis * > %p -> %p\n", q, p));
	*(std::vector<ns4__analysis * >*)p = *(std::vector<ns4__analysis * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__modelInstance(struct soap *soap, std::vector<ns3__modelInstance * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__modelInstance(struct soap *soap, const std::vector<ns3__modelInstance * >*a)
{
	for (std::vector<ns3__modelInstance * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__modelInstance(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__modelInstance(struct soap *soap, const char *tag, int id, const std::vector<ns3__modelInstance * >*a, const char *type)
{
	for (std::vector<ns3__modelInstance * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__modelInstance(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__modelInstance * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__modelInstance(struct soap *soap, const char *tag, std::vector<ns3__modelInstance * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__modelInstance(soap, -1)))
		return NULL;
	ns3__modelInstance *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns3__modelInstance, SOAP_TYPE_std__vectorTemplateOfPointerTons3__modelInstance, sizeof(ns3__modelInstance), 1))
				break;
			if (!soap_in_PointerTons3__modelInstance(soap, tag, NULL, "ns3:modelInstance"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons3__modelInstance(soap, tag, &n, "ns3:modelInstance"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__modelInstance * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__modelInstance(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__modelInstance(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons3__modelInstance, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__modelInstance * >);
		if (size)
			*size = sizeof(std::vector<ns3__modelInstance * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__modelInstance * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns3__modelInstance * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns3__modelInstance * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__modelInstance(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__modelInstance * > %p -> %p\n", q, p));
	*(std::vector<ns3__modelInstance * >*)p = *(std::vector<ns3__modelInstance * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__batchValues(struct soap *soap, std::vector<ns3__batchValues * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__batchValues(struct soap *soap, const std::vector<ns3__batchValues * >*a)
{
	for (std::vector<ns3__batchValues * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__batchValues(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__batchValues(struct soap *soap, const char *tag, int id, const std::vector<ns3__batchValues * >*a, const char *type)
{
	for (std::vector<ns3__batchValues * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__batchValues(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__batchValues * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__batchValues(struct soap *soap, const char *tag, std::vector<ns3__batchValues * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__batchValues(soap, -1)))
		return NULL;
	ns3__batchValues *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns3__batchValues, SOAP_TYPE_std__vectorTemplateOfPointerTons3__batchValues, sizeof(ns3__batchValues), 1))
				break;
			if (!soap_in_PointerTons3__batchValues(soap, tag, NULL, "ns3:batchValues"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons3__batchValues(soap, tag, &n, "ns3:batchValues"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__batchValues * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__batchValues(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__batchValues(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons3__batchValues, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__batchValues * >);
		if (size)
			*size = sizeof(std::vector<ns3__batchValues * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__batchValues * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns3__batchValues * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns3__batchValues * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__batchValues(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__batchValues * > %p -> %p\n", q, p));
	*(std::vector<ns3__batchValues * >*)p = *(std::vector<ns3__batchValues * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__tupleValue(struct soap *soap, std::vector<ns3__tupleValue * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__tupleValue(struct soap *soap, const std::vector<ns3__tupleValue * >*a)
{
	for (std::vector<ns3__tupleValue * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__tupleValue(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__tupleValue(struct soap *soap, const char *tag, int id, const std::vector<ns3__tupleValue * >*a, const char *type)
{
	for (std::vector<ns3__tupleValue * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__tupleValue(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__tupleValue * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__tupleValue(struct soap *soap, const char *tag, std::vector<ns3__tupleValue * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__tupleValue(soap, -1)))
		return NULL;
	ns3__tupleValue *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns3__tupleValue, SOAP_TYPE_std__vectorTemplateOfPointerTons3__tupleValue, sizeof(ns3__tupleValue), 1))
				break;
			if (!soap_in_PointerTons3__tupleValue(soap, tag, NULL, "ns3:tupleValue"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons3__tupleValue(soap, tag, &n, "ns3:tupleValue"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__tupleValue * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__tupleValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__tupleValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons3__tupleValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__tupleValue * >);
		if (size)
			*size = sizeof(std::vector<ns3__tupleValue * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__tupleValue * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns3__tupleValue * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns3__tupleValue * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__tupleValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__tupleValue * > %p -> %p\n", q, p));
	*(std::vector<ns3__tupleValue * >*)p = *(std::vector<ns3__tupleValue * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__entityValues(struct soap *soap, std::vector<ns3__entityValues * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__entityValues(struct soap *soap, const std::vector<ns3__entityValues * >*a)
{
	for (std::vector<ns3__entityValues * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__entityValues(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__entityValues(struct soap *soap, const char *tag, int id, const std::vector<ns3__entityValues * >*a, const char *type)
{
	for (std::vector<ns3__entityValues * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__entityValues(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__entityValues * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__entityValues(struct soap *soap, const char *tag, std::vector<ns3__entityValues * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__entityValues(soap, -1)))
		return NULL;
	ns3__entityValues *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns3__entityValues, SOAP_TYPE_std__vectorTemplateOfPointerTons3__entityValues, sizeof(ns3__entityValues), 1))
				break;
			if (!soap_in_PointerTons3__entityValues(soap, tag, NULL, "ns3:entityValues"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons3__entityValues(soap, tag, &n, "ns3:entityValues"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__entityValues * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__entityValues(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__entityValues(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons3__entityValues, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__entityValues * >);
		if (size)
			*size = sizeof(std::vector<ns3__entityValues * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__entityValues * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns3__entityValues * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns3__entityValues * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__entityValues(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__entityValues * > %p -> %p\n", q, p));
	*(std::vector<ns3__entityValues * >*)p = *(std::vector<ns3__entityValues * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__setMembers(struct soap *soap, std::vector<ns3__setMembers * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__setMembers(struct soap *soap, const std::vector<ns3__setMembers * >*a)
{
	for (std::vector<ns3__setMembers * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__setMembers(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__setMembers(struct soap *soap, const char *tag, int id, const std::vector<ns3__setMembers * >*a, const char *type)
{
	for (std::vector<ns3__setMembers * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__setMembers(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__setMembers * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__setMembers(struct soap *soap, const char *tag, std::vector<ns3__setMembers * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__setMembers(soap, -1)))
		return NULL;
	ns3__setMembers *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns3__setMembers, SOAP_TYPE_std__vectorTemplateOfPointerTons3__setMembers, sizeof(ns3__setMembers), 1))
				break;
			if (!soap_in_PointerTons3__setMembers(soap, tag, NULL, "ns3:setMembers"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons3__setMembers(soap, tag, &n, "ns3:setMembers"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__setMembers * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__setMembers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__setMembers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons3__setMembers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__setMembers * >);
		if (size)
			*size = sizeof(std::vector<ns3__setMembers * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__setMembers * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns3__setMembers * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns3__setMembers * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__setMembers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__setMembers * > %p -> %p\n", q, p));
	*(std::vector<ns3__setMembers * >*)p = *(std::vector<ns3__setMembers * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__value(struct soap *soap, std::vector<ns3__value * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__value(struct soap *soap, const std::vector<ns3__value * >*a)
{
	for (std::vector<ns3__value * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__value(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__value(struct soap *soap, const char *tag, int id, const std::vector<ns3__value * >*a, const char *type)
{
	for (std::vector<ns3__value * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__value(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__value * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__value(struct soap *soap, const char *tag, std::vector<ns3__value * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__value(soap, -1)))
		return NULL;
	ns3__value *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns3__value, SOAP_TYPE_std__vectorTemplateOfPointerTons3__value, sizeof(ns3__value), 1))
				break;
			if (!soap_in_PointerTons3__value(soap, tag, NULL, "ns3:value"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons3__value(soap, tag, &n, "ns3:value"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__value * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__value(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__value(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons3__value, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__value * >);
		if (size)
			*size = sizeof(std::vector<ns3__value * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__value * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns3__value * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns3__value * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__value(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__value * > %p -> %p\n", q, p));
	*(std::vector<ns3__value * >*)p = *(std::vector<ns3__value * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__tupleValues(struct soap *soap, std::vector<ns3__tupleValues * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__tupleValues(struct soap *soap, const std::vector<ns3__tupleValues * >*a)
{
	for (std::vector<ns3__tupleValues * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__tupleValues(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__tupleValues(struct soap *soap, const char *tag, int id, const std::vector<ns3__tupleValues * >*a, const char *type)
{
	for (std::vector<ns3__tupleValues * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__tupleValues(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__tupleValues * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__tupleValues(struct soap *soap, const char *tag, std::vector<ns3__tupleValues * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__tupleValues(soap, -1)))
		return NULL;
	ns3__tupleValues *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns3__tupleValues, SOAP_TYPE_std__vectorTemplateOfPointerTons3__tupleValues, sizeof(ns3__tupleValues), 1))
				break;
			if (!soap_in_PointerTons3__tupleValues(soap, tag, NULL, "ns3:tupleValues"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons3__tupleValues(soap, tag, &n, "ns3:tupleValues"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__tupleValues * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__tupleValues(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__tupleValues(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons3__tupleValues, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__tupleValues * >);
		if (size)
			*size = sizeof(std::vector<ns3__tupleValues * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__tupleValues * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns3__tupleValues * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns3__tupleValues * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__tupleValues(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__tupleValues * > %p -> %p\n", q, p));
	*(std::vector<ns3__tupleValues * >*)p = *(std::vector<ns3__tupleValues * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__tupleMembers(struct soap *soap, std::vector<ns3__tupleMembers * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__tupleMembers(struct soap *soap, const std::vector<ns3__tupleMembers * >*a)
{
	for (std::vector<ns3__tupleMembers * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__tupleMembers(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__tupleMembers(struct soap *soap, const char *tag, int id, const std::vector<ns3__tupleMembers * >*a, const char *type)
{
	for (std::vector<ns3__tupleMembers * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__tupleMembers(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__tupleMembers * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__tupleMembers(struct soap *soap, const char *tag, std::vector<ns3__tupleMembers * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__tupleMembers(soap, -1)))
		return NULL;
	ns3__tupleMembers *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns3__tupleMembers, SOAP_TYPE_std__vectorTemplateOfPointerTons3__tupleMembers, sizeof(ns3__tupleMembers), 1))
				break;
			if (!soap_in_PointerTons3__tupleMembers(soap, tag, NULL, "ns3:tupleMembers"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons3__tupleMembers(soap, tag, &n, "ns3:tupleMembers"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__tupleMembers * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__tupleMembers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__tupleMembers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons3__tupleMembers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__tupleMembers * >);
		if (size)
			*size = sizeof(std::vector<ns3__tupleMembers * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__tupleMembers * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns3__tupleMembers * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns3__tupleMembers * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__tupleMembers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__tupleMembers * > %p -> %p\n", q, p));
	*(std::vector<ns3__tupleMembers * >*)p = *(std::vector<ns3__tupleMembers * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons3__memberDic(struct soap *soap, std::vector<ns3__memberDic * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons3__memberDic(struct soap *soap, const std::vector<ns3__memberDic * >*a)
{
	for (std::vector<ns3__memberDic * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons3__memberDic(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons3__memberDic(struct soap *soap, const char *tag, int id, const std::vector<ns3__memberDic * >*a, const char *type)
{
	for (std::vector<ns3__memberDic * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons3__memberDic(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns3__memberDic * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons3__memberDic(struct soap *soap, const char *tag, std::vector<ns3__memberDic * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons3__memberDic(soap, -1)))
		return NULL;
	ns3__memberDic *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns3__memberDic, SOAP_TYPE_std__vectorTemplateOfPointerTons3__memberDic, sizeof(ns3__memberDic), 1))
				break;
			if (!soap_in_PointerTons3__memberDic(soap, tag, NULL, "ns3:memberDic"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons3__memberDic(soap, tag, &n, "ns3:memberDic"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns3__memberDic * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons3__memberDic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons3__memberDic(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons3__memberDic, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__memberDic * >);
		if (size)
			*size = sizeof(std::vector<ns3__memberDic * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns3__memberDic * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns3__memberDic * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns3__memberDic * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons3__memberDic(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns3__memberDic * > %p -> %p\n", q, p));
	*(std::vector<ns3__memberDic * >*)p = *(std::vector<ns3__memberDic * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfint(struct soap *soap, const std::vector<int >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfint(struct soap *soap, const char *tag, int id, const std::vector<int >*a, const char *type)
{
	for (std::vector<int >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_int(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<int >* SOAP_FMAC4 soap_in_std__vectorTemplateOfint(struct soap *soap, const char *tag, std::vector<int >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfint(soap, -1)))
		return NULL;
	int n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_int(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_int, SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0))
				break;
			if (!soap_in_int(soap, tag, NULL, "xsd:int"))
				break;
		}
		else
		{
			if (!soap_in_int(soap, tag, &n, "xsd:int"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<int > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<int >);
		if (size)
			*size = sizeof(std::vector<int >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<int >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<int >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<int >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<int > %p -> %p\n", q, p));
	*(std::vector<int >*)p = *(std::vector<int >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__entitySpec(struct soap *soap, std::vector<ns2__entitySpec * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__entitySpec(struct soap *soap, const std::vector<ns2__entitySpec * >*a)
{
	for (std::vector<ns2__entitySpec * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__entitySpec(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__entitySpec(struct soap *soap, const char *tag, int id, const std::vector<ns2__entitySpec * >*a, const char *type)
{
	for (std::vector<ns2__entitySpec * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__entitySpec(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__entitySpec * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__entitySpec(struct soap *soap, const char *tag, std::vector<ns2__entitySpec * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__entitySpec(soap, -1)))
		return NULL;
	ns2__entitySpec *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__entitySpec, SOAP_TYPE_std__vectorTemplateOfPointerTons2__entitySpec, sizeof(ns2__entitySpec), 1))
				break;
			if (!soap_in_PointerTons2__entitySpec(soap, tag, NULL, "ns2:entitySpec"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__entitySpec(soap, tag, &n, "ns2:entitySpec"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__entitySpec * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__entitySpec(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__entitySpec(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__entitySpec, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__entitySpec * >);
		if (size)
			*size = sizeof(std::vector<ns2__entitySpec * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__entitySpec * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__entitySpec * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__entitySpec * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__entitySpec(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__entitySpec * > %p -> %p\n", q, p));
	*(std::vector<ns2__entitySpec * >*)p = *(std::vector<ns2__entitySpec * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__setSpec(struct soap *soap, std::vector<ns2__setSpec * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__setSpec(struct soap *soap, const std::vector<ns2__setSpec * >*a)
{
	for (std::vector<ns2__setSpec * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__setSpec(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__setSpec(struct soap *soap, const char *tag, int id, const std::vector<ns2__setSpec * >*a, const char *type)
{
	for (std::vector<ns2__setSpec * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__setSpec(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__setSpec * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__setSpec(struct soap *soap, const char *tag, std::vector<ns2__setSpec * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__setSpec(soap, -1)))
		return NULL;
	ns2__setSpec *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__setSpec, SOAP_TYPE_std__vectorTemplateOfPointerTons2__setSpec, sizeof(ns2__setSpec), 1))
				break;
			if (!soap_in_PointerTons2__setSpec(soap, tag, NULL, "ns2:setSpec"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__setSpec(soap, tag, &n, "ns2:setSpec"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__setSpec * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__setSpec(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__setSpec(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__setSpec, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__setSpec * >);
		if (size)
			*size = sizeof(std::vector<ns2__setSpec * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__setSpec * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__setSpec * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__setSpec * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__setSpec(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__setSpec * > %p -> %p\n", q, p));
	*(std::vector<ns2__setSpec * >*)p = *(std::vector<ns2__setSpec * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
